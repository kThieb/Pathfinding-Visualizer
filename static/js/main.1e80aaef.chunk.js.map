{"version":3,"sources":["GridNode/GridNode.tsx","Grid/Grid.tsx","NavBar/NavBar.tsx","helperFunctions/shortestPathAlgorithms/retrievePath.ts","helperFunctions/ensureNotUndefined.ts","helperFunctions/shortestPathAlgorithms/dfs.ts","helperFunctions/dataStructures/binaryHeap.ts","helperFunctions/shortestPathAlgorithms/aStar.ts","helperFunctions/shortestPathAlgorithms/allAlgorithms.ts","helperFunctions/shortestPathAlgorithms/bfs.ts","helperFunctions/shortestPathAlgorithms/dijkstra.ts","helperFunctions/mazeGenerators/mazeGraph.ts","helperFunctions/constructGrid.ts","Wrapper/Wrapper.tsx","Visualizer/Visualizer.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["getAddedClassName","neighbors","node","addedClassName","i","length","neighbor","neighborX","neighborY","x","y","hasCheese","isShortestPath","isVisited","GridNode","React","memo","numberOfElementsPerRow","className","isStart","role","aria-label","isEnd","addEmoji","prevProps","nextProps","Grid","grid","maze","pairGrid","map","row","id","rowLength","key","index","ensure","get","argument","message","undefined","TypeError","NavBar","props","children","NavButton","addedClassNames","startClassName","visualizingClassName","visualizedClassName","isVisualized","onClick","e","handleClick","text","NavItem","useState","open","setOpen","shouldGreyOut","event","document","addEventListener","dropDownMenu","getElementById","targetElement","target","parentNode","DropDownMenu","style","height","DropDownItem","leftIcon","rightIcon","DropDownSlider","type","value","defaultValue","min","minValue","toString","max","maxValue","step","onChange","handleChange","retrievePath","predecessor","startNode","endNode","shortestPath","current","unshift","BinaryHeap","compare","content","this","element","push","bubbleUp","result","end","pop","sinkDown","n","parentN","Math","floor","parent","child2N","child1N","swap","manhattanDistance","a","b","abs","algorithms","mazeGraph","m","fill","visited","discovered","stack","currentNode","find","visitedNode","discoveredNode","nextNode","q","shift","distances","j","Number","MAX_SAFE_INTEGER","pq","size","currentX","currentY","currentDistance","remove","dA","dB","generateMazeGraph","columnLength","wallsDensity","pairRow","Map","set","createMazeGraph","currentWallsCount","currentNonVisitedNeighbors","getNeighbors","neighborNode","random","maxWallsCount","randRow","getNeighborsII","randIndex","dir","includes","constructGrid","numberOfRow","numberOfColumn","currentRow","WrapperCSSTransition","handleEnter","nodeRef","useRef","CSSTransition","onEnter","isAppearing","el","offsetHeight","ref","firstGrid","firstStartNode","firstEndNode","firstpairGrid","Visualizer","setGrid","setMaze","setPairGrid","algorithm","setAlgorithm","setWallsDensity","setIsVisualized","algoActiveMenu","setAlgoActiveMenu","setHeight","setStartNode","setEndNode","handleAlgorithmChange","algorithmName","handleMenuChange","menuName","newGrid","newStartNode","newEndNode","newPairGrid","newMaze","slice","path","setTimeout","newNode","visualizeAlgorithm","in","unmountOnExit","timeout","classNames","appear","App","exact","component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console"],"mappings":"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","file":"static/js/main.1e80aaef.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./GridNode.css\";\nimport { node } from \"../helperFunctions/usefulInterfaces\";\n\ninterface Props {\n  numberOfElementsPerRow: number;\n  node: node;\n  neighbors: [number, number][];\n}\n\nconst getAddedClassName: (\n  neighbors: [number, number][],\n  node: node\n) => string = (neighbors, node) => {\n  let addedClassName: string = \"\";\n  for (let i = 0; i < neighbors.length; i++) {\n    let neighbor: [number, number] = neighbors[i];\n    let neighborX = neighbor[0];\n    let neighborY = neighbor[1];\n    if (neighborX === node.x + 1) addedClassName += \" no-wall-bottom\";\n    if (neighborX === node.x - 1) addedClassName += \" no-wall-top\";\n    if (neighborY === node.y + 1) addedClassName += \" no-wall-right\";\n    if (neighborY === node.y - 1) addedClassName += \" no-wall-left\";\n  }\n  if (node.hasCheese) addedClassName += \" cheese\";\n  if (node.isShortestPath) addedClassName += \" shortest-path-node\";\n  if (node.isVisited) addedClassName += \" visited-node\";\n  return addedClassName;\n};\n\n// This component represents a single Node in the grid rendered in the DOM\nexport const _GridNode: React.FC<Props> = ({\n  numberOfElementsPerRow,\n  node,\n  neighbors,\n}) => {\n  const addEmoji: (node: node) => any = (node) => {\n    if (node.isStart) {\n      return (\n        <span role=\"img\" aria-label=\"rat\" className=\"content\">\n          🐀\n        </span>\n      );\n    }\n    if (node.isEnd) {\n      return (\n        <span role=\"img\" aria-label=\"rat\" className=\"content\">\n          🧀\n        </span>\n      );\n    }\n    return <span></span>;\n  };\n\n  return (\n    <div className={\"grid-node\" + getAddedClassName(neighbors, node)}>\n      {addEmoji(node)}\n    </div>\n  );\n};\n\nconst areEqual: (prevProps: Props, nextProps: Props) => boolean = (\n  prevProps,\n  nextProps\n) => {\n  return (\n    prevProps.node.isVisited === nextProps.node.isVisited &&\n    prevProps.node.isShortestPath === nextProps.node.isShortestPath &&\n    getAddedClassName(prevProps.neighbors, prevProps.node) ===\n      getAddedClassName(nextProps.neighbors, nextProps.node)\n  );\n};\n\nexport const GridNode = React.memo(_GridNode, areEqual);\n","import React from \"react\";\nimport { GridNode } from \"../GridNode/GridNode\";\nimport \"./Grid.css\";\nimport { node } from \"../helperFunctions/usefulInterfaces\";\n\ninterface Props {\n  grid: node[][];\n  maze: Map<[number, number], [number, number][]>;\n  pairGrid: [number, number][][];\n}\n\nexport const Grid: React.FC<Props> = ({ grid, maze, pairGrid }) => {\n  // Renders the grid in the DOM thanks to the grid state in the App component\n  return (\n    <div className=\"grid\">\n      {grid.map((row, id) => {\n        let rowLength = row.length;\n        return (\n          <div className=\"row\" key={id}>\n            {row.map((node, index) => (\n              <GridNode\n                numberOfElementsPerRow={rowLength}\n                key={id + index * rowLength}\n                node={node}\n                neighbors={ensure(maze.get(pairGrid[node.x][node.y]))}\n              ></GridNode>\n            ))}\n          </div>\n        );\n      })}\n    </div>\n  );\n};\n\n// This function is there to ensure that a value is not null or undefined\nfunction ensure<T>(\n  argument: T | undefined | null,\n  message: string = \"This value was promised to be there.\"\n): T {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}\n","import React, { useState } from \"react\";\nimport \"./NavBar.css\";\n\nexport const NavBar: React.FC = (props) => {\n  return (\n    <nav className=\"navbar\">\n      <ul className=\"navbar-nav\">{props.children}</ul>\n    </nav>\n  );\n};\n\ninterface NavButtonProps {\n  text: string;\n  isVisualized: number;\n  className: string;\n  startClassName?: string;\n  visualizingClassName: string;\n  visualizedClassName: string;\n  handleClick: () => void;\n}\n\nexport const NavButton: React.FC<NavButtonProps> = (props) => {\n  const addedClassNames: string[] = [\n    props.startClassName ? props.startClassName : \"\",\n    props.visualizingClassName,\n    props.visualizedClassName,\n  ];\n\n  return (\n    <li\n      className={\n        \"nav-item \" +\n        addedClassNames[props.isVisualized] +\n        \" \" +\n        props.className\n      }\n      onClick={(e) => {\n        props.handleClick();\n      }}\n    >\n      <p>{props.text}</p>\n    </li>\n  );\n};\n\ninterface NavItemProps {\n  text: string;\n  id: string;\n  isVisualized: number;\n  shouldGreyOut: boolean;\n}\n\nexport const NavItem: React.FC<NavItemProps> = (props) => {\n  const [open, setOpen] = useState(false);\n\n  const handleClick: (e: any) => void = (event) => {\n    if (!props.shouldGreyOut || !props.isVisualized) setOpen(!open);\n    document.addEventListener(\"click\", (e) => {\n      const dropDownMenu = document.getElementById(props.id);\n      let targetElement = e.target as Element;\n\n      do {\n        if (targetElement === dropDownMenu) return;\n        targetElement = targetElement.parentNode as Element;\n      } while (targetElement);\n      setOpen(false);\n    });\n  };\n\n  return (\n    <li\n      id={props.id}\n      className={\n        \"nav-item\" +\n        (props.shouldGreyOut && props.isVisualized ? \" greyed-out\" : \"\")\n      }\n    >\n      <p className=\"icon-button\" onClick={handleClick}>\n        {props.text}\n      </p>\n      {open && props.children}\n    </li>\n  );\n};\n\ninterface DropDownMenu {\n  height?: number;\n}\n\nexport const DropDownMenu: React.FC<DropDownMenu> = (props) => {\n  return (\n    <div className=\"dropdown\" style={{ height: props.height }}>\n      {props.children}\n    </div>\n  );\n};\n\ninterface DropDownAlgoProps {\n  leftIcon?: string;\n  rightIcon?: string;\n  handleClick: () => void;\n}\n\nexport const DropDownItem: React.FC<DropDownAlgoProps> = (props) => {\n  return (\n    <div\n      className=\"menu-item\"\n      onClick={(e) => {\n        props.handleClick();\n      }}\n    >\n      <span>{props.leftIcon ? props.leftIcon : \"\"}</span>\n      {props.children}\n      <span>{props.rightIcon ? props.rightIcon : \"\"}</span>\n    </div>\n  );\n};\n\ninterface DropDownSliderProps {\n  minValue: number;\n  maxValue: number;\n  defaultValue: number;\n  text: string;\n  handleChange: (event: any) => void;\n}\n\nexport const DropDownSlider: React.FC<DropDownSliderProps> = (props) => {\n  return (\n    <div className=\"slider-item\">\n      <div>\n        <p>{props.text}</p>\n      </div>\n      <input\n        className=\"slider\"\n        type=\"range\"\n        value={props.defaultValue}\n        min={props.minValue.toString()}\n        max={props.maxValue.toString()}\n        step={0.01}\n        onChange={(e) => props.handleChange(e.target.value)}\n      ></input>\n    </div>\n  );\n};\n","import { node } from \"../usefulInterfaces\";\n\nexport const retrievePath: (\n  predecessor: node[],\n  startNode: node,\n  endNode: node\n) => node[] = (predecessor, startNode, endNode) => {\n  let shortestPath = [endNode];\n  let current = endNode;\n  while (current !== startNode) {\n    current = predecessor[current.id];\n    shortestPath.unshift(current);\n  }\n\n  return shortestPath;\n};\n","// This function is here to ensure that a value is not undefined (especially when using arrays).\nexport function ensure<T>(\n  argument: T | undefined | null,\n  message: string = \"This value was promised to be there.\"\n): T {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n  return argument;\n}\n","import { node } from \"../usefulInterfaces\";\nimport { retrievePath } from \"./retrievePath\";\nimport { ensure } from \"../ensureNotUndefined\";\n\nexport const dfs: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [number, number][]>,\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  // Discovered array\n  let discovered: node[] = [startNode];\n\n  // Initialize the stack\n  let stack: node[] = [startNode];\n\n  // While the stack is not empty\n  while (stack.length > 0) {\n    // Get the element in front of the stack\n    let currentNode: node = ensure(stack.pop());\n\n    if (visited.find((visitedNode) => visitedNode === currentNode)) continue;\n\n    // Put the currentNode node in the visited set\n    visited.push(currentNode);\n\n    // If we found the end node, return the path to it\n    if (currentNode === endNode) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, endNode);\n      return [visited, shortestPath];\n    }\n\n    // iterate through the neighbors of the currentNode node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentNode.x][currentNode.y])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0],\n        neighborY: number = neighbor[1];\n\n      // Check if the node is on the board\n      if (\n        neighborX < 0 ||\n        neighborX >= m ||\n        neighborY < 0 ||\n        neighborY >= n ||\n        discovered.find(\n          (discoveredNode) => discoveredNode === grid[neighborX][neighborY]\n        )\n      )\n        continue;\n\n      // Get the node in the grid\n      let nextNode: node = grid[neighborX][neighborY];\n\n      // update the predecessor array\n      predecessor[nextNode.id] = currentNode;\n\n      // Add the node to the discovered array\n      discovered.push(nextNode);\n\n      // Push the nextNode to the stack\n      stack.push(nextNode);\n    }\n  }\n\n  return [visited, []];\n};\n","import { ensure } from \"../ensureNotUndefined\";\n\nexport class BinaryHeap<T> {\n  content: ([T, number] | undefined)[];\n  compare: (a: [T, number], b: [T, number]) => boolean;\n  index: number;\n\n  constructor(compare: (a: [T, number], b: [T, number]) => boolean) {\n    this.content = [];\n    this.index = 1;\n    this.compare = compare;\n  }\n\n  push(element: T) {\n    this.content.push([element, this.index++]);\n    this.bubbleUp(this.content.length - 1);\n  }\n\n  pop(): T | undefined {\n    let result: [T, number] = ensure(this.content[0]);\n    let end: [T, number] | undefined = this.content.pop();\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n    return ensure(result)[0];\n  }\n\n  remove(node: T) {\n    let length: number = this.content.length;\n    // To remove a value, we must search through the array to find\n    // it.\n    for (let i: number = 0; i < length; i++) {\n      if (ensure(this.content[i])[0] !== node) continue;\n      // When it is found, the process seen in 'pop' is repeated\n      // to fill up the hole.\n      let end: [T, number] | undefined = this.content.pop();\n      // If the element we popped was the one we needed to remove,\n      // we're done.\n      if (i === length - 1) break;\n      // Otherwise, we replace the removed element with the popped\n      // one, and allow it to float up or sink down as appropriate.\n      this.content[i] = end;\n      this.bubbleUp(i);\n      this.sinkDown(i);\n      break;\n    }\n  }\n\n  size() {\n    return this.content.length;\n  }\n\n  private bubbleUp(n: number) {\n    // Fetch the element that has to be moved.\n    let element: [T, number] = ensure(this.content[n]);\n    // When at 0, an element can not go up any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      let parentN: number = Math.floor((n + 1) / 2) - 1,\n        parent: [T, number] = ensure(this.content[parentN]);\n      // If the parent has a lesser score, things are in order and we\n      // are done.\n      // if (\n      //   score > this.scoreFunction(ensure(parent)[0]) ||\n      //   (score === this.scoreFunction(ensure(parent)[0]) &&\n      //     ensure(element)[1] > ensure(parent)[1])\n      // )\n      //   break;\n      if (this.compare(parent, element)) break;\n\n      // Otherwise, swap the parent with the current element and\n      // continue.\n      this.content[parentN] = element;\n      this.content[n] = parent;\n      n = parentN;\n    }\n  }\n\n  private sinkDown(n: number) {\n    // Look up the target element and its score.\n    let length: number = this.content.length,\n      element: [T, number] = ensure(this.content[n]);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      let child2N: number = (n + 1) * 2,\n        child1N: number = child2N - 1;\n      let swap: number = n;\n      // This is used to store the new position of the element, if any.\n      // If the first child exists (is inside the array)...\n      if (\n        child1N < length &&\n        this.compare(ensure(this.content[child1N]), element)\n      )\n        swap = child1N;\n      if (\n        child2N < length &&\n        this.compare(ensure(this.content[child2N]), ensure(this.content[swap]))\n      )\n        swap = child2N;\n\n      // If the order is good, we exit the loop\n      if (swap === n) break;\n\n      // Otherwise, swap and continue.\n      this.content[n] = this.content[swap];\n      this.content[swap] = element;\n      n = swap;\n    }\n  }\n}\n","import { node } from \"../usefulInterfaces\";\nimport { BinaryHeap } from \"../dataStructures/binaryHeap\";\nimport { retrievePath } from \"./retrievePath\";\nimport { ensure } from \"../ensureNotUndefined\";\n\nexport const aStar: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [number, number][]>,\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>(\n    (a: [node, number], b: [node, number]) => {\n      let dA: number = manhattanDistance(a[0], endNode),\n        dB: number = manhattanDistance(b[0], endNode);\n      if (distances[a[0].x][a[0].y] + dA !== distances[b[0].x][b[0].y] + dB) {\n        return distances[a[0].x][a[0].y] + dA < distances[b[0].x][b[0].y] + dB;\n      }\n      return a[1] < b[1];\n    }\n  );\n\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    visited.push(currentNode);\n\n    // If we found the endNode, return the shortest path to it\n    if (currentNode === endNode) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, endNode);\n      return [visited, shortestPath];\n    }\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentX][currentY])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0],\n        neighborY: number = neighbor[1];\n\n      // Check if the coordinates are valid\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n)\n        continue;\n\n      let nextNode: node = grid[neighbor[0]][neighbor[1]];\n\n      // Calculate the distance between the current node and the next node\n      // To Do: take into account the weight of the path\n      let currentDistance: number = distances[currentX][currentY] + 1;\n\n      // If the distance is less than the distance in the array distances,\n      // change it and change the predecessor of the next node to be the current one\n      if (currentDistance < distances[neighbor[0]][neighbor[1]]) {\n        predecessor[nextNode.id] = currentNode;\n        distances[neighbor[0]][neighbor[1]] = currentDistance;\n      }\n\n      // If the node is not yet visited, remove it from the heap and\n      // put it back in with its new distance as the score function\n      if (!visited.find((visitedNode) => visitedNode === nextNode)) {\n        pq.remove(nextNode);\n        pq.push(nextNode);\n      }\n    }\n  }\n  return [visited, []];\n};\n\nconst manhattanDistance: (a: node, b: node) => number = (a, b) => {\n  return Math.abs(b.x - a.x) + Math.abs(b.y - a.y);\n};\n","import { node } from \"../usefulInterfaces\";\nimport { dfs } from \"./dfs\";\nimport { bfs } from \"./bfs\";\nimport { dijkstraWithWalls } from \"./dijkstra\";\nimport { aStar } from \"./aStar\";\n\nexport const algorithms: {\n  [key: string]: (\n    grid: node[][],\n    pairGrid: [number, number][][],\n    mazeGraph: Map<[number, number], [number, number][]>,\n    startNode: node,\n    targetNode: node\n  ) => [node[], node[]];\n} = {\n  \"Depth First Search\": dfs,\n  \"Breadth First Search\": bfs,\n  \"Dijkstra's algorithm\": dijkstraWithWalls,\n  \"A* algorithm\": aStar,\n};\n","import { node } from \"../usefulInterfaces\";\nimport { retrievePath } from \"./retrievePath\";\nimport { ensure } from \"../ensureNotUndefined\";\n\nexport const bfs: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [number, number][]>,\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  // Initialize the discovered array\n  let discovered: node[] = [startNode];\n\n  // Initialize the Queue TODO: IMPLEMENT A BETTER VERSION OF THE QUEUE WITH O(1) OPERATIONS\n  let q: node[] = [startNode];\n\n  // While the queue is not empty\n  while (q.length > 0) {\n    // Get the element in front of the queue\n    let currentNode: node = ensure(q.shift());\n\n    if (visited.find((visitedNode) => visitedNode === currentNode)) continue;\n\n    // Put the currentNode node in the visited set\n    visited.push(currentNode);\n\n    // If we found the end node, return the path to it\n    if (currentNode === endNode) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, endNode);\n      return [visited, shortestPath];\n    }\n\n    // iterate through the neighbors of the currentNode node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentNode.x][currentNode.y])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0],\n        neighborY: number = neighbor[1];\n\n      if (\n        neighborX < 0 ||\n        neighborX >= m ||\n        neighborY < 0 ||\n        neighborY >= n ||\n        discovered.find(\n          (discoveredNode) => discoveredNode === grid[neighborX][neighborY]\n        )\n      )\n        continue;\n\n      // Get the node in the grid\n      let nextNode: node = grid[neighborX][neighborY];\n\n      // update the predecessor array\n      predecessor[nextNode.id] = currentNode;\n\n      // Add the node to the visited nodes\n      discovered.push(nextNode);\n\n      // Push the next node to the queue\n      q.push(nextNode);\n    }\n  }\n\n  return [visited, []];\n};\n","import { node } from \"../usefulInterfaces\";\nimport { BinaryHeap } from \"../dataStructures/binaryHeap\";\nimport { retrievePath } from \"./retrievePath\";\nimport { ensure } from \"../ensureNotUndefined\";\n\nexport const dijkstraWithWalls: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [number, number][]>,\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>(\n    (a: [node, number], b: [node, number]) => {\n      if (distances[a[0].x][a[0].y] !== distances[b[0].x][b[0].y]) {\n        return distances[a[0].x][a[0].y] < distances[b[0].x][b[0].y];\n      }\n      return a[1] < b[1];\n    }\n  );\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    visited.push(currentNode);\n\n    // If we found the endNode, return the shortest path to it\n    if (currentNode === endNode) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, endNode);\n      return [visited, shortestPath];\n    }\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentX][currentY])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0],\n        neighborY: number = neighbor[1];\n\n      // Check if the coordinates are valid\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n)\n        continue;\n\n      let nextNode: node = grid[neighbor[0]][neighbor[1]];\n\n      // Calculate the distance between the current node and the next node\n      // To Do: take into account the weight of the path\n      let currentDistance: number = distances[currentX][currentY] + 1;\n\n      // If the distance is less than the distance in the array distances,\n      // change it and change the predecessor of the next node to be the current one\n      if (currentDistance < distances[neighbor[0]][neighbor[1]]) {\n        predecessor[nextNode.id] = currentNode;\n        distances[neighbor[0]][neighbor[1]] = currentDistance;\n      }\n\n      // If the node is not yet visited, remove it from the heap and\n      // put it back in with its new distance as the score function\n      if (!visited.find((visitedNode) => visitedNode === nextNode)) {\n        pq.remove(nextNode);\n        pq.push(nextNode);\n      }\n    }\n  }\n\n  return [visited, []];\n};\n","import { node } from \"../usefulInterfaces\";\n\n// TODO: Refactor the code to use the different key-values pair as the nodes get changed when there is a setGrid that is applied\n\nconst createMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][]\n) => [[number, number][][], Map<[number, number], [number, number][]>] = (\n  rowLength,\n  columnLength,\n  grid\n) => {\n  let pairGrid: [number, number][][] = [];\n  for (let i: number = 0; i < columnLength; i++) {\n    let pairRow: [number, number][] = [];\n    for (let j: number = 0; j < rowLength; j++) {\n      let currentNode: node = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n    pairGrid.push(pairRow);\n  }\n\n  // Create the maze graph\n  let mazeGraph: Map<[number, number], [number, number][]> = new Map();\n  for (let i: number = 0; i < columnLength; i++) {\n    for (let j: number = 0; j < rowLength; j++) {\n      mazeGraph.set(pairGrid[i][j], []);\n    }\n  }\n  return [pairGrid, mazeGraph];\n};\n\nexport const createEmptyMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][]\n) => [[number, number][][], Map<[number, number], [number, number][]>] = (\n  rowLength,\n  columnLength,\n  grid\n) => {\n  let pairGrid: [number, number][][] = [];\n  for (let i: number = 0; i < columnLength; i++) {\n    let pairRow: [number, number][] = [];\n    for (let j: number = 0; j < rowLength; j++) {\n      let currentNode: node = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n    pairGrid.push(pairRow);\n  }\n  // Create the maze graph\n  let mazeGraph: Map<[number, number], [number, number][]> = new Map();\n  for (let i: number = 0; i < columnLength; i++) {\n    for (let j: number = 0; j < rowLength; j++) {\n      let neighbors: [number, number][] = getNeighborsEmpty(\n        pairGrid,\n        [i, j],\n        columnLength,\n        rowLength\n      );\n\n      mazeGraph.set(pairGrid[i][j], neighbors);\n    }\n  }\n  return [pairGrid, mazeGraph];\n};\n\nexport const generateMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][],\n  wallsDensity: number\n) => [[number, number][][], Map<[number, number], [number, number][]>] = (\n  rowLength,\n  columnLength,\n  grid,\n  wallsDensity\n) => {\n  let [pairGrid, mazeGraph] = createMazeGraph(rowLength, columnLength, grid);\n\n  // I. Generate a maze where each cells is reachable (with a DFS)\n  let currentWallsCount: number =\n    2 * (rowLength - 1) * (columnLength - 1) + rowLength + columnLength - 2;\n\n  // 1. Choose the initial cell, mark it as visited and push it to the stack\n  let startNode: [number, number] = pairGrid[0][0];\n  let stack: [number, number][] = [startNode];\n  let visited: [number, number][] = [startNode];\n\n  // 2. While the stack is not empty\n  while (stack.length > 0) {\n    // 1. Pop a cell from the stack and make it a current cell\n    let currentNode: [number, number] = ensure(stack.pop());\n    let currentNonVisitedNeighbors: [number, number][] = getNeighbors(\n      pairGrid,\n      currentNode,\n      rowLength,\n      columnLength,\n      visited\n    );\n    // 2. If the current cell has any neighbours which have not been visited\n    if (currentNonVisitedNeighbors.length > 0) {\n      // 1. Push the current cell to the stack\n      stack.push(currentNode);\n\n      // 2. Choose one of the unvisited neighbours\n      let randIndex: number = Math.floor(\n        Math.random() * currentNonVisitedNeighbors.length\n      );\n      let neighborNode: [number, number] =\n        currentNonVisitedNeighbors[randIndex];\n\n      // 3. Remove the wall between the current cell and the chosen cell\n      let currentNodeNeighbors: [number, number][] = ensure(\n        mazeGraph.get(currentNode)\n      );\n      currentNodeNeighbors.push(neighborNode);\n\n      let neighborNodeNeighbors: [number, number][] = ensure(\n        mazeGraph.get(neighborNode)\n      );\n      neighborNodeNeighbors.push(currentNode);\n\n      // 4. Mark the chosen cell as visited and push it to the stack\n      visited.push(neighborNode);\n      stack.push(neighborNode);\n\n      // 5. Remove 1 from the currentWallsCount\n      currentWallsCount--;\n    }\n  }\n\n  let maxWallsCount: number = currentWallsCount;\n  // II. Remove walls until the desired density is achieved\n  while (currentWallsCount * (1 / maxWallsCount) > wallsDensity) {\n    // 1. Choose a node randomly\n    let randRow: number = Math.floor(Math.random() * rowLength);\n    let randCol: number = Math.floor(Math.random() * columnLength);\n    let currentNode: [number, number] = pairGrid[randCol][randRow];\n\n    // 2. Get the cells with a wall with the current cell\n    let neighbors: [number, number][] = getNeighborsII(\n      pairGrid,\n      currentNode,\n      rowLength,\n      columnLength,\n      mazeGraph\n    );\n\n    if (neighbors.length > 0) {\n      // 3. Choose one of the cells with a wall\n      let randIndex: number = Math.floor(Math.random() * neighbors.length);\n      let neighborNode: [number, number] =\n        pairGrid[neighbors[randIndex][0]][neighbors[randIndex][1]];\n\n      // 4. Remove the wall between the 2 cells\n      let currentNodeNeighbors: [number, number][] = ensure(\n        mazeGraph.get(currentNode)\n      );\n      currentNodeNeighbors.push(neighborNode);\n      // mazeGraph.set(currentNode, currentNodeNeighbors);\n\n      let neighborNodeNeighbors: [number, number][] = ensure(\n        mazeGraph.get(neighborNode)\n      );\n      neighborNodeNeighbors.push(currentNode);\n      // mazeGraph.set(neighborNode, neighborNodeNeighbors);\n\n      currentWallsCount--;\n    }\n  }\n  return [pairGrid, mazeGraph];\n};\n\nconst getNeighbors: (\n  grid: [number, number][][],\n  currentNode: [number, number],\n  rowLength: number,\n  columnLength: number,\n  visited: [number, number][]\n) => [number, number][] = (\n  pairGrid,\n  currentNode,\n  rowLength,\n  columnLength,\n  visited\n) => {\n  const directions = [\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n    [0, 1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength &&\n      !visited.includes(pairGrid[neighborX][neighborY])\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n\nexport const getNeighborsEmpty: (\n  pairGrid: [number, number][][],\n  currentNode: [number, number],\n  columnLength: number,\n  rowLength: number\n) => [number, number][] = (pairGrid, currentNode, columnLength, rowLength) => {\n  const directions = [\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n    [0, 1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n\nconst getNeighborsII: (\n  pairGrid: [number, number][][],\n  currentNode: [number, number],\n  rowLength: number,\n  columnLength: number,\n  mazeGraph: Map<[number, number], [number, number][]>\n) => [number, number][] = (\n  pairGrid,\n  currentNode,\n  rowLength,\n  columnLength,\n  mazeGraph\n) => {\n  const directions = [\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n    [0, 1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength &&\n      !mazeGraph.get(currentNode)?.includes(pairGrid[neighborX][neighborY])\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n\nfunction ensure<T>(\n  argument: T | undefined | null,\n  message: string = \"This value was promised to be there.\"\n): T {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}\n","import { node } from \"./usefulInterfaces\";\n\n// This function (Not a React Component!) is made to initialize the grid rendered in the App component.\nexport const constructGrid: (\n  numberOfRows: number,\n  numberOfColumn: number,\n  startNode: [number, number],\n  endNode: [number, number]\n) => [node[][], node, node] = (\n  numberOfRow,\n  numberOfColumn,\n  startNode,\n  endNode\n) => {\n  let result: node[][] = [];\n  for (let i: number = 0; i < numberOfColumn; i++) {\n    let currentRow: node[] = [];\n    for (let j: number = 0; j < numberOfRow; j++) {\n      let currentNode: node = {\n        id: i + j * numberOfColumn,\n        x: i,\n        y: j,\n        isStart: false,\n        isEnd: false,\n        isVisited: false,\n        isShortestPath: false,\n        hasCheese: false,\n      };\n      currentRow.push(currentNode);\n    }\n    result.push(currentRow);\n  }\n  result[startNode[0]][startNode[1]].isStart = true;\n  result[endNode[0]][endNode[1]].isEnd = true;\n  // result = piecesOfCheese(result, numberOfColumn, numberOfRow, 21);\n  return [\n    result,\n    result[startNode[0]][startNode[1]],\n    result[endNode[0]][endNode[1]],\n  ];\n};\n\nconst piecesOfCheese: (\n  grid: node[][],\n  m: number,\n  n: number,\n  cheeseNum: number\n) => node[][] = (grid, m, n, cheeseNum) => {\n  let visited: boolean[][] = new Array(n);\n  for (let i: number = 0; i < n; ++i) {\n    visited[i] = new Array(n);\n  }\n  for (let i: number = 0; i < n; ++i) {\n    for (let j: number = 0; j < n; ++j) {\n      visited[i][j] = false;\n    }\n  }\n\n  visited[0][0] = true;\n  visited[n - 1][n - 1] = true;\n  for (let k: number = 0; k < cheeseNum / 2; k++) {\n    let i = -1,\n      j = -1;\n    do {\n      i = Math.floor(Math.random() * n);\n      j = Math.floor(Math.random() * n);\n    } while (visited[i][j]);\n    visited[i][j] = true;\n    visited[n - 1 - i][n - 1 - j] = true;\n    grid[i][j].hasCheese = true;\n    grid[n - 1 - i][n - 1 - j].hasCheese = true;\n  }\n  grid[Math.floor(n / 2)][Math.floor(n / 2)].hasCheese = true;\n  return grid;\n};\n","import React, { useRef } from \"react\";\nimport { CSSTransition } from \"react-transition-group\";\n\ninterface WrapperProps {\n  handleEnter: any;\n  timeout: number;\n  classNames: string;\n  in: boolean;\n  unmountOnExit: boolean;\n  appear?: boolean;\n}\n\nexport const WrapperCSSTransition: React.FC<WrapperProps> = ({\n  handleEnter,\n  ...props\n}) => {\n  const nodeRef = useRef<HTMLDivElement>(null);\n\n  // This function calculates the height of a DOM element\n  const calcHeight: (isAppearing: boolean) => void = (isAppearing) => {\n    const el = nodeRef.current;\n    const height: number = el !== null ? el.offsetHeight : 0;\n    handleEnter(height);\n  };\n\n  return (\n    <CSSTransition nodeRef={nodeRef} {...props} onEnter={calcHeight}>\n      <div ref={nodeRef}>{props.children}</div>\n    </CSSTransition>\n  );\n};\n","import React, { useState } from \"react\";\nimport \"./Visualizer.css\";\nimport { Grid } from \"../Grid/Grid\";\nimport {\n  NavBar,\n  NavItem,\n  DropDownMenu,\n  DropDownItem,\n  DropDownSlider,\n  NavButton,\n} from \"../NavBar/NavBar\";\nimport { node } from \"../helperFunctions/usefulInterfaces\";\nimport { algorithms } from \"../helperFunctions/shortestPathAlgorithms/allAlgorithms\";\nimport { generateMazeGraph } from \"../helperFunctions/mazeGenerators/mazeGraph\";\nimport { constructGrid } from \"../helperFunctions/constructGrid\";\nimport { WrapperCSSTransition } from \"../Wrapper/Wrapper\";\n\nconst NUMBER_OF_COLUMNS: number = 28;\nconst NUMBER_OF_ROWS: number = 13;\nconst VISITED_ANIMATION_TIMEOUT: number = 35;\nconst PATH_ANIMATION_TIMEOUT: number = 60;\n\n// We define these constants out of the functional component\n// that the App uses to avoid re-running the functions to create\n// these each time there is a re-render\nconst [firstGrid, firstStartNode, firstEndNode] = constructGrid(\n  NUMBER_OF_COLUMNS,\n  NUMBER_OF_ROWS,\n  [6, 3],\n  [6, 24]\n);\n\nconst [firstpairGrid, mazeGraph] = generateMazeGraph(\n  NUMBER_OF_COLUMNS,\n  NUMBER_OF_ROWS,\n  firstGrid,\n  0.6\n);\n\n// Component rendering everything in the webpage.\nconst Visualizer: React.FC = () => {\n  // States managing the grid\n  const [grid, setGrid] = useState(firstGrid);\n  const [maze, setMaze] = useState(mazeGraph);\n  const [pairGrid, setPairGrid] = useState(firstpairGrid);\n  const [algorithm, setAlgorithm] = useState(\"Dijkstra's algorithm\");\n  const [wallsDensity, setWallsDensity] = useState(0.6);\n  const [isVisualized, setIsVisualized] = useState(0);\n\n  // States managing the dropdown menu\n  const [algoActiveMenu, setAlgoActiveMenu] = useState(\"main\");\n  const [height, setHeight] = useState(undefined);\n  // const [mouseIsPressed, setMouseIsPressed] = useState(false);\n\n  // States of the start and end node\n  const [startNode, setStartNode] = useState(firstStartNode);\n  const [endNode, setEndNode] = useState(firstEndNode);\n\n  // This function is there to visualize the algorithm chosen in the drop down menu\n  const visualizeAlgorithm: (visited: node[], path: node[]) => void = (\n    visited,\n    path\n  ) => {\n    const n = visited.length;\n    for (let i: number = 0; i < n; i++) {\n      setTimeout(() => {\n        const newGrid = grid.slice();\n        const node = visited[i];\n        // define the x and y of the current node\n        const x: number = node.x;\n        const y: number = node.y;\n        const newNode: node = {\n          ...node,\n          isVisited: true,\n        };\n        newGrid[x][y] = newNode;\n        setGrid(newGrid);\n      }, VISITED_ANIMATION_TIMEOUT * i);\n    }\n\n    const m = path.length;\n    for (let i: number = 0; i < m; i++) {\n      setTimeout(() => {\n        const newGrid = grid.slice();\n        const node = path[i];\n        // define the x and y of the current node\n        const x: number = node.x;\n        const y: number = node.y;\n        const newNode: node = {\n          ...node,\n          isVisited: false,\n          isShortestPath: true,\n        };\n        newGrid[x][y] = newNode;\n        setGrid(newGrid);\n      }, VISITED_ANIMATION_TIMEOUT * n + PATH_ANIMATION_TIMEOUT * i);\n    }\n  };\n\n  // This function is passed to the drop down menu to handle the change of algorithm\n  const handleAlgorithmChange: (algorithmName: string) => () => void = (\n    algorithmName\n  ) => {\n    return () => {\n      setAlgorithm(algorithmName);\n    };\n  };\n\n  // This function handles the click on the menu buttons\n  const handleMenuChange: (menuName: string) => () => void = (menuName) => {\n    return () => setAlgoActiveMenu(menuName);\n  };\n\n  // This function changes the algorithm that will be run, at the moment only dijkstra is implemented\n  const chooseAlgorithm: () => (\n    grid: node[][],\n    pairGrid: [number, number][][],\n    mazeGraph: Map<[number, number], [number, number][]>,\n    startNode: node,\n    endNode: node\n  ) => [node[], node[]] = () => {\n    return algorithms[algorithm];\n  };\n\n  // This function handles the logic of the visualization of the algorithms\n  const handleVisualization: () => void = () => {\n    if (isVisualized === 0) {\n      setIsVisualized(1);\n      const [visited, path]: [node[], node[]] = chooseAlgorithm()(\n        grid,\n        pairGrid,\n        maze,\n        startNode,\n        endNode\n      );\n      const n: number = visited.length,\n        m: number = path.length;\n      visualizeAlgorithm(visited, path);\n      setTimeout(() => {\n        setIsVisualized(2);\n      }, VISITED_ANIMATION_TIMEOUT * n + PATH_ANIMATION_TIMEOUT * m);\n    }\n  };\n\n  // This function calls the generate maze function\n  const generateMaze: () => void = () => {\n    if (isVisualized === 0) {\n      const newGrid = grid.slice();\n      const [newPairGrid, newMaze] = generateMazeGraph(\n        NUMBER_OF_COLUMNS,\n        NUMBER_OF_ROWS,\n        newGrid,\n        wallsDensity\n      );\n      setGrid(newGrid);\n      setPairGrid(newPairGrid);\n      setMaze(newMaze);\n    }\n  };\n\n  // Reinitialize the the board\n  const reinitialize: () => void = () => {\n    if (isVisualized === 2) {\n      const [newGrid, newStartNode, newEndNode] = constructGrid(\n        NUMBER_OF_COLUMNS,\n        NUMBER_OF_ROWS,\n        [startNode.x, startNode.y],\n        [endNode.x, endNode.y]\n      );\n      const [newPairGrid, newMaze] = generateMazeGraph(\n        NUMBER_OF_COLUMNS,\n        NUMBER_OF_ROWS,\n        newGrid,\n        0.6\n      );\n      setGrid(newGrid);\n      setPairGrid(newPairGrid);\n      setMaze(newMaze);\n      setStartNode(newStartNode);\n      setEndNode(newEndNode);\n      setWallsDensity(0.6);\n      setIsVisualized(0);\n    }\n  };\n\n  // The following block of functions handles the making of walls in the grid\n  // This feature is currently not used as it is not a good fit with the current direction of the app\n\n  // const toggleWall: (x: number, y: number) => void = (x, y) => {\n  //   const newGrid: node[][] = grid.slice();\n  //   let newNode;\n  //   if (!newGrid[x][y].isWall) {\n  //     newNode = {\n  //       ...newGrid[x][y],\n  //       isWall: !newGrid[x][y].isWall,\n  //       className: \"grid-node wall-node\",\n  //     };\n  //   } else {\n  //     newNode = {\n  //       ...newGrid[x][y],\n  //       isWall: !newGrid[x][y].isWall,\n  //       className: \"grid-node\",\n  //     };\n  //   }\n  //   newGrid[x][y] = newNode;\n  //   setGrid(newGrid);\n  // };\n\n  // // handles the case when the mouse button is down\n  // const handleMouseDown: (x: number, y: number) => void = (x, y) => {\n  //   toggleWall(x, y);\n  //   setMouseIsPressed(false);\n  // };\n\n  // // handles the case whan the mouse button is down and you enter a node\n  // const handleMouseEnter: (x: number, y: number) => void = (x, y) => {\n  //   if (mouseIsPressed) {\n  //     toggleWall(x, y);\n  //   }\n  // };\n\n  // // handles the case when you mouse up\n  // const handleMouseUp: () => void = () => {\n  //   setMouseIsPressed(false);\n  // };\n\n  // Render the app\n  return (\n    <div className=\"App\">\n      <NavBar>\n        <NavButton\n          text=\"Reinitialize\"\n          isVisualized={isVisualized}\n          className=\"reinitialize\"\n          startClassName=\"greyed-out\"\n          visualizingClassName=\"greyed-out\"\n          visualizedClassName=\"highlight\"\n          handleClick={reinitialize}\n        />\n        <NavButton\n          text=\"Generate Maze\"\n          isVisualized={isVisualized}\n          className=\"generate-maze\"\n          visualizingClassName=\"greyed-out\"\n          visualizedClassName=\"greyed-out\"\n          handleClick={generateMaze}\n        />\n        <NavItem\n          text=\"Maze options\"\n          id=\"maze-options\"\n          isVisualized={isVisualized}\n          shouldGreyOut={true}\n        >\n          <DropDownMenu>\n            <DropDownSlider\n              text=\"Density of walls\"\n              minValue={0.1}\n              maxValue={1}\n              defaultValue={wallsDensity}\n              handleChange={setWallsDensity}\n            ></DropDownSlider>\n          </DropDownMenu>\n        </NavItem>\n        <NavButton\n          text={\"Visualize \" + algorithm + \"!\"}\n          isVisualized={isVisualized}\n          className=\"visualize-button\"\n          visualizingClassName=\"greyed-out\"\n          visualizedClassName=\"greyed-out\"\n          handleClick={handleVisualization}\n        />\n        <NavItem\n          text=\"Algorithms\"\n          id=\"algorithms\"\n          isVisualized={isVisualized}\n          shouldGreyOut={false}\n        >\n          <DropDownMenu height={height}>\n            <WrapperCSSTransition\n              in={algoActiveMenu === \"main\"}\n              unmountOnExit\n              timeout={500}\n              classNames=\"menu-primary\"\n              handleEnter={setHeight}\n              appear\n            >\n              <DropDownItem handleClick={handleMenuChange(\"unweighted\")}>\n                Algorithms for unweighted graphs\n              </DropDownItem>\n              <DropDownItem handleClick={handleMenuChange(\"weighted\")}>\n                Algorithms for weighted graphs\n              </DropDownItem>\n            </WrapperCSSTransition>\n            <WrapperCSSTransition\n              in={algoActiveMenu === \"unweighted\"}\n              unmountOnExit\n              timeout={500}\n              classNames=\"menu-unweighted\"\n              handleEnter={setHeight}\n            >\n              <DropDownItem handleClick={handleMenuChange(\"main\")}>\n                {\"<<<\"}\n              </DropDownItem>\n              <DropDownItem\n                handleClick={handleAlgorithmChange(\"Depth First Search\")}\n              >\n                <p>Depth First Search</p>\n                {algorithm === \"Depth First Search\" ? <p>✓</p> : \"\"}\n              </DropDownItem>\n              <DropDownItem\n                handleClick={handleAlgorithmChange(\"Breadth First Search\")}\n              >\n                <p>Breadth First Search</p>\n                {algorithm === \"Breadth First Search\" ? <p>✓</p> : \"\"}\n              </DropDownItem>\n            </WrapperCSSTransition>\n            <WrapperCSSTransition\n              in={algoActiveMenu === \"weighted\"}\n              unmountOnExit\n              timeout={500}\n              classNames=\"menu-weighted\"\n              handleEnter={setHeight}\n            >\n              <DropDownItem handleClick={handleMenuChange(\"main\")}>\n                {\"<<<\"}\n              </DropDownItem>\n              <DropDownItem\n                handleClick={handleAlgorithmChange(\"Dijkstra's algorithm\")}\n              >\n                <p>Dijkstra's Algorithm</p>\n                {algorithm === \"Dijkstra's algorithm\" ? <p>✓</p> : \"\"}\n              </DropDownItem>\n              <DropDownItem handleClick={handleAlgorithmChange(\"A* algorithm\")}>\n                <p>A* Algorithm</p>\n                {algorithm === \"A* algorithm\" ? <p>✓</p> : \"\"}\n              </DropDownItem>\n            </WrapperCSSTransition>\n          </DropDownMenu>\n        </NavItem>\n      </NavBar>\n      {/* <SecondaryHeader>\n        <button\n          className=\"visualize-button\"\n          onClick={(e) => {\n            visualizeAlgorithm(\n              ...chooseAlgorithm(algorithm)(\n                grid,\n                pairGrid,\n                mazeGraph,\n                startNode,\n                endNode\n              )\n            );\n          }}\n        >\n          Visualize the path!\n        </button>\n      </SecondaryHeader> */}\n      <Grid grid={grid} pairGrid={pairGrid} maze={maze} />\n    </div>\n  );\n};\n\nexport default Visualizer;\n","import React from \"react\";\n\nimport { BrowserRouter as Router, Switch, Route } from \"react-router-dom\";\nimport Visualizer from \"./Visualizer/Visualizer\";\n\nconst App: React.FC = () => {\n  return (\n    <div>\n      <Router>\n        <Switch>\n          <Route exact path=\"/pathfinding-visualizer\" component={Visualizer} />\n          {/* <Route path=\"/react-rat\" component={ReactRat} /> */}\n        </Switch>\n      </Router>\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\n// import PathFindingVisualizer from \"./Visualizer/PathFindingVisualizer\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}