{"ast":null,"code":"import _classCallCheck from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";export var BinaryHeap=/*#__PURE__*/function(){function BinaryHeap(scoreFunction){_classCallCheck(this,BinaryHeap);this.content=void 0;this.scoreFunction=void 0;this.content=[];this.scoreFunction=scoreFunction;}_createClass(BinaryHeap,[{key:\"push\",value:function push(element){this.content.push(element);this.bubbleUp(this.content.length-1);}},{key:\"pop\",value:function pop(){var result=this.content[0];var end=this.content.pop();if(this.content.length>0){this.content[0]=end;this.sinkDown(0);}return result;}},{key:\"remove\",value:function remove(node){var length=this.content.length;// To remove a value, we must search through the array to find\n// it.\nfor(var i=0;i<length;i++){if(this.content[i]!==node)continue;// When it is found, the process seen in 'pop' is repeated\n// to fill up the hole.\nvar end=this.content.pop();// If the element we popped was the one we needed to remove,\n// we're done.\nif(i===length-1)break;// Otherwise, we replace the removed element with the popped\n// one, and allow it to float up or sink down as appropriate.\nthis.content[i]=end;this.bubbleUp(i);this.sinkDown(i);break;}}},{key:\"size\",value:function size(){return this.content.length;}},{key:\"bubbleUp\",value:function bubbleUp(n){// Fetch the element that has to be moved.\nvar element=this.content[n],score=this.scoreFunction(ensure(element));// When at 0, an element can not go up any further.\nwhile(n>0){// Compute the parent element's index, and fetch it.\nvar parentN=Math.floor((n+1)/2)-1,parent=this.content[parentN];// If the parent has a lesser score, things are in order and we\n// are done.\nif(score>=this.scoreFunction(ensure(parent)))break;// Otherwise, swap the parent with the current element and\n// continue.\nthis.content[parentN]=element;this.content[n]=parent;n=parentN;}}},{key:\"sinkDown\",value:function sinkDown(n){// Look up the target element and its score.\nvar length=this.content.length,element=this.content[n],elemScore=this.scoreFunction(ensure(element));while(true){// Compute the indices of the child elements.\nvar child2N=(n+1)*2,child1N=child2N-1;// This is used to store the new position of the element,\n// if any.\nvar swap=null;// If the first child exists (is inside the array)...\nif(child1N<length){// Look it up and compute its score.\nvar child1=this.content[child1N],child1Score=this.scoreFunction(ensure(child1));// If the score is less than our element's, we need to swap.\nif(child1Score<elemScore)swap=child1N;}// Do the same checks for the other child.\nif(child2N<length){var child2=this.content[child2N],child2Score=this.scoreFunction(ensure(child2));if(child2Score<(swap==null?elemScore:child2Score))swap=child2N;}// No need to swap further, we are done.\nif(swap==null)break;// Otherwise, swap and continue.\nthis.content[n]=this.content[swap];this.content[swap]=element;n=swap;}}}]);return BinaryHeap;}();function ensure(argument){var message=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\"This value was promised to be there.\";if(argument===undefined||argument===null){throw new TypeError(message);}return argument;}","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helper_functions/binaryHeap.ts"],"names":["BinaryHeap","scoreFunction","content","element","push","bubbleUp","length","result","end","pop","sinkDown","node","i","n","score","ensure","parentN","Math","floor","parent","elemScore","child2N","child1N","swap","child1","child1Score","child2","child2Score","argument","message","undefined","TypeError"],"mappings":"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","sourcesContent":["export class BinaryHeap<T> {\n  content: (T | undefined)[];\n  scoreFunction: (x: T) => number;\n\n  constructor(scoreFunction: (x: T) => number) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  push(element: T) {\n    this.content.push(element);\n    this.bubbleUp(this.content.length - 1);\n  }\n\n  pop(): T | undefined {\n    let result = this.content[0];\n    let end = this.content.pop();\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n    return result;\n  }\n\n  remove(node: T) {\n    let length = this.content.length;\n    // To remove a value, we must search through the array to find\n    // it.\n    for (var i = 0; i < length; i++) {\n      if (this.content[i] !== node) continue;\n      // When it is found, the process seen in 'pop' is repeated\n      // to fill up the hole.\n      let end = this.content.pop();\n      // If the element we popped was the one we needed to remove,\n      // we're done.\n      if (i === length - 1) break;\n      // Otherwise, we replace the removed element with the popped\n      // one, and allow it to float up or sink down as appropriate.\n      this.content[i] = end;\n      this.bubbleUp(i);\n      this.sinkDown(i);\n      break;\n    }\n  }\n\n  size() {\n    return this.content.length;\n  }\n\n  private bubbleUp(n: number) {\n    // Fetch the element that has to be moved.\n    let element = this.content[n],\n      score = this.scoreFunction(ensure(element));\n    // When at 0, an element can not go up any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      let parentN = Math.floor((n + 1) / 2) - 1,\n        parent = this.content[parentN];\n      // If the parent has a lesser score, things are in order and we\n      // are done.\n      if (score >= this.scoreFunction(ensure(parent))) break;\n\n      // Otherwise, swap the parent with the current element and\n      // continue.\n      this.content[parentN] = element;\n      this.content[n] = parent;\n      n = parentN;\n    }\n  }\n\n  private sinkDown(n: number) {\n    // Look up the target element and its score.\n    var length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(ensure(element));\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) * 2,\n        child1N = child2N - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      var swap = null;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N],\n          child1Score = this.scoreFunction(ensure(child1));\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) swap = child1N;\n      }\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n          child2Score = this.scoreFunction(ensure(child2));\n        if (child2Score < (swap == null ? elemScore : child2Score))\n          swap = child2N;\n      }\n\n      // No need to swap further, we are done.\n      if (swap == null) break;\n\n      // Otherwise, swap and continue.\n      this.content[n] = this.content[swap];\n      this.content[swap] = element;\n      n = swap;\n    }\n  }\n}\n\nfunction ensure<T>(\n  argument: T | undefined | null,\n  message: string = \"This value was promised to be there.\"\n): T {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}\n"]},"metadata":{},"sourceType":"module"}