{"ast":null,"code":"export const bfs = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n        n = grid[0].length; // Initialize the predecessor array\n\n  const predecessor = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode; // Initialize the visited nodes array\n\n  let visited = new Set(); // Initialize the Queue TODO: IMPLEMENT A BETTER VERSION OF THE QUEUE WITH O(1) OPERATIONS\n\n  let q = [startNode]; // While the queue is not empty\n\n  while (q.length > 0) {\n    // Get the element in front of the queue\n    let current = ensure(q.shift()); // Put the current node in the visited set\n\n    visited.add(current); // iterate through the neighbors of the current node\n\n    for (const neighbor of ensure(mazeGraph.get(pairGrid[current.x][current.y]))) {\n      // Get the coordinates of the neighbor node\n      let neighborX = neighbor[0],\n          neighborY = neighbor[1];\n\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n) {}\n    }\n  }\n\n  return [visited, []];\n}; // This function is here to ensure that a value is not undefined (especially when using arrays).\n\nfunction ensure(argument, message = \"This value was promised to be there.\") {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helper_functions/shortestPathAlgorithms/bfs.ts"],"names":["bfs","grid","pairGrid","mazeGraph","startNode","endNode","m","length","n","predecessor","fill","id","visited","Set","q","current","ensure","shift","add","neighbor","get","x","y","neighborX","neighborY","argument","message","undefined","TypeError"],"mappings":"AAEA,OAAO,MAAMA,GAMQ,GAAG,CAACC,IAAD,EAAOC,QAAP,EAAiBC,SAAjB,EAA4BC,SAA5B,EAAuCC,OAAvC,KAAmD;AACzE,QAAMC,CAAC,GAAGL,IAAI,CAACM,MAAf;AAAA,QACEC,CAAC,GAAGP,IAAI,CAAC,CAAD,CAAJ,CAAQM,MADd,CADyE,CAIzE;;AACA,QAAME,WAAmB,GAAG,EAA5B;AACAA,EAAAA,WAAW,CAACC,IAAZ,CAAiBN,SAAjB,EAA4B,CAA5B,EAA+BE,CAAC,GAAGE,CAAnC;AACAC,EAAAA,WAAW,CAACL,SAAS,CAACO,EAAX,CAAX,GAA4BP,SAA5B,CAPyE,CASzE;;AACA,MAAIQ,OAAkB,GAAG,IAAIC,GAAJ,EAAzB,CAVyE,CAYzE;;AACA,MAAIC,CAAS,GAAG,CAACV,SAAD,CAAhB,CAbyE,CAezE;;AACA,SAAOU,CAAC,CAACP,MAAF,GAAW,CAAlB,EAAqB;AACnB;AACA,QAAIQ,OAAa,GAAGC,MAAM,CAACF,CAAC,CAACG,KAAF,EAAD,CAA1B,CAFmB,CAInB;;AACAL,IAAAA,OAAO,CAACM,GAAR,CAAYH,OAAZ,EALmB,CAOnB;;AACA,SAAK,MAAMI,QAAX,IAAuBH,MAAM,CAC3Bb,SAAS,CAACiB,GAAV,CAAclB,QAAQ,CAACa,OAAO,CAACM,CAAT,CAAR,CAAoBN,OAAO,CAACO,CAA5B,CAAd,CAD2B,CAA7B,EAEG;AACD;AACA,UAAIC,SAAiB,GAAGJ,QAAQ,CAAC,CAAD,CAAhC;AAAA,UACEK,SAAiB,GAAGL,QAAQ,CAAC,CAAD,CAD9B;;AAEA,UAAII,SAAS,GAAG,CAAZ,IAAiBA,SAAS,IAAIjB,CAA9B,IAAmCkB,SAAS,GAAG,CAA/C,IAAoDA,SAAS,IAAIhB,CAArE,EAAwE,CACvE;AACF;AACF;;AAED,SAAO,CAACI,OAAD,EAAU,EAAV,CAAP;AACD,CA1CM,C,CA4CP;;AACA,SAASI,MAAT,CACES,QADF,EAEEC,OAAe,GAAG,sCAFpB,EAGK;AACH,MAAID,QAAQ,KAAKE,SAAb,IAA0BF,QAAQ,KAAK,IAA3C,EAAiD;AAC/C,UAAM,IAAIG,SAAJ,CAAcF,OAAd,CAAN;AACD;;AAED,SAAOD,QAAP;AACD","sourcesContent":["import { node } from \"../usefulInterfaces\";\n\nexport const bfs: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [number, number][]>,\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: Set<node> = new Set<node>();\n\n  // Initialize the Queue TODO: IMPLEMENT A BETTER VERSION OF THE QUEUE WITH O(1) OPERATIONS\n  let q: node[] = [startNode];\n\n  // While the queue is not empty\n  while (q.length > 0) {\n    // Get the element in front of the queue\n    let current: node = ensure(q.shift());\n\n    // Put the current node in the visited set\n    visited.add(current);\n\n    // iterate through the neighbors of the current node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[current.x][current.y])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0],\n        neighborY: number = neighbor[1];\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n) {\n      }\n    }\n  }\n\n  return [visited, []];\n};\n\n// This function is here to ensure that a value is not undefined (especially when using arrays).\nfunction ensure<T>(\n  argument: T | undefined | null,\n  message: string = \"This value was promised to be there.\"\n): T {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}\n"]},"metadata":{},"sourceType":"module"}