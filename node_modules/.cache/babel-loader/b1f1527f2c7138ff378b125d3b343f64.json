{"ast":null,"code":"import { retrieveTwoEndedPath } from \"../retrievePath\";\nimport { ensure } from \"../../ensureNotUndefined\";\nexport const twoEndedBfs = (grid, pairGrid, mazeGraph, startNode, targetList) => {\n  const m = grid.length,\n        n = grid[0].length; // Initialize the predecessor array\n\n  const predecessor = [];\n\n  for (let i = 0; i < m * n; i++) {\n    predecessor.push(startNode);\n  }\n\n  predecessor[startNode.id] = startNode;\n  const successor = [];\n\n  for (let i = 0; i < m * n; i++) {\n    successor.push(targetList[0]);\n  }\n\n  successor[targetList[0].id] = targetList[0]; // Initialize the visited nodes array\n\n  let visitedForward = [];\n  let visitedBackward = [];\n  let visited = []; // Initialize the discovered array\n\n  let discovered = [startNode]; // Initialize the Queue TODO: IMPLEMENT A BETTER VERSION OF THE QUEUE WITH O(1) OPERATIONS\n\n  let q_forward = [startNode];\n  let q_backward = [targetList[0]]; // While the queue is not empty\n\n  while (q_forward.length > 0 || q_backward.length > 0) {\n    // Get the element in front of the queue\n    let currentForwardNode = ensure(q_forward.shift());\n    if (visitedForward.find(visitedNode => visitedNode === currentForwardNode)) continue; // Put the currentNode node in the visited set\n\n    visitedForward.push(currentForwardNode);\n    visited.push(currentForwardNode); // If we found the end node, return the path to it\n\n    if (visitedBackward.find(targetNode => currentForwardNode === targetNode)) {\n      // Retrieve the shortest path\n      const shortestPath = retrieveTwoEndedPath(predecessor, successor, currentForwardNode, startNode, targetList[0]);\n      return [visited, shortestPath];\n    } // iterate through the neighbors of the currentNode node\n\n\n    for (const neighbor of ensure(mazeGraph.get(pairGrid[currentForwardNode.x][currentForwardNode.y]))) {\n      // Get the coordinates of the neighbor node\n      let neighborX = neighbor[0][0],\n          neighborY = neighbor[0][1];\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n || discovered.find(discoveredNode => discoveredNode === grid[neighborX][neighborY])) continue; // Get the node in the grid\n\n      let nextNode = grid[neighborX][neighborY]; // update the predecessor array\n\n      predecessor[nextNode.id] = currentForwardNode; // Add the node to the visited nodes\n\n      discovered.push(nextNode); // Push the next node to the queue\n\n      q_forward.push(nextNode);\n    } // Get the element in front of the queue\n\n\n    let currentBackwardNode = ensure(q_backward.shift());\n    if (visitedBackward.find(visitedNode => visitedNode === currentBackwardNode)) continue; // Put the currentNode node in the visited set\n\n    visitedBackward.push(currentBackwardNode);\n    visited.push(currentForwardNode);\n\n    if (visitedForward.find(visitedNode => visitedNode === currentBackwardNode)) {\n      // Retrieve the shortest path\n      const shortestPath = retrieveTwoEndedPath(predecessor, successor, currentBackwardNode, startNode, targetList[0]);\n      return [visited, shortestPath];\n    } // iterate through the neighbors of the currentNode node\n\n\n    for (const neighbor of ensure(mazeGraph.get(pairGrid[currentBackwardNode.x][currentBackwardNode.y]))) {\n      // Get the coordinates of the neighbor node\n      let neighborX = neighbor[0][0],\n          neighborY = neighbor[0][1];\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n || discovered.find(discoveredNode => discoveredNode === grid[neighborX][neighborY])) continue; // Get the node in the grid\n\n      let nextNode = grid[neighborX][neighborY]; // update the predecessor array\n\n      successor[nextNode.id] = currentBackwardNode; // Add the node to the visited nodes\n\n      discovered.push(nextNode); // Push the next node to the queue\n\n      q_backward.push(nextNode);\n    }\n  }\n\n  return [visitedForward, []];\n};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helperFunctions/shortestPathAlgorithms/singleTarget/twoEndedBfs.ts"],"names":["retrieveTwoEndedPath","ensure","twoEndedBfs","grid","pairGrid","mazeGraph","startNode","targetList","m","length","n","predecessor","i","push","id","successor","visitedForward","visitedBackward","visited","discovered","q_forward","q_backward","currentForwardNode","shift","find","visitedNode","targetNode","shortestPath","neighbor","get","x","y","neighborX","neighborY","discoveredNode","nextNode","currentBackwardNode"],"mappings":"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","sourcesContent":["import { node } from \"../../usefulInterfaces\";\nimport { retrieveTwoEndedPath } from \"../retrievePath\";\nimport { ensure } from \"../../ensureNotUndefined\";\n\nexport const twoEndedBfs: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, targetList) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    predecessor.push(startNode);\n  }\n  predecessor[startNode.id] = startNode;\n\n  const successor: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    successor.push(targetList[0]);\n  }\n  successor[targetList[0].id] = targetList[0];\n\n  // Initialize the visited nodes array\n  let visitedForward: node[] = [];\n  let visitedBackward: node[] = [];\n  let visited: node[] = [];\n\n  // Initialize the discovered array\n  let discovered: node[] = [startNode];\n\n  // Initialize the Queue TODO: IMPLEMENT A BETTER VERSION OF THE QUEUE WITH O(1) OPERATIONS\n  let q_forward: node[] = [startNode];\n\n  let q_backward: node[] = [targetList[0]];\n\n  // While the queue is not empty\n  while (q_forward.length > 0 || q_backward.length > 0) {\n    // Get the element in front of the queue\n    let currentForwardNode: node = ensure(q_forward.shift());\n\n    if (\n      visitedForward.find((visitedNode) => visitedNode === currentForwardNode)\n    )\n      continue;\n\n    // Put the currentNode node in the visited set\n    visitedForward.push(currentForwardNode);\n    visited.push(currentForwardNode);\n\n    // If we found the end node, return the path to it\n    if (\n      visitedBackward.find((targetNode) => currentForwardNode === targetNode)\n    ) {\n      // Retrieve the shortest path\n      const shortestPath = retrieveTwoEndedPath(\n        predecessor,\n        successor,\n        currentForwardNode,\n        startNode,\n        targetList[0]\n      );\n      return [visited, shortestPath];\n    }\n\n    // iterate through the neighbors of the currentNode node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentForwardNode.x][currentForwardNode.y])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0][0],\n        neighborY: number = neighbor[0][1];\n\n      if (\n        neighborX < 0 ||\n        neighborX >= m ||\n        neighborY < 0 ||\n        neighborY >= n ||\n        discovered.find(\n          (discoveredNode) => discoveredNode === grid[neighborX][neighborY]\n        )\n      )\n        continue;\n\n      // Get the node in the grid\n      let nextNode: node = grid[neighborX][neighborY];\n\n      // update the predecessor array\n      predecessor[nextNode.id] = currentForwardNode;\n\n      // Add the node to the visited nodes\n      discovered.push(nextNode);\n\n      // Push the next node to the queue\n      q_forward.push(nextNode);\n    }\n\n    // Get the element in front of the queue\n    let currentBackwardNode: node = ensure(q_backward.shift());\n\n    if (\n      visitedBackward.find((visitedNode) => visitedNode === currentBackwardNode)\n    )\n      continue;\n\n    // Put the currentNode node in the visited set\n    visitedBackward.push(currentBackwardNode);\n    visited.push(currentForwardNode);\n\n    if (\n      visitedForward.find((visitedNode) => visitedNode === currentBackwardNode)\n    ) {\n      // Retrieve the shortest path\n      const shortestPath = retrieveTwoEndedPath(\n        predecessor,\n        successor,\n        currentBackwardNode,\n        startNode,\n        targetList[0]\n      );\n      return [visited, shortestPath];\n    }\n\n    // iterate through the neighbors of the currentNode node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentBackwardNode.x][currentBackwardNode.y])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0][0],\n        neighborY: number = neighbor[0][1];\n\n      if (\n        neighborX < 0 ||\n        neighborX >= m ||\n        neighborY < 0 ||\n        neighborY >= n ||\n        discovered.find(\n          (discoveredNode) => discoveredNode === grid[neighborX][neighborY]\n        )\n      )\n        continue;\n\n      // Get the node in the grid\n      let nextNode: node = grid[neighborX][neighborY];\n\n      // update the predecessor array\n      successor[nextNode.id] = currentBackwardNode;\n\n      // Add the node to the visited nodes\n      discovered.push(nextNode);\n\n      // Push the next node to the queue\n      q_backward.push(nextNode);\n    }\n  }\n\n  return [visitedForward, []];\n};\n"]},"metadata":{},"sourceType":"module"}