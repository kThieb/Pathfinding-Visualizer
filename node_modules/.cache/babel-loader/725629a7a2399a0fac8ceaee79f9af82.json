{"ast":null,"code":"import _createForOfIteratorHelper from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import{BinaryHeap}from\"../binaryHeap\";export var dijkstra=function dijkstra(grid,startNode,endNode){var m=grid.length,n=grid[0].length;// Initialize the distances array\nvar distances=[];for(var i=0;i<m;i++){distances.push([]);for(var j=0;j<n;j++){distances[i].push(Number.MAX_SAFE_INTEGER);}}distances[startNode.x][startNode.y]=0;// Initialize the predecessor array\nvar predecessor=[];predecessor.fill(startNode,0,m*n);predecessor[startNode.id]=startNode;// Initialize the visited nodes array\nvar visited=[];// Initialize the directions array we will use to perform Dijkstra's algorithm\nvar directions=[[0,1],[1,0],[0,-1],[-1,0]];//   Initialize the Binary Heap\nvar pq=new BinaryHeap(function(n){return distances[n.x][n.y];});pq.push(startNode);while(pq.size()>0){var currentNode=ensure(pq.pop());// add the current node to the visited nodes\n// currentNode.isVisited = true;\nvisited.push(currentNode);// Get the coordinates of the nodes\nvar currentX=currentNode.x;var currentY=currentNode.y;// Iterate the neighbors of the node\nvar _iterator=_createForOfIteratorHelper(directions),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var dir=_step.value;// Get the coordinates of the next node\nvar nextX=currentX+dir[0];var nextY=currentY+dir[1];// Check if the coordinates are valid\nif(nextX>=0&&nextX<m&&nextY>=0&&nextY<n){var _ret=function(){var nextNode=grid[nextX][nextY];// If the node is not yet visited, remove it from the heap and\n// put it back in with its new distance as the score function\nif(!visited.find(function(currentNode){return currentNode===nextNode;})){pq.remove(nextNode);pq.push(nextNode);}// Calculate the distance between the current node and the next node\n// To Do: take into account the weight of the path\nvar currentDistance=distances[currentX][currentY]+1;// If the distance is less than the distance in the array distances,\n// change it and change the predecessor of the next node to be the current one\nif(currentDistance<distances[nextX][nextY]){predecessor[nextNode.id]=currentNode;distances[nextX][nextY]=currentDistance;}// If we found the target node then we return what we need\nif(nextNode===endNode){// Retrieve the shortest path\nvar shortestPath=retrieveShortestPath(predecessor,startNode,endNode);visited.shift();// return the correct value\nreturn{v:[visited,shortestPath]};}}();if(typeof _ret===\"object\")return _ret.v;}}}catch(err){_iterator.e(err);}finally{_iterator.f();}}return[visited,[]];};export var dijkstraWithWalls=function dijkstraWithWalls(grid,pairGrid,mazeGraph,startNode,endNode){var m=grid.length,n=grid[0].length;// Initialize the distances array\nvar distances=[];for(var i=0;i<m;i++){distances.push([]);for(var j=0;j<n;j++){distances[i].push(Number.MAX_SAFE_INTEGER);}}distances[startNode.x][startNode.y]=0;// Initialize the predecessor array\nvar predecessor=[];predecessor.fill(startNode,0,m*n);predecessor[startNode.id]=startNode;// Initialize the visited nodes array\nvar visited=[];//   Initialize the Binary Heap\nvar pq=new BinaryHeap(function(n){return distances[n.x][n.y];});pq.push(startNode);while(pq.size()>0){var currentNode=ensure(pq.pop());// add the current node to the visited nodes\n// currentNode.isVisited = true;\nvisited.push(currentNode);// Get the coordinates of the nodes\nvar currentX=currentNode.x;var currentY=currentNode.y;// Iterate the neighbors of the node\nvar _iterator2=_createForOfIteratorHelper(ensure(mazeGraph.get(pairGrid[currentX][currentY]))),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var neighbor=_step2.value;// Check if the coordinates are valid\nif(neighbor[0]>=0&&neighbor[0]<m&&neighbor[1]>=0&&neighbor[1]<n){var _ret2=function(){var nextNode=grid[neighbor[0]][neighbor[1]];// If the node is not yet visited, remove it from the heap and\n// put it back in with its new distance as the score function\nif(!visited.find(function(currentNode){return currentNode===nextNode;})){pq.remove(nextNode);pq.push(nextNode);}// Calculate the distance between the current node and the next node\n// To Do: take into account the weight of the path\nvar currentDistance=distances[currentX][currentY]+1;// If the distance is less than the distance in the array distances,\n// change it and change the predecessor of the next node to be the current one\nif(currentDistance<distances[neighbor[0]][neighbor[1]]){predecessor[nextNode.id]=currentNode;distances[neighbor[0]][neighbor[1]]=currentDistance;}// If we found the target node then we return what we need\nif(nextNode===endNode){// Retrieve the shortest path\nvar shortestPath=retrieveShortestPath(predecessor,startNode,endNode);visited.push(endNode);return{v:[visited,shortestPath]};}}();if(typeof _ret2===\"object\")return _ret2.v;}}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}}return[visited,[]];};// This function retrieves the shortest path from the predecessor array from Dijkstra's algorithm\nvar retrieveShortestPath=function retrieveShortestPath(predecessor,startNode,endNode){var shortestPath=[endNode];var current=endNode;while(current!==startNode){current=predecessor[current.id];shortestPath.unshift(current);}return shortestPath;};// This function is here to ensure that a value is not undefined (especially when using arrays).\nfunction ensure(argument){var message=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\"This value was promised to be there.\";if(argument===undefined||argument===null){throw new TypeError(message);}return argument;}","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helper_functions/shortestPathAlgorithms/dijkstra.ts"],"names":["BinaryHeap","dijkstra","grid","startNode","endNode","m","length","n","distances","i","push","j","Number","MAX_SAFE_INTEGER","x","y","predecessor","fill","id","visited","directions","pq","size","currentNode","ensure","pop","currentX","currentY","dir","nextX","nextY","nextNode","find","remove","currentDistance","shortestPath","retrieveShortestPath","shift","dijkstraWithWalls","pairGrid","mazeGraph","get","neighbor","current","unshift","argument","message","undefined","TypeError"],"mappings":"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","sourcesContent":["import { node } from \"../usefulInterfaces\";\nimport { BinaryHeap } from \"../binaryHeap\";\n\nexport const dijkstra: (\n  grid: node[][],\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  // Initialize the directions array we will use to perform Dijkstra's algorithm\n  const directions: number[][] = [\n    [0, 1],\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n  ];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>(\n    (n: node) => distances[n.x][n.y]\n  );\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n    visited.push(currentNode);\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const dir of directions) {\n      // Get the coordinates of the next node\n      let nextX: number = currentX + dir[0];\n      let nextY: number = currentY + dir[1];\n\n      // Check if the coordinates are valid\n      if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n) {\n        let nextNode: node = grid[nextX][nextY];\n\n        // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n        if (!visited.find((currentNode) => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          pq.push(nextNode);\n        }\n\n        // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n        let currentDistance: number = distances[currentX][currentY] + 1;\n\n        // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n        if (currentDistance < distances[nextX][nextY]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[nextX][nextY] = currentDistance;\n        }\n\n        // If we found the target node then we return what we need\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrieveShortestPath(\n            predecessor,\n            startNode,\n            endNode\n          );\n          visited.shift();\n          // return the correct value\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n};\n\nexport const dijkstraWithWalls: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [number, number][]>,\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>(\n    (n: node) => distances[n.x][n.y]\n  );\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n    visited.push(currentNode);\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentX][currentY])\n    )) {\n      // Check if the coordinates are valid\n      if (\n        neighbor[0] >= 0 &&\n        neighbor[0] < m &&\n        neighbor[1] >= 0 &&\n        neighbor[1] < n\n      ) {\n        let nextNode: node = grid[neighbor[0]][neighbor[1]];\n\n        // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n        if (!visited.find((currentNode) => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          pq.push(nextNode);\n        }\n\n        // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n        let currentDistance: number = distances[currentX][currentY] + 1;\n\n        // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n        if (currentDistance < distances[neighbor[0]][neighbor[1]]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[neighbor[0]][neighbor[1]] = currentDistance;\n        }\n\n        // If we found the target node then we return what we need\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrieveShortestPath(\n            predecessor,\n            startNode,\n            endNode\n          );\n          visited.push(endNode);\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n};\n\n// This function retrieves the shortest path from the predecessor array from Dijkstra's algorithm\nconst retrieveShortestPath: (\n  predecessor: node[],\n  startNode: node,\n  endNode: node\n) => node[] = (predecessor, startNode, endNode) => {\n  let shortestPath = [endNode];\n  let current = endNode;\n  while (current !== startNode) {\n    current = predecessor[current.id];\n    shortestPath.unshift(current);\n  }\n\n  return shortestPath;\n};\n\n// This function is here to ensure that a value is not undefined (especially when using arrays).\nfunction ensure<T>(\n  argument: T | undefined | null,\n  message: string = \"This value was promised to be there.\"\n): T {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}\n"]},"metadata":{},"sourceType":"module"}