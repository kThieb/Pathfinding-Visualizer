{"ast":null,"code":"import _slicedToArray from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _createForOfIteratorHelper from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import{BinaryHeap}from\"../../dataStructures/binaryHeap\";import{retrievePath}from\"../retrievePath\";import{ensure}from\"../../ensureNotUndefined\";export var dijkstraHelper=function dijkstraHelper(grid,pairGrid,mazeGraph,startNode,oldTargetList){var m=grid.length,n=grid[0].length;var targetList=oldTargetList.slice();// Initialize the distances array\nvar distances=[];for(var i=0;i<m;i++){distances.push([]);for(var j=0;j<n;j++){distances[i].push(Number.MAX_SAFE_INTEGER-1);}}distances[startNode.x][startNode.y]=0;// Initialize the predecessor array\nvar predecessor=[];for(var _i=0;_i<m*n;_i++){predecessor.push(startNode);}predecessor[startNode.id]=startNode;// Initialize the visited nodes array\nvar visited=[];//   Initialize the Binary Heap\nvar pq=new BinaryHeap(function(a,b){if(distances[a[0].x][a[0].y]!==distances[b[0].x][b[0].y]){return distances[a[0].x][a[0].y]<distances[b[0].x][b[0].y];}return a[1]<b[1];});pq.push(startNode);var _loop=function _loop(){var currentNode=ensure(pq.pop());// add the current node to the visited nodes\nvisited.push(currentNode);// If we found the endNode, return the shortest path to it\nif(targetList.find(function(targetNode){return targetNode===currentNode;})){// Retrieve the shortest path\nvar shortestPath=retrievePath(predecessor,startNode,currentNode);return{v:[visited,shortestPath,currentNode,distances[currentNode.x][currentNode.y]]};}// Get the coordinates of the nodes\nvar currentX=currentNode.x;var currentY=currentNode.y;// Iterate the neighbors of the node\nvar _iterator=_createForOfIteratorHelper(ensure(mazeGraph.get(pairGrid[currentX][currentY]))),_step;try{var _loop2=function _loop2(){var neighbor=_step.value;// Get the coordinates of the neighbor node\nvar neighborX=neighbor[0][0],neighborY=neighbor[0][1];// Check if the coordinates are valid\nif(neighborX<0||neighborX>=m||neighborY<0||neighborY>=n)return\"continue\";var nextNode=grid[neighborX][neighborY];// Calculate the distance between the current node and the next node\n// To Do: take into account the weight of the path\nvar currentDistance=distances[currentX][currentY]+neighbor[1];// If the distance is less than the distance in the array distances,\n// change it and change the predecessor of the next node to be the current one\nif(currentDistance<distances[neighborX][neighborY]){predecessor[nextNode.id]=currentNode;distances[neighborX][neighborY]=currentDistance;}// If the node is not yet visited, remove it from the heap and\n// put it back in with its new distance as the score function\nif(!visited.find(function(visitedNode){return visitedNode===nextNode;})){pq.remove(nextNode);pq.push(nextNode);}};for(_iterator.s();!(_step=_iterator.n()).done;){var _ret2=_loop2();if(_ret2===\"continue\")continue;}}catch(err){_iterator.e(err);}finally{_iterator.f();}};while(pq.size()>0){var _ret=_loop();if(typeof _ret===\"object\")return _ret.v;}return[visited,[],startNode,0];};export var getDistanceMatrix=function getDistanceMatrix(grid,pairGrid,mazeGraph,targetList){var result=[];for(var i=0;i<targetList.length;i++){result.push([]);var _loop3=function _loop3(j){var distance=dijkstraHelper(grid,pairGrid,mazeGraph,targetList[i],targetList.filter(function(targetNode){return targetNode===targetList[j];}))[3];if(i!==j)result[i].push(distance);else result[i].push(0);};for(var j=0;j<targetList.length;j++){_loop3(j);}}return result;};export var dijkstra=function dijkstra(grid,pairGrid,mazeGraph,startNode,targetList){var _dijkstraHelper=dijkstraHelper(grid,pairGrid,mazeGraph,startNode,targetList),_dijkstraHelper2=_slicedToArray(_dijkstraHelper,4),visited=_dijkstraHelper2[0],path=_dijkstraHelper2[1],distance=_dijkstraHelper2[3];return[[visited,path],distance];};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helperFunctions/shortestPathAlgorithms/singleTarget/dijkstra.ts"],"names":["BinaryHeap","retrievePath","ensure","dijkstraHelper","grid","pairGrid","mazeGraph","startNode","oldTargetList","m","length","n","targetList","slice","distances","i","push","j","Number","MAX_SAFE_INTEGER","x","y","predecessor","id","visited","pq","a","b","currentNode","pop","find","targetNode","shortestPath","currentX","currentY","get","neighbor","neighborX","neighborY","nextNode","currentDistance","visitedNode","remove","size","getDistanceMatrix","result","distance","filter","dijkstra","path"],"mappings":"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","sourcesContent":["import { node } from \"../../usefulInterfaces\";\nimport { BinaryHeap } from \"../../dataStructures/binaryHeap\";\nimport { retrievePath } from \"../retrievePath\";\nimport { ensure } from \"../../ensureNotUndefined\";\n\nexport const dijkstraHelper: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [node[], node[], node, number] = (\n  grid,\n  pairGrid,\n  mazeGraph,\n  startNode,\n  oldTargetList\n) => {\n  const m = grid.length,\n    n = grid[0].length;\n  const targetList: node[] = oldTargetList.slice();\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER - 1);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    predecessor.push(startNode);\n  }\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>(\n    (a: [node, number], b: [node, number]) => {\n      if (distances[a[0].x][a[0].y] !== distances[b[0].x][b[0].y]) {\n        return distances[a[0].x][a[0].y] < distances[b[0].x][b[0].y];\n      }\n      return a[1] < b[1];\n    }\n  );\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    visited.push(currentNode);\n\n    // If we found the endNode, return the shortest path to it\n    if (targetList.find((targetNode) => targetNode === currentNode)) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, currentNode);\n      return [\n        visited,\n        shortestPath,\n        currentNode,\n        distances[currentNode.x][currentNode.y],\n      ];\n    }\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentX][currentY])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0][0],\n        neighborY: number = neighbor[0][1];\n\n      // Check if the coordinates are valid\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n)\n        continue;\n\n      let nextNode: node = grid[neighborX][neighborY];\n\n      // Calculate the distance between the current node and the next node\n      // To Do: take into account the weight of the path\n      let currentDistance: number = distances[currentX][currentY] + neighbor[1];\n\n      // If the distance is less than the distance in the array distances,\n      // change it and change the predecessor of the next node to be the current one\n      if (currentDistance < distances[neighborX][neighborY]) {\n        predecessor[nextNode.id] = currentNode;\n        distances[neighborX][neighborY] = currentDistance;\n      }\n\n      // If the node is not yet visited, remove it from the heap and\n      // put it back in with its new distance as the score function\n      if (!visited.find((visitedNode) => visitedNode === nextNode)) {\n        pq.remove(nextNode);\n        pq.push(nextNode);\n      }\n    }\n  }\n  return [visited, [], startNode, 0];\n};\n\nexport const getDistanceMatrix: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  targetList: node[]\n) => number[][] = (grid, pairGrid, mazeGraph, targetList) => {\n  const result: number[][] = [];\n  for (let i: number = 0; i < targetList.length; i++) {\n    result.push([]);\n    for (let j: number = 0; j < targetList.length; j++) {\n      const distance = dijkstraHelper(\n        grid,\n        pairGrid,\n        mazeGraph,\n        targetList[i],\n        targetList.filter((targetNode: node) => targetNode === targetList[j])\n      )[3];\n      if (i !== j) result[i].push(distance);\n      else result[i].push(0);\n    }\n  }\n\n  return result;\n};\n\nexport const dijkstra: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [[node[], node[]], number] = (\n  grid,\n  pairGrid,\n  mazeGraph,\n  startNode,\n  targetList\n) => {\n  const [visited, path, , distance] = dijkstraHelper(\n    grid,\n    pairGrid,\n    mazeGraph,\n    startNode,\n    targetList\n  );\n  return [[visited, path], distance];\n};\n"]},"metadata":{},"sourceType":"module"}