{"ast":null,"code":"import { retrieveDistance, retrievePath } from \"../retrievePath\";\nimport { ensure } from \"../../ensureNotUndefined\";\nexport const dfs = (grid, pairGrid, mazeGraph, startNode, targetList) => {\n  const m = grid.length,\n        n = grid[0].length; // Initialize the predecessor array\n\n  const predecessor = [];\n\n  for (let i = 0; i < m * n; i++) {\n    predecessor.push(startNode);\n  }\n\n  predecessor[startNode.id] = startNode; // Initialize the visited nodes array\n\n  let visited = []; // Discovered array\n\n  let discovered = [startNode]; // Initialize the stack\n\n  let stack = [startNode]; // While the stack is not empty\n\n  while (stack.length > 0) {\n    // Get the element in front of the stack\n    let currentNode = ensure(stack.pop());\n    if (visited.find(visitedNode => visitedNode === currentNode)) continue; // Put the currentNode node in the visited set\n\n    visited.push(currentNode); // If we found the end node, return the path to it\n\n    if (targetList.find(targetNode => currentNode)) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, currentNode);\n      return [[visited, shortestPath], retrieveDistance(shortestPath, pairGrid, mazeGraph)];\n    }\n\n    console.log(stack); // iterate through the neighbors of the currentNode node\n\n    for (const neighbor of ensure(mazeGraph.get(pairGrid[currentNode.x][currentNode.y]))) {\n      // Get the coordinates of the neighbor node\n      let neighborX = neighbor[0][0],\n          neighborY = neighbor[0][1]; // Check if the node is on the board\n\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n || discovered.find(discoveredNode => discoveredNode === grid[neighborX][neighborY])) continue; // Get the node in the grid\n\n      let nextNode = grid[neighborX][neighborY]; // update the predecessor array\n\n      predecessor[nextNode.id] = currentNode; // Add the node to the discovered array\n\n      discovered.push(nextNode); // Push the nextNode to the stack\n\n      stack.push(nextNode);\n    }\n  }\n\n  return [[visited, []], 0];\n};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helperFunctions/shortestPathAlgorithms/singleTarget/dfs.ts"],"names":["retrieveDistance","retrievePath","ensure","dfs","grid","pairGrid","mazeGraph","startNode","targetList","m","length","n","predecessor","i","push","id","visited","discovered","stack","currentNode","pop","find","visitedNode","targetNode","shortestPath","console","log","neighbor","get","x","y","neighborX","neighborY","discoveredNode","nextNode"],"mappings":"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","sourcesContent":["import { node } from \"../../usefulInterfaces\";\nimport { retrieveDistance, retrievePath } from \"../retrievePath\";\nimport { ensure } from \"../../ensureNotUndefined\";\n\nexport const dfs: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [[node[], node[]], number] = (\n  grid,\n  pairGrid,\n  mazeGraph,\n  startNode,\n  targetList\n) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    predecessor.push(startNode);\n  }\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  // Discovered array\n  let discovered: node[] = [startNode];\n\n  // Initialize the stack\n  let stack: node[] = [startNode];\n\n  // While the stack is not empty\n  while (stack.length > 0) {\n    // Get the element in front of the stack\n    let currentNode: node = ensure(stack.pop());\n\n    if (visited.find((visitedNode) => visitedNode === currentNode)) continue;\n\n    // Put the currentNode node in the visited set\n    visited.push(currentNode);\n\n    // If we found the end node, return the path to it\n    if (targetList.find((targetNode) => currentNode)) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, currentNode);\n      return [\n        [visited, shortestPath],\n        retrieveDistance(shortestPath, pairGrid, mazeGraph),\n      ];\n    }\n    console.log(stack);\n    // iterate through the neighbors of the currentNode node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentNode.x][currentNode.y])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0][0],\n        neighborY: number = neighbor[0][1];\n\n      // Check if the node is on the board\n      if (\n        neighborX < 0 ||\n        neighborX >= m ||\n        neighborY < 0 ||\n        neighborY >= n ||\n        discovered.find(\n          (discoveredNode) => discoveredNode === grid[neighborX][neighborY]\n        )\n      )\n        continue;\n\n      // Get the node in the grid\n      let nextNode: node = grid[neighborX][neighborY];\n\n      // update the predecessor array\n      predecessor[nextNode.id] = currentNode;\n\n      // Add the node to the discovered array\n      discovered.push(nextNode);\n\n      // Push the nextNode to the stack\n      stack.push(nextNode);\n    }\n  }\n\n  return [[visited, []], 0];\n};\n"]},"metadata":{},"sourceType":"module"}