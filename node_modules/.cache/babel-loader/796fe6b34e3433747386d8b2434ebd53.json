{"ast":null,"code":"import _createForOfIteratorHelper from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import{BinaryHeap}from\"../dataStructures/binaryHeap\";import{retrievePath}from\"./retrievePath\";import{ensure}from\"../ensureNotUndefined\";export var aStar=function aStar(grid,pairGrid,mazeGraph,startNode,endNode){var m=grid.length,n=grid[0].length;// Initialize the distances array\nvar distances=[];for(var i=0;i<m;i++){distances.push([]);for(var j=0;j<n;j++){distances[i].push(Number.MAX_SAFE_INTEGER);}}distances[startNode.x][startNode.y]=0;// Initialize the predecessor array\nvar predecessor=[];predecessor.fill(startNode,0,m*n);predecessor[startNode.id]=startNode;// Initialize the visited nodes array\nvar visited=[];//   Initialize the Binary Heap\nvar pq=new BinaryHeap(function(a,b){var dA=manhattanDistance(a[0],endNode),dB=manhattanDistance(b[0],endNode);if(distances[a[0].x][a[0].y]+dA!==distances[b[0].x][b[0].y]+dB){return distances[a[0].x][a[0].y]+dA<distances[b[0].x][b[0].y]+dB;}return a[1]<b[1];});pq.push(startNode);while(pq.size()>0){var currentNode=ensure(pq.pop());// add the current node to the visited nodes\nvisited.push(currentNode);// If we found the endNode, return the shortest path to it\nif(currentNode===endNode){// Retrieve the shortest path\nvar shortestPath=retrievePath(predecessor,startNode,endNode);return[visited,shortestPath];}// Get the coordinates of the nodes\nvar currentX=currentNode.x;var currentY=currentNode.y;// Iterate the neighbors of the node\nvar _iterator=_createForOfIteratorHelper(ensure(mazeGraph.get(pairGrid[currentX][currentY]))),_step;try{var _loop=function _loop(){var neighbor=_step.value;// Get the coordinates of the neighbor node\nvar neighborX=neighbor[0][0],neighborY=neighbor[0][1];// Check if the coordinates are valid\nif(neighborX<0||neighborX>=m||neighborY<0||neighborY>=n)return\"continue\";var nextNode=grid[neighborX][neighborY];// Calculate the distance between the current node and the next node\nvar currentDistance=distances[currentX][currentY]+neighbor[1];// If the distance is less than the distance in the array distances,\n// change it and change the predecessor of the next node to be the current one\nif(currentDistance<distances[neighborX][neighborY]){predecessor[nextNode.id]=currentNode;distances[neighborX][neighborY]=currentDistance;}// If the node is not yet visited, remove it from the heap and\n// put it back in with its new distance as the score function\nif(!visited.find(function(visitedNode){return visitedNode===nextNode;})){pq.remove(nextNode);pq.push(nextNode);}};for(_iterator.s();!(_step=_iterator.n()).done;){var _ret=_loop();if(_ret===\"continue\")continue;}}catch(err){_iterator.e(err);}finally{_iterator.f();}}return[visited,[]];};var manhattanDistance=function manhattanDistance(a,b){return Math.abs(b.x-a.x)+Math.abs(b.y-a.y);};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helperFunctions/shortestPathAlgorithms/aStar.ts"],"names":["BinaryHeap","retrievePath","ensure","aStar","grid","pairGrid","mazeGraph","startNode","endNode","m","length","n","distances","i","push","j","Number","MAX_SAFE_INTEGER","x","y","predecessor","fill","id","visited","pq","a","b","dA","manhattanDistance","dB","size","currentNode","pop","shortestPath","currentX","currentY","get","neighbor","neighborX","neighborY","nextNode","currentDistance","find","visitedNode","remove","Math","abs"],"mappings":"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","sourcesContent":["import { node } from \"../usefulInterfaces\";\nimport { BinaryHeap } from \"../dataStructures/binaryHeap\";\nimport { retrievePath } from \"./retrievePath\";\nimport { ensure } from \"../ensureNotUndefined\";\n\nexport const aStar: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>(\n    (a: [node, number], b: [node, number]) => {\n      let dA: number = manhattanDistance(a[0], endNode),\n        dB: number = manhattanDistance(b[0], endNode);\n      if (distances[a[0].x][a[0].y] + dA !== distances[b[0].x][b[0].y] + dB) {\n        return distances[a[0].x][a[0].y] + dA < distances[b[0].x][b[0].y] + dB;\n      }\n      return a[1] < b[1];\n    }\n  );\n\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    visited.push(currentNode);\n\n    // If we found the endNode, return the shortest path to it\n    if (currentNode === endNode) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, endNode);\n      return [visited, shortestPath];\n    }\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentX][currentY])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0][0],\n        neighborY: number = neighbor[0][1];\n\n      // Check if the coordinates are valid\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n)\n        continue;\n\n      let nextNode: node = grid[neighborX][neighborY];\n\n      // Calculate the distance between the current node and the next node\n      let currentDistance: number = distances[currentX][currentY] + neighbor[1];\n\n      // If the distance is less than the distance in the array distances,\n      // change it and change the predecessor of the next node to be the current one\n      if (currentDistance < distances[neighborX][neighborY]) {\n        predecessor[nextNode.id] = currentNode;\n        distances[neighborX][neighborY] = currentDistance;\n      }\n\n      // If the node is not yet visited, remove it from the heap and\n      // put it back in with its new distance as the score function\n      if (!visited.find((visitedNode) => visitedNode === nextNode)) {\n        pq.remove(nextNode);\n        pq.push(nextNode);\n      }\n    }\n  }\n  return [visited, []];\n};\n\nconst manhattanDistance: (a: node, b: node) => number = (a, b) => {\n  return Math.abs(b.x - a.x) + Math.abs(b.y - a.y);\n};\n"]},"metadata":{},"sourceType":"module"}