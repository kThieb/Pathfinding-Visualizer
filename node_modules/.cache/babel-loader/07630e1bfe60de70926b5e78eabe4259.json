{"ast":null,"code":"import _createForOfIteratorHelper from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import{BinaryHeap}from\"../binaryHeap\";import{retrievePath}from\"./retrievePath\";export var dijkstra=function dijkstra(grid,startNode,endNode){var m=grid.length,n=grid[0].length;// Initialize the distances array\nvar distances=[];for(var i=0;i<m;i++){distances.push([]);for(var j=0;j<n;j++){distances[i].push(Number.MAX_SAFE_INTEGER);}}distances[startNode.x][startNode.y]=0;// Initialize the predecessor array\nvar predecessor=[];predecessor.fill(startNode,0,m*n);predecessor[startNode.id]=startNode;// Initialize the visited nodes array\nvar visited=[];// Initialize the directions array we will use to perform Dijkstra's algorithm\nvar directions=[[0,1],[1,0],[0,-1],[-1,0]];//   Initialize the Binary Heap\nvar pq=new BinaryHeap(function(a){return distances[a.x][a.y];});pq.push(startNode);while(pq.size()>0){var currentNode=ensure(pq.pop());// add the current node to the visited nodes\n// currentNode.isVisited = true;\nvisited.push(currentNode);// Get the coordinates of the nodes\nvar currentX=currentNode.x;var currentY=currentNode.y;// Iterate the neighbors of the node\nvar _iterator=_createForOfIteratorHelper(directions),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var dir=_step.value;// Get the coordinates of the next node\nvar nextX=currentX+dir[0];var nextY=currentY+dir[1];// Check if the coordinates are valid\nif(nextX>=0&&nextX<m&&nextY>=0&&nextY<n){var _ret=function(){var nextNode=grid[nextX][nextY];// If the node is not yet visited, remove it from the heap and\n// put it back in with its new distance as the score function\nif(!visited.find(function(currentNode){return currentNode===nextNode;})){pq.remove(nextNode);pq.push(nextNode);}// Calculate the distance between the current node and the next node\n// To Do: take into account the weight of the path\nvar currentDistance=distances[currentX][currentY]+1;// If the distance is less than the distance in the array distances,\n// change it and change the predecessor of the next node to be the current one\nif(currentDistance<distances[nextX][nextY]){predecessor[nextNode.id]=currentNode;distances[nextX][nextY]=currentDistance;}// If we found the target node then we return what we need\nif(nextNode===endNode){// Retrieve the shortest path\nvar shortestPath=retrievePath(predecessor,startNode,endNode);visited.shift();// return the correct value\nreturn{v:[visited,shortestPath]};}}();if(typeof _ret===\"object\")return _ret.v;}}}catch(err){_iterator.e(err);}finally{_iterator.f();}}return[visited,[]];};export var dijkstraWithWalls=function dijkstraWithWalls(grid,pairGrid,mazeGraph,startNode,endNode){var m=grid.length,n=grid[0].length;// Initialize the distances array\nvar distances=[];for(var i=0;i<m;i++){distances.push([]);for(var j=0;j<n;j++){distances[i].push(Number.MAX_SAFE_INTEGER);}}distances[startNode.x][startNode.y]=0;// Initialize the predecessor array\nvar predecessor=[];predecessor.fill(startNode,0,m*n);predecessor[startNode.id]=startNode;// Initialize the visited nodes array\nvar visited=[];//   Initialize the Binary Heap\nvar pq=new BinaryHeap(function(a){return distances[a.x][a.y];});pq.push(startNode);while(pq.size()>0){var currentNode=ensure(pq.pop());// If we found the endNode, return the shortest path to it\nif(currentNode===endNode){// Retrieve the shortest path\nvar shortestPath=retrievePath(predecessor,startNode,endNode);visited.push(endNode);return[visited,shortestPath];}// add the current node to the visited nodes\n// currentNode.isVisited = true;\nvisited.push(currentNode);// Get the coordinates of the nodes\nvar currentX=currentNode.x;var currentY=currentNode.y;// Iterate the neighbors of the node\nvar _iterator2=_createForOfIteratorHelper(ensure(mazeGraph.get(pairGrid[currentX][currentY]))),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var neighbor=_step2.value;// Check if the coordinates are valid\nif(neighbor[0]>=0&&neighbor[0]<m&&neighbor[1]>=0&&neighbor[1]<n){(function(){var nextNode=grid[neighbor[0]][neighbor[1]];// Calculate the distance between the current node and the next node\n// To Do: take into account the weight of the path\nvar currentDistance=distances[currentX][currentY]+1;// If the distance is less than the distance in the array distances,\n// change it and change the predecessor of the next node to be the current one\nif(currentDistance<distances[neighbor[0]][neighbor[1]]){predecessor[nextNode.id]=currentNode;distances[neighbor[0]][neighbor[1]]=currentDistance;}// If the node is not yet visited, remove it from the heap and\n// put it back in with its new distance as the score function\nif(!visited.find(function(currentNode){return currentNode===nextNode;})){pq.remove(nextNode);pq.push(nextNode);}})();}}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}}return[visited,[]];};// This function is here to ensure that a value is not undefined (especially when using arrays).\nfunction ensure(argument){var message=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\"This value was promised to be there.\";if(argument===undefined||argument===null){throw new TypeError(message);}return argument;}","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helper_functions/shortestPathAlgorithms/dijkstra.ts"],"names":["BinaryHeap","retrievePath","dijkstra","grid","startNode","endNode","m","length","n","distances","i","push","j","Number","MAX_SAFE_INTEGER","x","y","predecessor","fill","id","visited","directions","pq","a","size","currentNode","ensure","pop","currentX","currentY","dir","nextX","nextY","nextNode","find","remove","currentDistance","shortestPath","shift","dijkstraWithWalls","pairGrid","mazeGraph","get","neighbor","argument","message","undefined","TypeError"],"mappings":"sNACA,OAASA,UAAT,KAA2B,eAA3B,CACA,OAASC,YAAT,KAA6B,gBAA7B,CAEA,MAAO,IAAMC,CAAAA,QAIQ,CAAG,QAJXA,CAAAA,QAIW,CAACC,IAAD,CAAOC,SAAP,CAAkBC,OAAlB,CAA8B,CACpD,GAAMC,CAAAA,CAAC,CAAGH,IAAI,CAACI,MAAf,CACEC,CAAC,CAAGL,IAAI,CAAC,CAAD,CAAJ,CAAQI,MADd,CAGA;AACA,GAAME,CAAAA,SAAqB,CAAG,EAA9B,CACA,IAAK,GAAIC,CAAAA,CAAS,CAAG,CAArB,CAAwBA,CAAC,CAAGJ,CAA5B,CAA+BI,CAAC,EAAhC,CAAoC,CAClCD,SAAS,CAACE,IAAV,CAAe,EAAf,EACA,IAAK,GAAIC,CAAAA,CAAS,CAAG,CAArB,CAAwBA,CAAC,CAAGJ,CAA5B,CAA+BI,CAAC,EAAhC,CAAoC,CAClCH,SAAS,CAACC,CAAD,CAAT,CAAaC,IAAb,CAAkBE,MAAM,CAACC,gBAAzB,EACD,CACF,CAEDL,SAAS,CAACL,SAAS,CAACW,CAAX,CAAT,CAAuBX,SAAS,CAACY,CAAjC,EAAsC,CAAtC,CAEA;AACA,GAAMC,CAAAA,WAAmB,CAAG,EAA5B,CACAA,WAAW,CAACC,IAAZ,CAAiBd,SAAjB,CAA4B,CAA5B,CAA+BE,CAAC,CAAGE,CAAnC,EACAS,WAAW,CAACb,SAAS,CAACe,EAAX,CAAX,CAA4Bf,SAA5B,CAEA;AACA,GAAIgB,CAAAA,OAAe,CAAG,EAAtB,CAEA;AACA,GAAMC,CAAAA,UAAsB,CAAG,CAC7B,CAAC,CAAD,CAAI,CAAJ,CAD6B,CAE7B,CAAC,CAAD,CAAI,CAAJ,CAF6B,CAG7B,CAAC,CAAD,CAAI,CAAC,CAAL,CAH6B,CAI7B,CAAC,CAAC,CAAF,CAAK,CAAL,CAJ6B,CAA/B,CAOA;AACA,GAAIC,CAAAA,EAAoB,CAAG,GAAItB,CAAAA,UAAJ,CAAqB,SAACuB,CAAD,CAAa,CAC3D,MAAOd,CAAAA,SAAS,CAACc,CAAC,CAACR,CAAH,CAAT,CAAeQ,CAAC,CAACP,CAAjB,CAAP,CACD,CAF0B,CAA3B,CAGAM,EAAE,CAACX,IAAH,CAAQP,SAAR,EAEA,MAAOkB,EAAE,CAACE,IAAH,GAAY,CAAnB,CAAsB,CACpB,GAAIC,CAAAA,WAAiB,CAAGC,MAAM,CAACJ,EAAE,CAACK,GAAH,EAAD,CAA9B,CAEA;AACA;AACAP,OAAO,CAACT,IAAR,CAAac,WAAb,EAEA;AACA,GAAIG,CAAAA,QAAgB,CAAGH,WAAW,CAACV,CAAnC,CACA,GAAIc,CAAAA,QAAgB,CAAGJ,WAAW,CAACT,CAAnC,CAEA;AAXoB,yCAYFK,UAZE,YAYpB,+CAA8B,IAAnBS,CAAAA,GAAmB,aAC5B;AACA,GAAIC,CAAAA,KAAa,CAAGH,QAAQ,CAAGE,GAAG,CAAC,CAAD,CAAlC,CACA,GAAIE,CAAAA,KAAa,CAAGH,QAAQ,CAAGC,GAAG,CAAC,CAAD,CAAlC,CAEA;AACA,GAAIC,KAAK,EAAI,CAAT,EAAcA,KAAK,CAAGzB,CAAtB,EAA2B0B,KAAK,EAAI,CAApC,EAAyCA,KAAK,CAAGxB,CAArD,CAAwD,qBACtD,GAAIyB,CAAAA,QAAc,CAAG9B,IAAI,CAAC4B,KAAD,CAAJ,CAAYC,KAAZ,CAArB,CAEA;AACA;AACA,GAAI,CAACZ,OAAO,CAACc,IAAR,CAAa,SAACT,WAAD,QAAiBA,CAAAA,WAAW,GAAKQ,QAAjC,EAAb,CAAL,CAA8D,CAC5DX,EAAE,CAACa,MAAH,CAAUF,QAAV,EACAX,EAAE,CAACX,IAAH,CAAQsB,QAAR,EACD,CAED;AACA;AACA,GAAIG,CAAAA,eAAuB,CAAG3B,SAAS,CAACmB,QAAD,CAAT,CAAoBC,QAApB,EAAgC,CAA9D,CAEA;AACA;AACA,GAAIO,eAAe,CAAG3B,SAAS,CAACsB,KAAD,CAAT,CAAiBC,KAAjB,CAAtB,CAA+C,CAC7Cf,WAAW,CAACgB,QAAQ,CAACd,EAAV,CAAX,CAA2BM,WAA3B,CACAhB,SAAS,CAACsB,KAAD,CAAT,CAAiBC,KAAjB,EAA0BI,eAA1B,CACD,CAED;AACA,GAAIH,QAAQ,GAAK5B,OAAjB,CAA0B,CACxB;AACA,GAAMgC,CAAAA,YAAY,CAAGpC,YAAY,CAACgB,WAAD,CAAcb,SAAd,CAAyBC,OAAzB,CAAjC,CACAe,OAAO,CAACkB,KAAR,GACA;AACA,SAAO,CAAClB,OAAD,CAAUiB,YAAV,CAAP,EACD,CA5BqD,4CA6BvD,CACF,CAhDmB,qDAiDrB,CAED,MAAO,CAACjB,OAAD,CAAU,EAAV,CAAP,CACD,CA7FM,CA+FP,MAAO,IAAMmB,CAAAA,iBAMQ,CAAG,QANXA,CAAAA,iBAMW,CAACpC,IAAD,CAAOqC,QAAP,CAAiBC,SAAjB,CAA4BrC,SAA5B,CAAuCC,OAAvC,CAAmD,CACzE,GAAMC,CAAAA,CAAC,CAAGH,IAAI,CAACI,MAAf,CACEC,CAAC,CAAGL,IAAI,CAAC,CAAD,CAAJ,CAAQI,MADd,CAGA;AACA,GAAME,CAAAA,SAAqB,CAAG,EAA9B,CACA,IAAK,GAAIC,CAAAA,CAAS,CAAG,CAArB,CAAwBA,CAAC,CAAGJ,CAA5B,CAA+BI,CAAC,EAAhC,CAAoC,CAClCD,SAAS,CAACE,IAAV,CAAe,EAAf,EACA,IAAK,GAAIC,CAAAA,CAAS,CAAG,CAArB,CAAwBA,CAAC,CAAGJ,CAA5B,CAA+BI,CAAC,EAAhC,CAAoC,CAClCH,SAAS,CAACC,CAAD,CAAT,CAAaC,IAAb,CAAkBE,MAAM,CAACC,gBAAzB,EACD,CACF,CAEDL,SAAS,CAACL,SAAS,CAACW,CAAX,CAAT,CAAuBX,SAAS,CAACY,CAAjC,EAAsC,CAAtC,CAEA;AACA,GAAMC,CAAAA,WAAmB,CAAG,EAA5B,CACAA,WAAW,CAACC,IAAZ,CAAiBd,SAAjB,CAA4B,CAA5B,CAA+BE,CAAC,CAAGE,CAAnC,EACAS,WAAW,CAACb,SAAS,CAACe,EAAX,CAAX,CAA4Bf,SAA5B,CAEA;AACA,GAAIgB,CAAAA,OAAe,CAAG,EAAtB,CAEA;AACA,GAAIE,CAAAA,EAAoB,CAAG,GAAItB,CAAAA,UAAJ,CAAqB,SAACuB,CAAD,CAAa,CAC3D,MAAOd,CAAAA,SAAS,CAACc,CAAC,CAACR,CAAH,CAAT,CAAeQ,CAAC,CAACP,CAAjB,CAAP,CACD,CAF0B,CAA3B,CAGAM,EAAE,CAACX,IAAH,CAAQP,SAAR,EAEA,MAAOkB,EAAE,CAACE,IAAH,GAAY,CAAnB,CAAsB,CACpB,GAAIC,CAAAA,WAAiB,CAAGC,MAAM,CAACJ,EAAE,CAACK,GAAH,EAAD,CAA9B,CAEA;AACA,GAAIF,WAAW,GAAKpB,OAApB,CAA6B,CAC3B;AACA,GAAMgC,CAAAA,YAAY,CAAGpC,YAAY,CAACgB,WAAD,CAAcb,SAAd,CAAyBC,OAAzB,CAAjC,CACAe,OAAO,CAACT,IAAR,CAAaN,OAAb,EACA,MAAO,CAACe,OAAD,CAAUiB,YAAV,CAAP,CACD,CAED;AACA;AACAjB,OAAO,CAACT,IAAR,CAAac,WAAb,EAEA;AACA,GAAIG,CAAAA,QAAgB,CAAGH,WAAW,CAACV,CAAnC,CACA,GAAIc,CAAAA,QAAgB,CAAGJ,WAAW,CAACT,CAAnC,CAEA;AAnBoB,0CAoBGU,MAAM,CAC3Be,SAAS,CAACC,GAAV,CAAcF,QAAQ,CAACZ,QAAD,CAAR,CAAmBC,QAAnB,CAAd,CAD2B,CApBT,aAoBpB,kDAEG,IAFQc,CAAAA,QAER,cACD;AACA,GACEA,QAAQ,CAAC,CAAD,CAAR,EAAe,CAAf,EACAA,QAAQ,CAAC,CAAD,CAAR,CAAcrC,CADd,EAEAqC,QAAQ,CAAC,CAAD,CAAR,EAAe,CAFf,EAGAA,QAAQ,CAAC,CAAD,CAAR,CAAcnC,CAJhB,CAKE,aACA,GAAIyB,CAAAA,QAAc,CAAG9B,IAAI,CAACwC,QAAQ,CAAC,CAAD,CAAT,CAAJ,CAAkBA,QAAQ,CAAC,CAAD,CAA1B,CAArB,CAEA;AACA;AACA,GAAIP,CAAAA,eAAuB,CAAG3B,SAAS,CAACmB,QAAD,CAAT,CAAoBC,QAApB,EAAgC,CAA9D,CAEA;AACA;AACA,GAAIO,eAAe,CAAG3B,SAAS,CAACkC,QAAQ,CAAC,CAAD,CAAT,CAAT,CAAuBA,QAAQ,CAAC,CAAD,CAA/B,CAAtB,CAA2D,CACzD1B,WAAW,CAACgB,QAAQ,CAACd,EAAV,CAAX,CAA2BM,WAA3B,CACAhB,SAAS,CAACkC,QAAQ,CAAC,CAAD,CAAT,CAAT,CAAuBA,QAAQ,CAAC,CAAD,CAA/B,EAAsCP,eAAtC,CACD,CAED;AACA;AACA,GAAI,CAAChB,OAAO,CAACc,IAAR,CAAa,SAACT,WAAD,QAAiBA,CAAAA,WAAW,GAAKQ,QAAjC,EAAb,CAAL,CAA8D,CAC5DX,EAAE,CAACa,MAAH,CAAUF,QAAV,EACAX,EAAE,CAACX,IAAH,CAAQsB,QAAR,EACD,CAnBD,KAoBD,CACF,CAlDmB,uDAmDrB,CAED,MAAO,CAACb,OAAD,CAAU,EAAV,CAAP,CACD,CAzFM,CA2FP;AACA,QAASM,CAAAA,MAAT,CACEkB,QADF,CAGK,IADHC,CAAAA,OACG,2DADe,sCACf,CACH,GAAID,QAAQ,GAAKE,SAAb,EAA0BF,QAAQ,GAAK,IAA3C,CAAiD,CAC/C,KAAM,IAAIG,CAAAA,SAAJ,CAAcF,OAAd,CAAN,CACD,CAED,MAAOD,CAAAA,QAAP,CACD","sourcesContent":["import { node } from \"../usefulInterfaces\";\nimport { BinaryHeap } from \"../binaryHeap\";\nimport { retrievePath } from \"./retrievePath\";\n\nexport const dijkstra: (\n  grid: node[][],\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  // Initialize the directions array we will use to perform Dijkstra's algorithm\n  const directions: number[][] = [\n    [0, 1],\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n  ];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>((a: node) => {\n    return distances[a.x][a.y];\n  });\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n    visited.push(currentNode);\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const dir of directions) {\n      // Get the coordinates of the next node\n      let nextX: number = currentX + dir[0];\n      let nextY: number = currentY + dir[1];\n\n      // Check if the coordinates are valid\n      if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n) {\n        let nextNode: node = grid[nextX][nextY];\n\n        // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n        if (!visited.find((currentNode) => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          pq.push(nextNode);\n        }\n\n        // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n        let currentDistance: number = distances[currentX][currentY] + 1;\n\n        // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n        if (currentDistance < distances[nextX][nextY]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[nextX][nextY] = currentDistance;\n        }\n\n        // If we found the target node then we return what we need\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrievePath(predecessor, startNode, endNode);\n          visited.shift();\n          // return the correct value\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n};\n\nexport const dijkstraWithWalls: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [number, number][]>,\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>((a: node) => {\n    return distances[a.x][a.y];\n  });\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // If we found the endNode, return the shortest path to it\n    if (currentNode === endNode) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, endNode);\n      visited.push(endNode);\n      return [visited, shortestPath];\n    }\n\n    // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n    visited.push(currentNode);\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentX][currentY])\n    )) {\n      // Check if the coordinates are valid\n      if (\n        neighbor[0] >= 0 &&\n        neighbor[0] < m &&\n        neighbor[1] >= 0 &&\n        neighbor[1] < n\n      ) {\n        let nextNode: node = grid[neighbor[0]][neighbor[1]];\n\n        // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n        let currentDistance: number = distances[currentX][currentY] + 1;\n\n        // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n        if (currentDistance < distances[neighbor[0]][neighbor[1]]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[neighbor[0]][neighbor[1]] = currentDistance;\n        }\n\n        // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n        if (!visited.find((currentNode) => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          pq.push(nextNode);\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n};\n\n// This function is here to ensure that a value is not undefined (especially when using arrays).\nfunction ensure<T>(\n  argument: T | undefined | null,\n  message: string = \"This value was promised to be there.\"\n): T {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}\n"]},"metadata":{},"sourceType":"module"}