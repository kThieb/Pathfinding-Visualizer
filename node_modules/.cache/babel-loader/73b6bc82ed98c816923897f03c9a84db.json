{"ast":null,"code":"import { BinaryHeap } from \"../binaryHeap\";\nimport { retrievePath } from \"./retrievePath\";\nexport const dijkstra = (grid, startNode, endNode) => {\n  const m = grid.length,\n        n = grid[0].length; // Initialize the distances array\n\n  const distances = [];\n\n  for (let i = 0; i < m; i++) {\n    distances.push([]);\n\n    for (let j = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0; // Initialize the predecessor array\n\n  const predecessor = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode; // Initialize the visited nodes array\n\n  let visited = []; // Initialize the directions array we will use to perform Dijkstra's algorithm\n\n  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]; //   Initialize the Binary Heap\n\n  let pq = new BinaryHeap(a => {\n    return distances[a.x][a.y];\n  });\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode = ensure(pq.pop()); // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n\n    visited.push(currentNode); // Get the coordinates of the nodes\n\n    let currentX = currentNode.x;\n    let currentY = currentNode.y; // Iterate the neighbors of the node\n\n    for (const dir of directions) {\n      // Get the coordinates of the next node\n      let nextX = currentX + dir[0];\n      let nextY = currentY + dir[1]; // Check if the coordinates are valid\n\n      if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n) {\n        let nextNode = grid[nextX][nextY]; // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n\n        if (!visited.find(currentNode => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          pq.push(nextNode);\n        } // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n\n\n        let currentDistance = distances[currentX][currentY] + 1; // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n\n        if (currentDistance < distances[nextX][nextY]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[nextX][nextY] = currentDistance;\n        } // If we found the target node then we return what we need\n\n\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrievePath(predecessor, startNode, endNode);\n          visited.shift(); // return the correct value\n\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n};\nexport const dijkstraWithWalls = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n        n = grid[0].length; // Initialize the distances array\n\n  const distances = [];\n\n  for (let i = 0; i < m; i++) {\n    distances.push([]);\n\n    for (let j = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0; // Initialize the predecessor array\n\n  const predecessor = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode; // Initialize the visited nodes array\n\n  let visited = []; //   Initialize the Binary Heap\n\n  let pq = new BinaryHeap(a => {\n    return distances[a.x][a.y];\n  });\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode = ensure(pq.pop()); // If we found the endNode, return the shortest path to it\n\n    if (currentNode === endNode) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, endNode);\n      visited.push(endNode);\n      return [visited, shortestPath];\n    } // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n\n\n    visited.push(currentNode); // Get the coordinates of the nodes\n\n    let currentX = currentNode.x;\n    let currentY = currentNode.y; // Iterate the neighbors of the node\n\n    for (const neighbor of ensure(mazeGraph.get(pairGrid[currentX][currentY]))) {\n      // Check if the coordinates are valid\n      if (neighbor[0] >= 0 && neighbor[0] < m && neighbor[1] >= 0 && neighbor[1] < n) {\n        let nextNode = grid[neighbor[0]][neighbor[1]]; // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n\n        let currentDistance = distances[currentX][currentY] + 1; // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n\n        let changedDistance = false;\n\n        if (currentDistance < distances[neighbor[0]][neighbor[1]]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[neighbor[0]][neighbor[1]] = currentDistance;\n          changedDistance = true;\n        } // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n\n\n        if (!visited.find(currentNode => currentNode === nextNode)) {\n          if (changedDistance) pq.remove(nextNode); // nextNode.pqIndex = index++;\n\n          pq.push(nextNode);\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n}; // This function is here to ensure that a value is not undefined (especially when using arrays).\n\nfunction ensure(argument, message = \"This value was promised to be there.\") {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helper_functions/shortestPathAlgorithms/dijkstra.ts"],"names":["BinaryHeap","retrievePath","dijkstra","grid","startNode","endNode","m","length","n","distances","i","push","j","Number","MAX_SAFE_INTEGER","x","y","predecessor","fill","id","visited","directions","pq","a","size","currentNode","ensure","pop","currentX","currentY","dir","nextX","nextY","nextNode","find","remove","currentDistance","shortestPath","shift","dijkstraWithWalls","pairGrid","mazeGraph","neighbor","get","changedDistance","argument","message","undefined","TypeError"],"mappings":"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","sourcesContent":["import { node } from \"../usefulInterfaces\";\nimport { BinaryHeap } from \"../binaryHeap\";\nimport { retrievePath } from \"./retrievePath\";\n\nexport const dijkstra: (\n  grid: node[][],\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  // Initialize the directions array we will use to perform Dijkstra's algorithm\n  const directions: number[][] = [\n    [0, 1],\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n  ];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>((a: node) => {\n    return distances[a.x][a.y];\n  });\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n    visited.push(currentNode);\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const dir of directions) {\n      // Get the coordinates of the next node\n      let nextX: number = currentX + dir[0];\n      let nextY: number = currentY + dir[1];\n\n      // Check if the coordinates are valid\n      if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n) {\n        let nextNode: node = grid[nextX][nextY];\n\n        // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n        if (!visited.find((currentNode) => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          pq.push(nextNode);\n        }\n\n        // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n        let currentDistance: number = distances[currentX][currentY] + 1;\n\n        // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n        if (currentDistance < distances[nextX][nextY]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[nextX][nextY] = currentDistance;\n        }\n\n        // If we found the target node then we return what we need\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrievePath(predecessor, startNode, endNode);\n          visited.shift();\n          // return the correct value\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n};\n\nexport const dijkstraWithWalls: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [number, number][]>,\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>((a: node) => {\n    return distances[a.x][a.y];\n  });\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // If we found the endNode, return the shortest path to it\n    if (currentNode === endNode) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, endNode);\n      visited.push(endNode);\n      return [visited, shortestPath];\n    }\n\n    // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n    visited.push(currentNode);\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentX][currentY])\n    )) {\n      // Check if the coordinates are valid\n      if (\n        neighbor[0] >= 0 &&\n        neighbor[0] < m &&\n        neighbor[1] >= 0 &&\n        neighbor[1] < n\n      ) {\n        let nextNode: node = grid[neighbor[0]][neighbor[1]];\n\n        // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n        let currentDistance: number = distances[currentX][currentY] + 1;\n\n        // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n        let changedDistance: boolean = false;\n        if (currentDistance < distances[neighbor[0]][neighbor[1]]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[neighbor[0]][neighbor[1]] = currentDistance;\n          changedDistance = true;\n        }\n\n        // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n        if (!visited.find((currentNode) => currentNode === nextNode)) {\n          if (changedDistance) pq.remove(nextNode);\n          // nextNode.pqIndex = index++;\n          pq.push(nextNode);\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n};\n\n// This function is here to ensure that a value is not undefined (especially when using arrays).\nfunction ensure<T>(\n  argument: T | undefined | null,\n  message: string = \"This value was promised to be there.\"\n): T {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}\n"]},"metadata":{},"sourceType":"module"}