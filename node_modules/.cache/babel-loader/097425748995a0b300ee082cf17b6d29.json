{"ast":null,"code":"// This function (Not a React Component!) is made to initialize the grid rendered in the App component.\nexport const constructGrid = (numberOfRow, numberOfColumn, startNode, endNode, numberOfTargets) => {\n  let result = [];\n\n  for (let i = 0; i < numberOfColumn; i++) {\n    let currentRow = [];\n\n    for (let j = 0; j < numberOfRow; j++) {\n      let currentNode = {\n        id: i + j * numberOfColumn,\n        x: i,\n        y: j,\n        isStart: false,\n        hasCheese: false,\n        hasRat: false,\n        isVisited: false,\n        isShortestPath: false,\n        successorPosition: \"\"\n      };\n      currentRow.push(currentNode);\n    }\n\n    result.push(currentRow);\n  }\n\n  result[startNode[0]][startNode[1]].isStart = true;\n  result[startNode[0]][startNode[1]].hasRat = true;\n  result[endNode[0]][endNode[1]].hasCheese = true;\n  let targetList = [result[endNode[0]][endNode[1]]];\n  if (numberOfTargets >= 1) [result, targetList] = piecesOfCheese(result, startNode, endNode, numberOfTargets);\n  return [result, result[startNode[0]][startNode[1]], targetList];\n};\nexport const reconstructGrid = (numberOfRow, numberOfColumn, startNode, targetList) => {\n  let result = [];\n\n  for (let i = 0; i < numberOfColumn; i++) {\n    let currentRow = [];\n\n    for (let j = 0; j < numberOfRow; j++) {\n      let currentNode = {\n        id: i + j * numberOfColumn,\n        x: i,\n        y: j,\n        isStart: false,\n        hasCheese: targetList.find(targetNode => targetNode.x === i && targetNode.y === j) ? true : false,\n        hasRat: false,\n        isVisited: false,\n        isFirstShortestPath: false,\n        isSecondShortestPath: false,\n        successorPosition: \"\"\n      };\n      currentRow.push(currentNode);\n    }\n\n    result.push(currentRow);\n  }\n\n  result[startNode[0]][startNode[1]].isStart = true;\n  result[startNode[0]][startNode[1]].hasRat = true;\n  let newTargetList = targetList.map(targetNode => result[targetNode.x][targetNode.y]);\n  return [result, result[startNode[0]][startNode[1]], newTargetList];\n};\n\nconst piecesOfCheese = (grid, startNode, endNode, cheeseNum) => {\n  const n = grid.length,\n        m = grid[0].length;\n  const targetList = [grid[endNode[0]][endNode[1]]];\n  let visited = new Array(n);\n\n  for (let i = 0; i < n; ++i) {\n    visited[i] = new Array(m);\n  }\n\n  for (let i = 0; i < n; ++i) {\n    for (let j = 0; j < m; ++j) {\n      visited[i][j] = false;\n    }\n  }\n\n  visited[startNode[0]][startNode[1]] = true;\n  visited[endNode[0]][endNode[1]] = true;\n\n  for (let k = 0; k < cheeseNum; k++) {\n    let i = -1,\n        j = -1;\n\n    do {\n      i = Math.floor(Math.random() * n);\n      j = Math.floor(Math.random() * m);\n    } while (visited[i][j]);\n\n    visited[i][j] = true;\n    grid[i][j].hasCheese = true;\n    targetList.push(grid[i][j]);\n  }\n\n  return [grid, targetList];\n};\n\nexport const addPiecesOfCheese = (numberOfRows, numberOfColumn, startNode, oldTargetList, cheeseToAdd) => {\n  // let targetList: node[] = [];\n  while (cheeseToAdd < 0) {\n    let randIndex = Math.floor(Math.random() * oldTargetList.length);\n    oldTargetList = oldTargetList.filter((targetNode, index) => index !== randIndex);\n    cheeseToAdd++;\n  }\n\n  const [newGrid, newStartNode, targetList] = reconstructGrid(numberOfRows, numberOfColumn, [startNode.x, startNode.y], oldTargetList);\n  let visited = new Array(numberOfColumn);\n\n  for (let i = 0; i < numberOfColumn; ++i) {\n    visited[i] = new Array(numberOfRows);\n  }\n\n  for (let i = 0; i < numberOfColumn; ++i) {\n    for (let j = 0; j < numberOfRows; ++j) {\n      visited[i][j] = false;\n    }\n  }\n\n  visited[startNode.x][startNode.y] = true;\n  targetList.forEach(targetNode => {\n    visited[targetNode.x][targetNode.y] = true;\n  });\n\n  for (let k = 0; k < cheeseToAdd; k++) {\n    let i = -1,\n        j = -1;\n\n    do {\n      i = Math.floor(Math.random() * numberOfColumn);\n      j = Math.floor(Math.random() * numberOfRows);\n    } while (visited[i][j]);\n\n    visited[i][j] = true;\n    newGrid[i][j].hasCheese = true;\n    targetList.push(newGrid[i][j]);\n  }\n\n  return [newGrid, newStartNode, targetList];\n};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helperFunctions/constructGrid.ts"],"names":["constructGrid","numberOfRow","numberOfColumn","startNode","endNode","numberOfTargets","result","i","currentRow","j","currentNode","id","x","y","isStart","hasCheese","hasRat","isVisited","isShortestPath","successorPosition","push","targetList","piecesOfCheese","reconstructGrid","find","targetNode","isFirstShortestPath","isSecondShortestPath","newTargetList","map","grid","cheeseNum","n","length","m","visited","Array","k","Math","floor","random","addPiecesOfCheese","numberOfRows","oldTargetList","cheeseToAdd","randIndex","filter","index","newGrid","newStartNode","forEach"],"mappings":"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","sourcesContent":["import { node } from \"./usefulInterfaces\";\n\n// This function (Not a React Component!) is made to initialize the grid rendered in the App component.\nexport const constructGrid: (\n  numberOfRows: number,\n  numberOfColumn: number,\n  startNode: [number, number],\n  endNode: [number, number],\n  numberOfTargets: number\n) => [node[][], node, node[]] = (\n  numberOfRow,\n  numberOfColumn,\n  startNode,\n  endNode,\n  numberOfTargets\n) => {\n  let result: node[][] = [];\n  for (let i: number = 0; i < numberOfColumn; i++) {\n    let currentRow: node[] = [];\n    for (let j: number = 0; j < numberOfRow; j++) {\n      let currentNode: node = {\n        id: i + j * numberOfColumn,\n        x: i,\n        y: j,\n        isStart: false,\n        hasCheese: false,\n        hasRat: false,\n        isVisited: false,\n        isShortestPath: false,\n\n        successorPosition: \"\",\n      };\n      currentRow.push(currentNode);\n    }\n    result.push(currentRow);\n  }\n  result[startNode[0]][startNode[1]].isStart = true;\n  result[startNode[0]][startNode[1]].hasRat = true;\n  result[endNode[0]][endNode[1]].hasCheese = true;\n  let targetList: node[] = [result[endNode[0]][endNode[1]]];\n  if (numberOfTargets >= 1)\n    [result, targetList] = piecesOfCheese(\n      result,\n      startNode,\n      endNode,\n      numberOfTargets\n    );\n  return [result, result[startNode[0]][startNode[1]], targetList];\n};\n\nexport const reconstructGrid: (\n  numberOfRows: number,\n  numberOfColumn: number,\n  startNode: [number, number],\n  targetList: node[]\n) => [node[][], node, node[]] = (\n  numberOfRow,\n  numberOfColumn,\n  startNode,\n  targetList\n) => {\n  let result: node[][] = [];\n  for (let i: number = 0; i < numberOfColumn; i++) {\n    let currentRow: node[] = [];\n    for (let j: number = 0; j < numberOfRow; j++) {\n      let currentNode: node = {\n        id: i + j * numberOfColumn,\n        x: i,\n        y: j,\n        isStart: false,\n        hasCheese: targetList.find(\n          (targetNode) => targetNode.x === i && targetNode.y === j\n        )\n          ? true\n          : false,\n        hasRat: false,\n        isVisited: false,\n        isFirstShortestPath: false,\n        isSecondShortestPath: false,\n        successorPosition: \"\",\n      };\n      currentRow.push(currentNode);\n    }\n    result.push(currentRow);\n  }\n  result[startNode[0]][startNode[1]].isStart = true;\n  result[startNode[0]][startNode[1]].hasRat = true;\n  let newTargetList: node[] = targetList.map(\n    (targetNode) => result[targetNode.x][targetNode.y]\n  );\n  return [result, result[startNode[0]][startNode[1]], newTargetList];\n};\n\nconst piecesOfCheese: (\n  grid: node[][],\n  startNode: [number, number],\n  endNode: [number, number],\n  cheeseNum: number\n) => [node[][], node[]] = (grid, startNode, endNode, cheeseNum) => {\n  const n: number = grid.length,\n    m: number = grid[0].length;\n  const targetList: node[] = [grid[endNode[0]][endNode[1]]];\n  let visited: boolean[][] = new Array(n);\n  for (let i: number = 0; i < n; ++i) {\n    visited[i] = new Array(m);\n  }\n  for (let i: number = 0; i < n; ++i) {\n    for (let j: number = 0; j < m; ++j) {\n      visited[i][j] = false;\n    }\n  }\n\n  visited[startNode[0]][startNode[1]] = true;\n  visited[endNode[0]][endNode[1]] = true;\n  for (let k: number = 0; k < cheeseNum; k++) {\n    let i = -1,\n      j = -1;\n    do {\n      i = Math.floor(Math.random() * n);\n      j = Math.floor(Math.random() * m);\n    } while (visited[i][j]);\n    visited[i][j] = true;\n    grid[i][j].hasCheese = true;\n    targetList.push(grid[i][j]);\n  }\n  return [grid, targetList];\n};\n\nexport const addPiecesOfCheese: (\n  numberOfRows: number,\n  numberOfColumn: number,\n  startNode: node,\n  oldTargetList: node[],\n  cheeseToAdd: number\n) => [node[][], node, node[]] = (\n  numberOfRows,\n  numberOfColumn,\n  startNode,\n  oldTargetList,\n  cheeseToAdd\n) => {\n  // let targetList: node[] = [];\n  while (cheeseToAdd < 0) {\n    let randIndex: number = Math.floor(Math.random() * oldTargetList.length);\n    oldTargetList = oldTargetList.filter(\n      (targetNode, index) => index !== randIndex\n    );\n    cheeseToAdd++;\n  }\n\n  const [newGrid, newStartNode, targetList] = reconstructGrid(\n    numberOfRows,\n    numberOfColumn,\n    [startNode.x, startNode.y],\n    oldTargetList\n  );\n\n  let visited: boolean[][] = new Array(numberOfColumn);\n  for (let i: number = 0; i < numberOfColumn; ++i) {\n    visited[i] = new Array(numberOfRows);\n  }\n  for (let i: number = 0; i < numberOfColumn; ++i) {\n    for (let j: number = 0; j < numberOfRows; ++j) {\n      visited[i][j] = false;\n    }\n  }\n\n  visited[startNode.x][startNode.y] = true;\n  targetList.forEach((targetNode) => {\n    visited[targetNode.x][targetNode.y] = true;\n  });\n  for (let k: number = 0; k < cheeseToAdd; k++) {\n    let i = -1,\n      j = -1;\n    do {\n      i = Math.floor(Math.random() * numberOfColumn);\n      j = Math.floor(Math.random() * numberOfRows);\n    } while (visited[i][j]);\n    visited[i][j] = true;\n    newGrid[i][j].hasCheese = true;\n    targetList.push(newGrid[i][j]);\n  }\n  return [newGrid, newStartNode, targetList];\n};\n"]},"metadata":{},"sourceType":"module"}