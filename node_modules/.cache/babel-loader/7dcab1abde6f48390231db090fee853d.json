{"ast":null,"code":"import _toConsumableArray from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _objectSpread from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _slicedToArray from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import React,{useState}from\"react\";import\"./Visualizer.css\";import{Grid}from\"../Grid/Grid\";import{NavBar,NavDropDownItem,DropDownMenu,DropDownAlgo,DropDownSlider,NavChangingButtonItem}from\"../NavBar/NavBar\";import{dijkstraWithWalls}from\"../helper_functions/shortestPathAlgorithms/dijkstra\";import{createEmptyMazeGraph,generateMazeGraph}from\"../helper_functions/mazeGenerators/mazeGraph\";import{constructGrid}from\"../helper_functions/constructGrid\";var NUMBER_OF_ROWS=28;var NUMBER_OF_COLUMN=13;// We define these constants out of the functional component\n// that the App uses to avoid re-running the functions to create\n// these each time there is a re-render\nvar _constructGrid=constructGrid(NUMBER_OF_ROWS,NUMBER_OF_COLUMN,[6,3],[6,24]),_constructGrid2=_slicedToArray(_constructGrid,3),firstGrid=_constructGrid2[0],firstStartNode=_constructGrid2[1],firstEndNode=_constructGrid2[2];var _createEmptyMazeGraph=createEmptyMazeGraph(NUMBER_OF_ROWS,NUMBER_OF_COLUMN,firstGrid),_createEmptyMazeGraph2=_slicedToArray(_createEmptyMazeGraph,2),firstpairGrid=_createEmptyMazeGraph2[0],mazeGraph=_createEmptyMazeGraph2[1];// Component rendering everything in the webpage.\nvar Visualizer=function Visualizer(){// States managing the grid\nvar _useState=useState(firstGrid),_useState2=_slicedToArray(_useState,2),grid=_useState2[0],setGrid=_useState2[1];var _useState3=useState(mazeGraph),_useState4=_slicedToArray(_useState3,2),maze=_useState4[0],setMaze=_useState4[1];var _useState5=useState(firstpairGrid),_useState6=_slicedToArray(_useState5,2),pairGrid=_useState6[0],setPairGrid=_useState6[1];var _useState7=useState(\"dijkstraWithWalls\"),_useState8=_slicedToArray(_useState7,2),algorithm=_useState8[0],setAlgorithm=_useState8[1];var _useState9=useState(0.7),_useState10=_slicedToArray(_useState9,2),wallsDensity=_useState10[0],setWallsDensity=_useState10[1];var _useState11=useState(false),_useState12=_slicedToArray(_useState11,2),isVisualized=_useState12[0],setIsVisualized=_useState12[1];// const [mouseIsPressed, setMouseIsPressed] = useState(false);\n// States of the start and end node\nvar _useState13=useState(firstStartNode),_useState14=_slicedToArray(_useState13,2),startNode=_useState14[0],setStartNode=_useState14[1];var _useState15=useState(firstEndNode),_useState16=_slicedToArray(_useState15,2),endNode=_useState16[0],setEndNode=_useState16[1];// This function is there to visualize the algorithm chosen in the drop down menu\nvar visualizeAlgorithm=function visualizeAlgorithm(visited,path){var n=visited.length;var _loop=function _loop(i){setTimeout(function(){var newGrid=grid.slice();var node=visited[i];// define the x and y of the current node\nvar x=node.x;var y=node.y;var newNode=_objectSpread(_objectSpread({},node),{},{isVisited:true,className:\"grid-node visited-node\",waitClassChange:0});newGrid[x][y]=newNode;setGrid(newGrid);},30*i);};for(var i=0;i<n;i++){_loop(i);}var m=path.length;var _loop2=function _loop2(_i){setTimeout(function(){var newGrid=grid.slice();var node=path[_i];// define the x and y of the current node\nvar x=node.x;var y=node.y;var newNode=_objectSpread(_objectSpread({},node),{},{isShortestPath:true,className:\"grid-node shortest-path-node\",waitClassChange:0});newGrid[x][y]=newNode;setGrid(newGrid);},30*n+150*_i);};for(var _i=0;_i<m;_i++){_loop2(_i);}};// This function is passed to the drop down menu to handle the change of algorithm\nvar handleAlgorithmChange=function handleAlgorithmChange(algorithmName){setAlgorithm(algorithmName);};// This function changes the algorithm that will be run, at the moment only dijkstra is implemented\nvar chooseAlgorithm=function chooseAlgorithm(algorithmName){if(algorithmName===\"dijkstraWithWalls\"){return dijkstraWithWalls;}return dijkstraWithWalls;};// This function calls the generate maze function\nvar generateMaze=function generateMaze(){var newGrid=grid.slice();var _generateMazeGraph=generateMazeGraph(NUMBER_OF_ROWS,NUMBER_OF_COLUMN,newGrid,wallsDensity),_generateMazeGraph2=_slicedToArray(_generateMazeGraph,2),newPairGrid=_generateMazeGraph2[0],newMaze=_generateMazeGraph2[1];setGrid(newGrid);setPairGrid(newPairGrid);setMaze(newMaze);};// Reinitialize the the board\nvar reinitialize=function reinitialize(){var _constructGrid3=constructGrid(NUMBER_OF_ROWS,NUMBER_OF_COLUMN,[startNode.x,startNode.y],[endNode.x,endNode.y]),_constructGrid4=_slicedToArray(_constructGrid3,3),newGrid=_constructGrid4[0],newStartNode=_constructGrid4[1],newEndNode=_constructGrid4[2];var _createEmptyMazeGraph3=createEmptyMazeGraph(NUMBER_OF_ROWS,NUMBER_OF_COLUMN,newGrid),_createEmptyMazeGraph4=_slicedToArray(_createEmptyMazeGraph3,2),newPairGrid=_createEmptyMazeGraph4[0],newMaze=_createEmptyMazeGraph4[1];setGrid(newGrid);setPairGrid(newPairGrid);setMaze(newMaze);setStartNode(newStartNode);setEndNode(newEndNode);setIsVisualized(false);};// The following block of functions handles the making of walls in the grid\n// This feature is currently not used as it is not a good fit with the current direction of the app\n// const toggleWall: (x: number, y: number) => void = (x, y) => {\n//   const newGrid: node[][] = grid.slice();\n//   let newNode;\n//   if (!newGrid[x][y].isWall) {\n//     newNode = {\n//       ...newGrid[x][y],\n//       isWall: !newGrid[x][y].isWall,\n//       className: \"grid-node wall-node\",\n//     };\n//   } else {\n//     newNode = {\n//       ...newGrid[x][y],\n//       isWall: !newGrid[x][y].isWall,\n//       className: \"grid-node\",\n//     };\n//   }\n//   newGrid[x][y] = newNode;\n//   setGrid(newGrid);\n// };\n// // handles the case when the mouse button is down\n// const handleMouseDown: (x: number, y: number) => void = (x, y) => {\n//   toggleWall(x, y);\n//   setMouseIsPressed(false);\n// };\n// // handles the case whan the mouse button is down and you enter a node\n// const handleMouseEnter: (x: number, y: number) => void = (x, y) => {\n//   if (mouseIsPressed) {\n//     toggleWall(x, y);\n//   }\n// };\n// // handles the case when you mouse up\n// const handleMouseUp: () => void = () => {\n//   setMouseIsPressed(false);\n// };\n// Render the app\nreturn/*#__PURE__*/React.createElement(\"div\",{className:\"App\"},/*#__PURE__*/React.createElement(NavBar,null,/*#__PURE__*/React.createElement(NavChangingButtonItem,{isVisualized:isVisualized,className:\"reinitialize\",visualizedClassName:\"highlight\",handleClick:reinitialize},\"Reinitialize\"),/*#__PURE__*/React.createElement(NavChangingButtonItem,{isVisualized:isVisualized,className:\"generate-maze\",visualizedClassName:\"greyed-out\",handleClick:generateMaze},\"Generate maze\"),/*#__PURE__*/React.createElement(NavDropDownItem,{tabIndex:1,icon:\"\",text:\"Maze options\",id:\"maze-options\",isVisualized:isVisualized,shouldGreyOut:true},/*#__PURE__*/React.createElement(DropDownMenu,{left:false},/*#__PURE__*/React.createElement(DropDownSlider,{isVisualized:isVisualized,minValue:0.1,maxValue:1,defaultValue:wallsDensity,text:\"Density of walls\",handleChangeWallsDensity:setWallsDensity}))),/*#__PURE__*/React.createElement(NavChangingButtonItem,{isVisualized:isVisualized,className:\"visualize-button\",visualizedClassName:\"greyed-out\",handleClick:function handleClick(){if(!isVisualized){visualizeAlgorithm.apply(void 0,_toConsumableArray(chooseAlgorithm(algorithm)(grid,pairGrid,maze,startNode,endNode)));setIsVisualized(true);}}},\"Visualize!\"),/*#__PURE__*/React.createElement(NavDropDownItem,{tabIndex:2,icon:\"\\u3233\",text:\"Algorithm\",id:\"algorithms\",isVisualized:isVisualized,shouldGreyOut:false},/*#__PURE__*/React.createElement(DropDownMenu,{left:true},/*#__PURE__*/React.createElement(DropDownAlgo,{changeAlgorithm:handleAlgorithmChange,algorithmName:\"dijkstraWithWalls\"},/*#__PURE__*/React.createElement(\"p\",null,\"Dijkstra's Algorithm\"),algorithm===\"dijkstraWithWalls\"?/*#__PURE__*/React.createElement(\"p\",null,\"\\u2713\"):\"\")))),/*#__PURE__*/React.createElement(Grid,{grid:grid,pairGrid:pairGrid,maze:maze}));};export default Visualizer;","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/Visualizer/Visualizer.tsx"],"names":["React","useState","Grid","NavBar","NavDropDownItem","DropDownMenu","DropDownAlgo","DropDownSlider","NavChangingButtonItem","dijkstraWithWalls","createEmptyMazeGraph","generateMazeGraph","constructGrid","NUMBER_OF_ROWS","NUMBER_OF_COLUMN","firstGrid","firstStartNode","firstEndNode","firstpairGrid","mazeGraph","Visualizer","grid","setGrid","maze","setMaze","pairGrid","setPairGrid","algorithm","setAlgorithm","wallsDensity","setWallsDensity","isVisualized","setIsVisualized","startNode","setStartNode","endNode","setEndNode","visualizeAlgorithm","visited","path","n","length","i","setTimeout","newGrid","slice","node","x","y","newNode","isVisited","className","waitClassChange","m","isShortestPath","handleAlgorithmChange","algorithmName","chooseAlgorithm","generateMaze","newPairGrid","newMaze","reinitialize","newStartNode","newEndNode"],"mappings":"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","sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport \"./Visualizer.css\";\nimport { Grid } from \"../Grid/Grid\";\nimport {\n  NavBar,\n  NavDropDownItem,\n  DropDownMenu,\n  DropDownAlgo,\n  DropDownSlider,\n  NavChangingButtonItem,\n} from \"../NavBar/NavBar\";\nimport { SecondaryHeader } from \"../SecondaryHeader/SecondaryHeader\";\nimport { node } from \"../helper_functions/usefulInterfaces\";\nimport {\n  dijkstra,\n  dijkstraWithWalls,\n} from \"../helper_functions/shortestPathAlgorithms/dijkstra\";\nimport {\n  createEmptyMazeGraph,\n  generateMazeGraph,\n} from \"../helper_functions/mazeGenerators/mazeGraph\";\nimport { constructGrid } from \"../helper_functions/constructGrid\";\n\nconst NUMBER_OF_ROWS: number = 28;\nconst NUMBER_OF_COLUMN: number = 13;\n\n// We define these constants out of the functional component\n// that the App uses to avoid re-running the functions to create\n// these each time there is a re-render\nconst [firstGrid, firstStartNode, firstEndNode] = constructGrid(\n  NUMBER_OF_ROWS,\n  NUMBER_OF_COLUMN,\n  [6, 3],\n  [6, 24]\n);\n\nconst [firstpairGrid, mazeGraph] = createEmptyMazeGraph(\n  NUMBER_OF_ROWS,\n  NUMBER_OF_COLUMN,\n  firstGrid\n);\n\n// Component rendering everything in the webpage.\nconst Visualizer: React.FC = () => {\n  // States managing the grid\n  const [grid, setGrid] = useState(firstGrid);\n  const [maze, setMaze] = useState(mazeGraph);\n  const [pairGrid, setPairGrid] = useState(firstpairGrid);\n  const [algorithm, setAlgorithm] = useState(\"dijkstraWithWalls\");\n  const [wallsDensity, setWallsDensity] = useState(0.7);\n  const [isVisualized, setIsVisualized] = useState(false);\n  // const [mouseIsPressed, setMouseIsPressed] = useState(false);\n\n  // States of the start and end node\n  const [startNode, setStartNode] = useState(firstStartNode);\n  const [endNode, setEndNode] = useState(firstEndNode);\n\n  // This function is there to visualize the algorithm chosen in the drop down menu\n  const visualizeAlgorithm: (visited: node[], path: node[]) => void = (\n    visited,\n    path\n  ) => {\n    const n = visited.length;\n    for (let i: number = 0; i < n; i++) {\n      setTimeout(() => {\n        const newGrid = grid.slice();\n        const node = visited[i];\n        // define the x and y of the current node\n        const x: number = node.x;\n        const y: number = node.y;\n        const newNode = {\n          ...node,\n          isVisited: true,\n          className: \"grid-node visited-node\",\n          waitClassChange: 0,\n        };\n        newGrid[x][y] = newNode;\n        setGrid(newGrid);\n      }, 30 * i);\n    }\n\n    const m = path.length;\n    for (let i: number = 0; i < m; i++) {\n      setTimeout(() => {\n        const newGrid = grid.slice();\n        const node = path[i];\n        // define the x and y of the current node\n        const x: number = node.x;\n        const y: number = node.y;\n        const newNode = {\n          ...node,\n          isShortestPath: true,\n          className: \"grid-node shortest-path-node\",\n          waitClassChange: 0,\n        };\n        newGrid[x][y] = newNode;\n        setGrid(newGrid);\n      }, 30 * n + 150 * i);\n    }\n  };\n\n  // This function is passed to the drop down menu to handle the change of algorithm\n  const handleAlgorithmChange: (algorithmName: string) => void = (\n    algorithmName\n  ) => {\n    setAlgorithm(algorithmName);\n  };\n\n  // This function changes the algorithm that will be run, at the moment only dijkstra is implemented\n  const chooseAlgorithm: (\n    algorithmName: string\n  ) => (\n    grid: node[][],\n    pairGrid: [number, number][][],\n    mazeGraph: Map<[number, number], [number, number][]>,\n    startNode: node,\n    endNode: node\n  ) => [node[], node[]] = (algorithmName) => {\n    if (algorithmName === \"dijkstraWithWalls\") {\n      return dijkstraWithWalls;\n    }\n    return dijkstraWithWalls;\n  };\n\n  // This function calls the generate maze function\n  const generateMaze: () => void = () => {\n    const newGrid = grid.slice();\n    const [newPairGrid, newMaze] = generateMazeGraph(\n      NUMBER_OF_ROWS,\n      NUMBER_OF_COLUMN,\n      newGrid,\n      wallsDensity\n    );\n    setGrid(newGrid);\n    setPairGrid(newPairGrid);\n    setMaze(newMaze);\n  };\n\n  // Reinitialize the the board\n  const reinitialize: () => void = () => {\n    const [newGrid, newStartNode, newEndNode] = constructGrid(\n      NUMBER_OF_ROWS,\n      NUMBER_OF_COLUMN,\n      [startNode.x, startNode.y],\n      [endNode.x, endNode.y]\n    );\n    const [newPairGrid, newMaze] = createEmptyMazeGraph(\n      NUMBER_OF_ROWS,\n      NUMBER_OF_COLUMN,\n      newGrid\n    );\n    setGrid(newGrid);\n    setPairGrid(newPairGrid);\n    setMaze(newMaze);\n    setStartNode(newStartNode);\n    setEndNode(newEndNode);\n    setIsVisualized(false);\n  };\n\n  // The following block of functions handles the making of walls in the grid\n  // This feature is currently not used as it is not a good fit with the current direction of the app\n\n  // const toggleWall: (x: number, y: number) => void = (x, y) => {\n  //   const newGrid: node[][] = grid.slice();\n  //   let newNode;\n  //   if (!newGrid[x][y].isWall) {\n  //     newNode = {\n  //       ...newGrid[x][y],\n  //       isWall: !newGrid[x][y].isWall,\n  //       className: \"grid-node wall-node\",\n  //     };\n  //   } else {\n  //     newNode = {\n  //       ...newGrid[x][y],\n  //       isWall: !newGrid[x][y].isWall,\n  //       className: \"grid-node\",\n  //     };\n  //   }\n  //   newGrid[x][y] = newNode;\n  //   setGrid(newGrid);\n  // };\n\n  // // handles the case when the mouse button is down\n  // const handleMouseDown: (x: number, y: number) => void = (x, y) => {\n  //   toggleWall(x, y);\n  //   setMouseIsPressed(false);\n  // };\n\n  // // handles the case whan the mouse button is down and you enter a node\n  // const handleMouseEnter: (x: number, y: number) => void = (x, y) => {\n  //   if (mouseIsPressed) {\n  //     toggleWall(x, y);\n  //   }\n  // };\n\n  // // handles the case when you mouse up\n  // const handleMouseUp: () => void = () => {\n  //   setMouseIsPressed(false);\n  // };\n\n  // Render the app\n  return (\n    <div className=\"App\">\n      <NavBar>\n        <NavChangingButtonItem\n          isVisualized={isVisualized}\n          className=\"reinitialize\"\n          visualizedClassName=\"highlight\"\n          handleClick={reinitialize}\n        >\n          Reinitialize\n        </NavChangingButtonItem>\n        <NavChangingButtonItem\n          isVisualized={isVisualized}\n          className=\"generate-maze\"\n          visualizedClassName=\"greyed-out\"\n          handleClick={generateMaze}\n        >\n          Generate maze\n        </NavChangingButtonItem>\n        <NavDropDownItem\n          tabIndex={1}\n          icon=\"\"\n          text=\"Maze options\"\n          id=\"maze-options\"\n          isVisualized={isVisualized}\n          shouldGreyOut={true}\n        >\n          <DropDownMenu left={false}>\n            <DropDownSlider\n              isVisualized={isVisualized}\n              minValue={0.1}\n              maxValue={1}\n              defaultValue={wallsDensity}\n              text=\"Density of walls\"\n              handleChangeWallsDensity={setWallsDensity}\n            ></DropDownSlider>\n          </DropDownMenu>\n        </NavDropDownItem>\n        <NavChangingButtonItem\n          isVisualized={isVisualized}\n          className=\"visualize-button\"\n          visualizedClassName=\"greyed-out\"\n          handleClick={() => {\n            if (!isVisualized) {\n              visualizeAlgorithm(\n                ...chooseAlgorithm(algorithm)(\n                  grid,\n                  pairGrid,\n                  maze,\n                  startNode,\n                  endNode\n                )\n              );\n              setIsVisualized(true);\n            }\n          }}\n        >\n          Visualize!\n        </NavChangingButtonItem>\n        <NavDropDownItem\n          tabIndex={2}\n          icon=\"&#12851;\"\n          text=\"Algorithm\"\n          id=\"algorithms\"\n          isVisualized={isVisualized}\n          shouldGreyOut={false}\n        >\n          <DropDownMenu left={true}>\n            <DropDownAlgo\n              changeAlgorithm={handleAlgorithmChange}\n              algorithmName=\"dijkstraWithWalls\"\n            >\n              <p>Dijkstra's Algorithm</p>\n              {algorithm === \"dijkstraWithWalls\" ? <p>✓</p> : \"\"}\n            </DropDownAlgo>\n            {/* <DropDownAlgo\n              changeAlgorithm={handleAlgorithmChange}\n              algorithmName=\"A*\"\n            >\n              A* Algorithm\n            </DropDownAlgo> */}\n          </DropDownMenu>\n        </NavDropDownItem>\n      </NavBar>\n      {/* <SecondaryHeader>\n        <button\n          className=\"visualize-button\"\n          onClick={(e) => {\n            visualizeAlgorithm(\n              ...chooseAlgorithm(algorithm)(\n                grid,\n                pairGrid,\n                mazeGraph,\n                startNode,\n                endNode\n              )\n            );\n          }}\n        >\n          Visualize the path!\n        </button>\n      </SecondaryHeader> */}\n      <Grid grid={grid} pairGrid={pairGrid} maze={maze} />\n    </div>\n  );\n};\n\nexport default Visualizer;\n"]},"metadata":{},"sourceType":"module"}