{"ast":null,"code":"import _slicedToArray from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";// This function (Not a React Component!) is made to initialize the grid rendered in the App component.\nexport var constructGrid=function constructGrid(numberOfRow,numberOfColumn,startNode,endNode,numberOfTargets){var result=[];for(var i=0;i<numberOfColumn;i++){var currentRow=[];for(var j=0;j<numberOfRow;j++){var currentNode={id:i+j*numberOfColumn,x:i,y:j,isStart:false,hasCheese:false,hasRat:false,isVisited:false,isShortestPath:false,successorPosition:\"\"};currentRow.push(currentNode);}result.push(currentRow);}result[startNode[0]][startNode[1]].isStart=true;result[startNode[0]][startNode[1]].hasRat=true;result[endNode[0]][endNode[1]].hasCheese=true;var targetList=[result[endNode[0]][endNode[1]]];if(numberOfTargets>=1){var _piecesOfCheese=piecesOfCheese(result,startNode,endNode,numberOfTargets);var _piecesOfCheese2=_slicedToArray(_piecesOfCheese,2);result=_piecesOfCheese2[0];targetList=_piecesOfCheese2[1];}return[result,result[startNode[0]][startNode[1]],targetList];};export var reconstructGrid=function reconstructGrid(numberOfRow,numberOfColumn,startNode,targetList){var result=[];var _loop=function _loop(i){var currentRow=[];var _loop2=function _loop2(j){var currentNode={id:i+j*numberOfColumn,x:i,y:j,isStart:false,hasCheese:targetList.find(function(targetNode){return targetNode.x===i&&targetNode.y===j;})?true:false,hasRat:false,isVisited:false,isShortestPath:false,successorPosition:\"\"};currentRow.push(currentNode);};for(var j=0;j<numberOfRow;j++){_loop2(j);}result.push(currentRow);};for(var i=0;i<numberOfColumn;i++){_loop(i);}result[startNode[0]][startNode[1]].isStart=true;result[startNode[0]][startNode[1]].hasRat=true;var newTargetList=targetList.map(function(targetNode){return result[targetNode.x][targetNode.y];});return[result,result[startNode[0]][startNode[1]],newTargetList];};var piecesOfCheese=function piecesOfCheese(grid,startNode,endNode,cheeseNum){var n=grid.length,m=grid[0].length;var targetList=[grid[endNode[0]][endNode[1]]];var visited=new Array(n);for(var i=0;i<n;++i){visited[i]=new Array(m);}for(var _i=0;_i<n;++_i){for(var j=0;j<m;++j){visited[_i][j]=false;}}visited[startNode[0]][startNode[1]]=true;visited[endNode[0]][endNode[1]]=true;for(var k=0;k<cheeseNum;k++){var _i2=-1,_j=-1;do{_i2=Math.floor(Math.random()*n);_j=Math.floor(Math.random()*m);}while(visited[_i2][_j]);visited[_i2][_j]=true;grid[_i2][_j].hasCheese=true;targetList.push(grid[_i2][_j]);}return[grid,targetList];};export var addPiecesOfCheese=function addPiecesOfCheese(numberOfRows,numberOfColumn,startNode,oldTargetList,cheeseToAdd){var _loop3=function _loop3(){var randIndex=Math.floor(Math.random()*oldTargetList.length);oldTargetList=oldTargetList.filter(function(targetNode,index){return index!==randIndex;});cheeseToAdd++;};// let targetList: node[] = [];\nwhile(cheeseToAdd<0){_loop3();}var _reconstructGrid=reconstructGrid(numberOfRows,numberOfColumn,[startNode.x,startNode.y],oldTargetList),_reconstructGrid2=_slicedToArray(_reconstructGrid,3),newGrid=_reconstructGrid2[0],newStartNode=_reconstructGrid2[1],targetList=_reconstructGrid2[2];var visited=new Array(numberOfColumn);for(var i=0;i<numberOfColumn;++i){visited[i]=new Array(numberOfRows);}for(var _i3=0;_i3<numberOfColumn;++_i3){for(var j=0;j<numberOfRows;++j){visited[_i3][j]=false;}}visited[startNode.x][startNode.y]=true;targetList.forEach(function(targetNode){visited[targetNode.x][targetNode.y]=true;});for(var k=0;k<cheeseToAdd;k++){var _i4=-1,_j2=-1;do{_i4=Math.floor(Math.random()*numberOfColumn);_j2=Math.floor(Math.random()*numberOfRows);}while(visited[_i4][_j2]);visited[_i4][_j2]=true;newGrid[_i4][_j2].hasCheese=true;targetList.push(newGrid[_i4][_j2]);}return[newGrid,newStartNode,targetList];};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helperFunctions/constructGrid.ts"],"names":["constructGrid","numberOfRow","numberOfColumn","startNode","endNode","numberOfTargets","result","i","currentRow","j","currentNode","id","x","y","isStart","hasCheese","hasRat","isVisited","isShortestPath","successorPosition","push","targetList","piecesOfCheese","reconstructGrid","find","targetNode","newTargetList","map","grid","cheeseNum","n","length","m","visited","Array","k","Math","floor","random","addPiecesOfCheese","numberOfRows","oldTargetList","cheeseToAdd","randIndex","filter","index","newGrid","newStartNode","forEach"],"mappings":"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","sourcesContent":["import { node } from \"./usefulInterfaces\";\n\n// This function (Not a React Component!) is made to initialize the grid rendered in the App component.\nexport const constructGrid: (\n  numberOfRows: number,\n  numberOfColumn: number,\n  startNode: [number, number],\n  endNode: [number, number],\n  numberOfTargets: number\n) => [node[][], node, node[]] = (\n  numberOfRow,\n  numberOfColumn,\n  startNode,\n  endNode,\n  numberOfTargets\n) => {\n  let result: node[][] = [];\n  for (let i: number = 0; i < numberOfColumn; i++) {\n    let currentRow: node[] = [];\n    for (let j: number = 0; j < numberOfRow; j++) {\n      let currentNode: node = {\n        id: i + j * numberOfColumn,\n        x: i,\n        y: j,\n        isStart: false,\n        hasCheese: false,\n        hasRat: false,\n        isVisited: false,\n        isShortestPath: false,\n        successorPosition: \"\",\n      };\n      currentRow.push(currentNode);\n    }\n    result.push(currentRow);\n  }\n  result[startNode[0]][startNode[1]].isStart = true;\n  result[startNode[0]][startNode[1]].hasRat = true;\n  result[endNode[0]][endNode[1]].hasCheese = true;\n  let targetList: node[] = [result[endNode[0]][endNode[1]]];\n  if (numberOfTargets >= 1)\n    [result, targetList] = piecesOfCheese(\n      result,\n      startNode,\n      endNode,\n      numberOfTargets\n    );\n  return [result, result[startNode[0]][startNode[1]], targetList];\n};\n\nexport const reconstructGrid: (\n  numberOfRows: number,\n  numberOfColumn: number,\n  startNode: [number, number],\n  targetList: node[]\n) => [node[][], node, node[]] = (\n  numberOfRow,\n  numberOfColumn,\n  startNode,\n  targetList\n) => {\n  let result: node[][] = [];\n  for (let i: number = 0; i < numberOfColumn; i++) {\n    let currentRow: node[] = [];\n    for (let j: number = 0; j < numberOfRow; j++) {\n      let currentNode: node = {\n        id: i + j * numberOfColumn,\n        x: i,\n        y: j,\n        isStart: false,\n        hasCheese: targetList.find(\n          (targetNode) => targetNode.x === i && targetNode.y === j\n        )\n          ? true\n          : false,\n        hasRat: false,\n        isVisited: false,\n        isShortestPath: false,\n        successorPosition: \"\",\n      };\n      currentRow.push(currentNode);\n    }\n    result.push(currentRow);\n  }\n  result[startNode[0]][startNode[1]].isStart = true;\n  result[startNode[0]][startNode[1]].hasRat = true;\n  let newTargetList: node[] = targetList.map(\n    (targetNode) => result[targetNode.x][targetNode.y]\n  );\n  return [result, result[startNode[0]][startNode[1]], newTargetList];\n};\n\nconst piecesOfCheese: (\n  grid: node[][],\n  startNode: [number, number],\n  endNode: [number, number],\n  cheeseNum: number\n) => [node[][], node[]] = (grid, startNode, endNode, cheeseNum) => {\n  const n: number = grid.length,\n    m: number = grid[0].length;\n  const targetList: node[] = [grid[endNode[0]][endNode[1]]];\n  let visited: boolean[][] = new Array(n);\n  for (let i: number = 0; i < n; ++i) {\n    visited[i] = new Array(m);\n  }\n  for (let i: number = 0; i < n; ++i) {\n    for (let j: number = 0; j < m; ++j) {\n      visited[i][j] = false;\n    }\n  }\n\n  visited[startNode[0]][startNode[1]] = true;\n  visited[endNode[0]][endNode[1]] = true;\n  for (let k: number = 0; k < cheeseNum; k++) {\n    let i = -1,\n      j = -1;\n    do {\n      i = Math.floor(Math.random() * n);\n      j = Math.floor(Math.random() * m);\n    } while (visited[i][j]);\n    visited[i][j] = true;\n    grid[i][j].hasCheese = true;\n    targetList.push(grid[i][j]);\n  }\n  return [grid, targetList];\n};\n\nexport const addPiecesOfCheese: (\n  numberOfRows: number,\n  numberOfColumn: number,\n  startNode: node,\n  oldTargetList: node[],\n  cheeseToAdd: number\n) => [node[][], node, node[]] = (\n  numberOfRows,\n  numberOfColumn,\n  startNode,\n  oldTargetList,\n  cheeseToAdd\n) => {\n  // let targetList: node[] = [];\n  while (cheeseToAdd < 0) {\n    let randIndex: number = Math.floor(Math.random() * oldTargetList.length);\n    oldTargetList = oldTargetList.filter(\n      (targetNode, index) => index !== randIndex\n    );\n    cheeseToAdd++;\n  }\n\n  const [newGrid, newStartNode, targetList] = reconstructGrid(\n    numberOfRows,\n    numberOfColumn,\n    [startNode.x, startNode.y],\n    oldTargetList\n  );\n\n  let visited: boolean[][] = new Array(numberOfColumn);\n  for (let i: number = 0; i < numberOfColumn; ++i) {\n    visited[i] = new Array(numberOfRows);\n  }\n  for (let i: number = 0; i < numberOfColumn; ++i) {\n    for (let j: number = 0; j < numberOfRows; ++j) {\n      visited[i][j] = false;\n    }\n  }\n\n  visited[startNode.x][startNode.y] = true;\n  targetList.forEach((targetNode) => {\n    visited[targetNode.x][targetNode.y] = true;\n  });\n  for (let k: number = 0; k < cheeseToAdd; k++) {\n    let i = -1,\n      j = -1;\n    do {\n      i = Math.floor(Math.random() * numberOfColumn);\n      j = Math.floor(Math.random() * numberOfRows);\n    } while (visited[i][j]);\n    visited[i][j] = true;\n    newGrid[i][j].hasCheese = true;\n    targetList.push(newGrid[i][j]);\n  }\n  return [newGrid, newStartNode, targetList];\n};\n"]},"metadata":{},"sourceType":"module"}