{"ast":null,"code":"import { BinaryHeap } from \"../../dataStructures/binaryHeap\";\nimport { retrievePath } from \"../retrievePath\";\nimport { ensure } from \"../../ensureNotUndefined\";\nexport const dijkstraHelper = (grid, pairGrid, mazeGraph, startNode, oldTargetList) => {\n  const m = grid.length,\n        n = grid[0].length;\n  const targetList = oldTargetList.slice(); // Initialize the distances array\n\n  const distances = [];\n\n  for (let i = 0; i < m; i++) {\n    distances.push([]);\n\n    for (let j = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER - 1);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0; // Initialize the predecessor array\n\n  const predecessor = [];\n\n  for (let i = 0; i < m * n; i++) {\n    predecessor.push(startNode);\n  }\n\n  predecessor[startNode.id] = startNode; // Initialize the visited nodes array\n\n  let visited = []; //   Initialize the Binary Heap\n\n  let pq = new BinaryHeap((a, b) => {\n    if (distances[a[0].x][a[0].y] !== distances[b[0].x][b[0].y]) {\n      return distances[a[0].x][a[0].y] < distances[b[0].x][b[0].y];\n    }\n\n    return a[1] < b[1];\n  });\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode = ensure(pq.pop()); // add the current node to the visited nodes\n\n    visited.push(currentNode); // If we found the endNode, return the shortest path to it\n\n    if (targetList.find(targetNode => targetNode === currentNode)) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, currentNode);\n      return [visited, shortestPath, currentNode];\n    } // Get the coordinates of the nodes\n\n\n    let currentX = currentNode.x;\n    let currentY = currentNode.y; // Iterate the neighbors of the node\n\n    for (const neighbor of ensure(mazeGraph.get(pairGrid[currentX][currentY]))) {\n      // Get the coordinates of the neighbor node\n      let neighborX = neighbor[0][0],\n          neighborY = neighbor[0][1]; // Check if the coordinates are valid\n\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n) continue;\n      let nextNode = grid[neighborX][neighborY]; // Calculate the distance between the current node and the next node\n      // To Do: take into account the weight of the path\n\n      let currentDistance = distances[currentX][currentY] + neighbor[1]; // If the distance is less than the distance in the array distances,\n      // change it and change the predecessor of the next node to be the current one\n\n      if (currentDistance < distances[neighborX][neighborY]) {\n        predecessor[nextNode.id] = currentNode;\n        distances[neighborX][neighborY] = currentDistance;\n      } // If the node is not yet visited, remove it from the heap and\n      // put it back in with its new distance as the score function\n\n\n      if (!visited.find(visitedNode => visitedNode === nextNode)) {\n        pq.remove(nextNode);\n        pq.push(nextNode);\n      }\n    }\n  }\n\n  return [visited, [], startNode];\n};\nexport const getDistanceMatrix = (grid, pairGrid, mazeGraph, startNode, targetList) => {\n  targetList.unshift(startNode);\n  const result = new Array(targetList.length);\n\n  for (let i = 0; i < targetList.length; i++) {\n    for (let j = 0; j < targetList.length; j++) {\n      const [visited, path] = dijkstra(grid, pairGrid, mazeGraph, targetList[i], targetList.filter(targetNode => targetNode !== targetList[i]));\n      if (i !== j) result[i].push();else result[i].push(0);\n    }\n  }\n\n  return [[]];\n};\nexport const dijkstra = (grid, pairGrid, mazeGraph, startNode, targetList) => {\n  const [visited, path] = dijkstraHelper(grid, pairGrid, mazeGraph, startNode, targetList);\n  return [visited, path];\n};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helperFunctions/shortestPathAlgorithms/singleTarget/dijkstra.ts"],"names":["BinaryHeap","retrievePath","ensure","dijkstraHelper","grid","pairGrid","mazeGraph","startNode","oldTargetList","m","length","n","targetList","slice","distances","i","push","j","Number","MAX_SAFE_INTEGER","x","y","predecessor","id","visited","pq","a","b","size","currentNode","pop","find","targetNode","shortestPath","currentX","currentY","neighbor","get","neighborX","neighborY","nextNode","currentDistance","visitedNode","remove","getDistanceMatrix","unshift","result","Array","path","dijkstra","filter"],"mappings":"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","sourcesContent":["import { node } from \"../../usefulInterfaces\";\nimport { BinaryHeap } from \"../../dataStructures/binaryHeap\";\nimport { retrievePath } from \"../retrievePath\";\nimport { ensure } from \"../../ensureNotUndefined\";\n\nexport const dijkstraHelper: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [node[], node[], node] = (\n  grid,\n  pairGrid,\n  mazeGraph,\n  startNode,\n  oldTargetList\n) => {\n  const m = grid.length,\n    n = grid[0].length;\n  const targetList: node[] = oldTargetList.slice();\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER - 1);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    predecessor.push(startNode);\n  }\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>(\n    (a: [node, number], b: [node, number]) => {\n      if (distances[a[0].x][a[0].y] !== distances[b[0].x][b[0].y]) {\n        return distances[a[0].x][a[0].y] < distances[b[0].x][b[0].y];\n      }\n      return a[1] < b[1];\n    }\n  );\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    visited.push(currentNode);\n\n    // If we found the endNode, return the shortest path to it\n    if (targetList.find((targetNode) => targetNode === currentNode)) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, currentNode);\n      return [visited, shortestPath, currentNode];\n    }\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentX][currentY])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0][0],\n        neighborY: number = neighbor[0][1];\n\n      // Check if the coordinates are valid\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n)\n        continue;\n\n      let nextNode: node = grid[neighborX][neighborY];\n\n      // Calculate the distance between the current node and the next node\n      // To Do: take into account the weight of the path\n      let currentDistance: number = distances[currentX][currentY] + neighbor[1];\n\n      // If the distance is less than the distance in the array distances,\n      // change it and change the predecessor of the next node to be the current one\n      if (currentDistance < distances[neighborX][neighborY]) {\n        predecessor[nextNode.id] = currentNode;\n        distances[neighborX][neighborY] = currentDistance;\n      }\n\n      // If the node is not yet visited, remove it from the heap and\n      // put it back in with its new distance as the score function\n      if (!visited.find((visitedNode) => visitedNode === nextNode)) {\n        pq.remove(nextNode);\n        pq.push(nextNode);\n      }\n    }\n  }\n  return [visited, [], startNode];\n};\n\nexport const getDistanceMatrix: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => number[][] = (grid, pairGrid, mazeGraph, startNode, targetList) => {\n  targetList.unshift(startNode);\n  const result: number[][] = new Array(targetList.length);\n  for (let i: number = 0; i < targetList.length; i++) {\n    for (let j: number = 0; j < targetList.length; j++) {\n      const [visited, path] = dijkstra(\n        grid,\n        pairGrid,\n        mazeGraph,\n        targetList[i],\n        targetList.filter((targetNode: node) => targetNode !== targetList[i])\n      );\n      if (i !== j) result[i].push();\n      else result[i].push(0);\n    }\n  }\n\n  return [[]];\n};\n\nexport const dijkstra: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, targetList) => {\n  const [visited, path] = dijkstraHelper(\n    grid,\n    pairGrid,\n    mazeGraph,\n    startNode,\n    targetList\n  );\n  return [visited, path];\n};\n"]},"metadata":{},"sourceType":"module"}