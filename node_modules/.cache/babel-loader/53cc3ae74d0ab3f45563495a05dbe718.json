{"ast":null,"code":"import _createForOfIteratorHelper from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import{retrieveDistance,retrievePath}from\"../retrievePath\";import{ensure}from\"../../ensureNotUndefined\";export var bfs=function bfs(grid,pairGrid,mazeGraph,startNode,targetList){var m=grid.length,n=grid[0].length;// Initialize the predecessor array\nvar predecessor=[];for(var i=0;i<m*n;i++){predecessor.push(startNode);}predecessor[startNode.id]=startNode;// Initialize the visited nodes array\nvar visited=[];// Initialize the discovered array\nvar discovered=[startNode];// Initialize the Queue TODO: IMPLEMENT A BETTER VERSION OF THE QUEUE WITH O(1) OPERATIONS\nvar q=[startNode];// While the queue is not empty\nvar _loop=function _loop(){// Get the element in front of the queue\nvar currentNode=ensure(q.shift());if(visited.find(function(visitedNode){return visitedNode===currentNode;}))return\"continue\";// Put the currentNode node in the visited set\nvisited.push(currentNode);// If we found the end node, return the path to it\nif(targetList.find(function(targetNode){return currentNode===targetNode;})){// Retrieve the shortest path\nvar shortestPath=retrievePath(predecessor,startNode,currentNode);return{v:[[visited,shortestPath],retrieveDistance(shortestPath,pairGrid,mazeGraph)]};}// iterate through the neighbors of the currentNode node\nvar _iterator=_createForOfIteratorHelper(ensure(mazeGraph.get(pairGrid[currentNode.x][currentNode.y]))),_step;try{var _loop2=function _loop2(){var neighbor=_step.value;// Get the coordinates of the neighbor node\nvar neighborX=neighbor[0][0],neighborY=neighbor[0][1];if(neighborX<0||neighborX>=m||neighborY<0||neighborY>=n||discovered.find(function(discoveredNode){return discoveredNode===grid[neighborX][neighborY];}))return\"continue\";// Get the node in the grid\nvar nextNode=grid[neighborX][neighborY];// update the predecessor array\npredecessor[nextNode.id]=currentNode;// Add the node to the visited nodes\ndiscovered.push(nextNode);// Push the next node to the queue\nq.push(nextNode);};for(_iterator.s();!(_step=_iterator.n()).done;){var _ret2=_loop2();if(_ret2===\"continue\")continue;}}catch(err){_iterator.e(err);}finally{_iterator.f();}};while(q.length>0){var _ret=_loop();if(_ret===\"continue\")continue;if(typeof _ret===\"object\")return _ret.v;}return[[visited,[]],0];};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helperFunctions/shortestPathAlgorithms/singleTarget/bfs.ts"],"names":["retrieveDistance","retrievePath","ensure","bfs","grid","pairGrid","mazeGraph","startNode","targetList","m","length","n","predecessor","i","push","id","visited","discovered","q","currentNode","shift","find","visitedNode","targetNode","shortestPath","get","x","y","neighbor","neighborX","neighborY","discoveredNode","nextNode"],"mappings":"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","sourcesContent":["import { node } from \"../../usefulInterfaces\";\nimport { retrieveDistance, retrievePath } from \"../retrievePath\";\nimport { ensure } from \"../../ensureNotUndefined\";\n\nexport const bfs: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [[node[], node[]], number] = (\n  grid,\n  pairGrid,\n  mazeGraph,\n  startNode,\n  targetList\n) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    predecessor.push(startNode);\n  }\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  // Initialize the discovered array\n  let discovered: node[] = [startNode];\n\n  // Initialize the Queue TODO: IMPLEMENT A BETTER VERSION OF THE QUEUE WITH O(1) OPERATIONS\n  let q: node[] = [startNode];\n\n  // While the queue is not empty\n  while (q.length > 0) {\n    // Get the element in front of the queue\n    let currentNode: node = ensure(q.shift());\n\n    if (visited.find((visitedNode) => visitedNode === currentNode)) continue;\n\n    // Put the currentNode node in the visited set\n    visited.push(currentNode);\n\n    // If we found the end node, return the path to it\n    if (targetList.find((targetNode) => currentNode === targetNode)) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, currentNode);\n      return [\n        [visited, shortestPath],\n        retrieveDistance(shortestPath, pairGrid, mazeGraph),\n      ];\n    }\n\n    // iterate through the neighbors of the currentNode node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentNode.x][currentNode.y])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0][0],\n        neighborY: number = neighbor[0][1];\n\n      if (\n        neighborX < 0 ||\n        neighborX >= m ||\n        neighborY < 0 ||\n        neighborY >= n ||\n        discovered.find(\n          (discoveredNode) => discoveredNode === grid[neighborX][neighborY]\n        )\n      )\n        continue;\n\n      // Get the node in the grid\n      let nextNode: node = grid[neighborX][neighborY];\n\n      // update the predecessor array\n      predecessor[nextNode.id] = currentNode;\n\n      // Add the node to the visited nodes\n      discovered.push(nextNode);\n\n      // Push the next node to the queue\n      q.push(nextNode);\n    }\n  }\n\n  return [[visited, []], 0];\n};\n"]},"metadata":{},"sourceType":"module"}