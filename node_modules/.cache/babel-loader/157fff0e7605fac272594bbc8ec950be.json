{"ast":null,"code":"import { BinaryHeap } from \"../binaryHeap\";\nexport const dijkstra = (grid, startNode, endNode) => {\n  const m = grid.length,\n        n = grid[0].length; // Initialize the distances array\n\n  const distances = [];\n\n  for (let i = 0; i < m; i++) {\n    distances.push([]);\n\n    for (let j = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0; // Initialize the predecessor array\n\n  const predecessor = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode; // Initialize the visited nodes array\n\n  let visited = []; // Initialize the directions array we will use to perform Dijkstra's algorithm\n\n  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]; //   Initialize the Binary Heap\n\n  let pq = new BinaryHeap(n => distances[n.x][n.y]);\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode = ensure(pq.pop()); // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n\n    visited.push(currentNode); // Get the coordinates of the nodes\n\n    let currentX = currentNode.x;\n    let currentY = currentNode.y; // Iterate the neighbors of the node\n\n    for (const dir of directions) {\n      // Get the coordinates of the next node\n      let nextX = currentX + dir[0];\n      let nextY = currentY + dir[1]; // Check if the coordinates are valid\n\n      if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n) {\n        let nextNode = grid[nextX][nextY]; // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n\n        if (!visited.find(currentNode => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          pq.push(nextNode);\n        } // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n\n\n        let currentDistance = distances[currentX][currentY] + 1; // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n\n        if (currentDistance < distances[nextX][nextY]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[nextX][nextY] = currentDistance;\n        } // If we found the target node then we return what we need\n\n\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrieveShortestPath(predecessor, startNode, endNode);\n          visited.shift(); // return the correct value\n\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n};\nexport const dijkstraWithWalls = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n        n = grid[0].length; // Initialize the distances array\n\n  const distances = [];\n\n  for (let i = 0; i < m; i++) {\n    distances.push([]);\n\n    for (let j = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0; // Initialize the predecessor array\n\n  const predecessor = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode; // Initialize the visited nodes array\n\n  let visited = []; //   Initialize the Binary Heap\n\n  let pq = new BinaryHeap(n => distances[n.x][n.y]);\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode = ensure(pq.pop()); // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n\n    visited.push(currentNode); // Get the coordinates of the nodes\n\n    let currentX = currentNode.x;\n    let currentY = currentNode.y; // Iterate the neighbors of the node\n\n    for (const neighbor of ensure(mazeGraph.get(pairGrid[currentX][currentY]))) {\n      // Check if the coordinates are valid\n      if (neighbor[0] >= 0 && neighbor[0] < m && neighbor[1] >= 0 && neighbor[1] < n) {\n        let nextNode = grid[neighbor[0]][neighbor[1]]; // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n\n        if (!visited.find(currentNode => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          pq.push(nextNode);\n        } // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n\n\n        let currentDistance = distances[currentX][currentY] + 1; // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n\n        if (currentDistance < distances[neighbor[0]][neighbor[1]]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[neighbor[0]][neighbor[1]] = currentDistance;\n        } // If we found the target node then we return what we need\n\n\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrieveShortestPath(predecessor, startNode, endNode);\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n}; // This function retrieves the shortest path from the predecessor array from Dijkstra's algorithm\n\nconst retrieveShortestPath = (predecessor, startNode, endNode) => {\n  let shortestPath = [];\n  let current = endNode;\n\n  while (current !== startNode) {\n    current = predecessor[current.id];\n    shortestPath.unshift(current);\n  }\n\n  shortestPath.shift();\n  return shortestPath;\n}; // This function is here to ensure that a value is not undefined (especially when using arrays).\n\n\nfunction ensure(argument, message = \"This value was promised to be there.\") {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helper_functions/shortestPathAlgorithms/dijkstra.ts"],"names":["BinaryHeap","dijkstra","grid","startNode","endNode","m","length","n","distances","i","push","j","Number","MAX_SAFE_INTEGER","x","y","predecessor","fill","id","visited","directions","pq","size","currentNode","ensure","pop","currentX","currentY","dir","nextX","nextY","nextNode","find","remove","currentDistance","shortestPath","retrieveShortestPath","shift","dijkstraWithWalls","pairGrid","mazeGraph","neighbor","get","current","unshift","argument","message","undefined","TypeError"],"mappings":"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","sourcesContent":["import { node } from \"../usefulInterfaces\";\nimport { BinaryHeap } from \"../binaryHeap\";\n\nexport const dijkstra: (\n  grid: node[][],\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  // Initialize the directions array we will use to perform Dijkstra's algorithm\n  const directions: number[][] = [\n    [0, 1],\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n  ];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>(\n    (n: node) => distances[n.x][n.y]\n  );\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n    visited.push(currentNode);\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const dir of directions) {\n      // Get the coordinates of the next node\n      let nextX: number = currentX + dir[0];\n      let nextY: number = currentY + dir[1];\n\n      // Check if the coordinates are valid\n      if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n) {\n        let nextNode: node = grid[nextX][nextY];\n\n        // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n        if (!visited.find((currentNode) => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          pq.push(nextNode);\n        }\n\n        // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n        let currentDistance: number = distances[currentX][currentY] + 1;\n\n        // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n        if (currentDistance < distances[nextX][nextY]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[nextX][nextY] = currentDistance;\n        }\n\n        // If we found the target node then we return what we need\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrieveShortestPath(\n            predecessor,\n            startNode,\n            endNode\n          );\n          visited.shift();\n          // return the correct value\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n};\n\nexport const dijkstraWithWalls: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [number, number][]>,\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>(\n    (n: node) => distances[n.x][n.y]\n  );\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n    visited.push(currentNode);\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentX][currentY])\n    )) {\n      // Check if the coordinates are valid\n      if (\n        neighbor[0] >= 0 &&\n        neighbor[0] < m &&\n        neighbor[1] >= 0 &&\n        neighbor[1] < n\n      ) {\n        let nextNode: node = grid[neighbor[0]][neighbor[1]];\n\n        // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n        if (!visited.find((currentNode) => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          pq.push(nextNode);\n        }\n\n        // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n        let currentDistance: number = distances[currentX][currentY] + 1;\n\n        // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n        if (currentDistance < distances[neighbor[0]][neighbor[1]]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[neighbor[0]][neighbor[1]] = currentDistance;\n        }\n\n        // If we found the target node then we return what we need\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrieveShortestPath(\n            predecessor,\n            startNode,\n            endNode\n          );\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n};\n\n// This function retrieves the shortest path from the predecessor array from Dijkstra's algorithm\nconst retrieveShortestPath: (\n  predecessor: node[],\n  startNode: node,\n  endNode: node\n) => node[] = (predecessor, startNode, endNode) => {\n  let shortestPath = [];\n  let current = endNode;\n  while (current !== startNode) {\n    current = predecessor[current.id];\n    shortestPath.unshift(current);\n  }\n  shortestPath.shift();\n\n  return shortestPath;\n};\n\n// This function is here to ensure that a value is not undefined (especially when using arrays).\nfunction ensure<T>(\n  argument: T | undefined | null,\n  message: string = \"This value was promised to be there.\"\n): T {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}\n"]},"metadata":{},"sourceType":"module"}