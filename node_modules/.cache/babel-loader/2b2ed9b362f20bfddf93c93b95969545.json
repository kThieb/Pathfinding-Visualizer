{"ast":null,"code":"import { getDistanceMatrix } from \"../singleTarget/dijkstra\";\nexport const bruteForceTSP = (grid, pairGrid, mazeGraph, startNode, targetList) => {\n  const newTargetList = targetList;\n  newTargetList.unshift(startNode);\n  const distancesMatrix = getDistanceMatrix(grid, pairGrid, mazeGraph, newTargetList);\n  let path = [[startNode, 0]];\n  let optimalPath = []; // let maxCost: number = greedy(\n  //   grid,\n  //   pairGrid,\n  //   mazeGraph,\n  //   startNode,\n  //   targetList\n  // )[1];\n\n  let maxCost = Number.MAX_VALUE;\n  const maxLength = targetList.length;\n  const bnbtargets = targetList.map((targetNode, i) => [targetNode, i]);\n\n  const branchAndBound = (candidatePath, remainingTargets, currentCost) => {\n    console.log(candidatePath);\n\n    if (candidatePath.length === maxLength) {\n      if (currentCost > maxCost) return;\n      maxCost = currentCost;\n      optimalPath = candidatePath;\n      return;\n    }\n\n    const newRemainingTargets = remainingTargets.slice();\n    remainingTargets.forEach(targetNodeAndIndex => {\n      let prevId = candidatePath[candidatePath.length - 1][1];\n      candidatePath.push(targetNodeAndIndex);\n      branchAndBound(candidatePath.slice(), newRemainingTargets.filter(tgAndId => tgAndId[1] !== targetNodeAndIndex[1]), currentCost + distancesMatrix[prevId][targetNodeAndIndex[1]]);\n      candidatePath.pop();\n    });\n  };\n\n  branchAndBound(path, bnbtargets, 0);\n  console.log(optimalPath);\n  return optimalPath;\n};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helperFunctions/shortestPathAlgorithms/multipleTarget/bruteForce.ts"],"names":["getDistanceMatrix","bruteForceTSP","grid","pairGrid","mazeGraph","startNode","targetList","newTargetList","unshift","distancesMatrix","path","optimalPath","maxCost","Number","MAX_VALUE","maxLength","length","bnbtargets","map","targetNode","i","branchAndBound","candidatePath","remainingTargets","currentCost","console","log","newRemainingTargets","slice","forEach","targetNodeAndIndex","prevId","push","filter","tgAndId","pop"],"mappings":"AACA,SAASA,iBAAT,QAAkC,0BAAlC;AAGA,OAAO,MAAMC,aAMQ,GAAG,CAACC,IAAD,EAAOC,QAAP,EAAiBC,SAAjB,EAA4BC,SAA5B,EAAuCC,UAAvC,KAAsD;AAC5E,QAAMC,aAAqB,GAAGD,UAA9B;AACAC,EAAAA,aAAa,CAACC,OAAd,CAAsBH,SAAtB;AACA,QAAMI,eAA2B,GAAGT,iBAAiB,CACnDE,IADmD,EAEnDC,QAFmD,EAGnDC,SAHmD,EAInDG,aAJmD,CAArD;AAMA,MAAIG,IAAsB,GAAG,CAAC,CAACL,SAAD,EAAY,CAAZ,CAAD,CAA7B;AACA,MAAIM,WAA6B,GAAG,EAApC,CAV4E,CAY5E;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAIC,OAAe,GAAGC,MAAM,CAACC,SAA7B;AACA,QAAMC,SAAiB,GAAGT,UAAU,CAACU,MAArC;AACA,QAAMC,UAA4B,GAAGX,UAAU,CAACY,GAAX,CAAe,CAACC,UAAD,EAAaC,CAAb,KAAmB,CACrED,UADqE,EAErEC,CAFqE,CAAlC,CAArC;;AAKA,QAAMC,cAIG,GAAG,CAACC,aAAD,EAAgBC,gBAAhB,EAAkCC,WAAlC,KAAkD;AAC5DC,IAAAA,OAAO,CAACC,GAAR,CAAYJ,aAAZ;;AACA,QAAIA,aAAa,CAACN,MAAd,KAAyBD,SAA7B,EAAwC;AACtC,UAAIS,WAAW,GAAGZ,OAAlB,EAA2B;AAC3BA,MAAAA,OAAO,GAAGY,WAAV;AACAb,MAAAA,WAAW,GAAGW,aAAd;AACA;AACD;;AACD,UAAMK,mBAAqC,GAAGJ,gBAAgB,CAACK,KAAjB,EAA9C;AACAL,IAAAA,gBAAgB,CAACM,OAAjB,CAA0BC,kBAAD,IAAwB;AAC/C,UAAIC,MAAc,GAAGT,aAAa,CAACA,aAAa,CAACN,MAAd,GAAuB,CAAxB,CAAb,CAAwC,CAAxC,CAArB;AACAM,MAAAA,aAAa,CAACU,IAAd,CAAmBF,kBAAnB;AACAT,MAAAA,cAAc,CACZC,aAAa,CAACM,KAAd,EADY,EAEZD,mBAAmB,CAACM,MAApB,CACGC,OAAD,IAAaA,OAAO,CAAC,CAAD,CAAP,KAAeJ,kBAAkB,CAAC,CAAD,CADhD,CAFY,EAKZN,WAAW,GAAGf,eAAe,CAACsB,MAAD,CAAf,CAAwBD,kBAAkB,CAAC,CAAD,CAA1C,CALF,CAAd;AAOAR,MAAAA,aAAa,CAACa,GAAd;AACD,KAXD;AAYD,GAzBD;;AA0BAd,EAAAA,cAAc,CAACX,IAAD,EAAOO,UAAP,EAAmB,CAAnB,CAAd;AACAQ,EAAAA,OAAO,CAACC,GAAR,CAAYf,WAAZ;AACA,SAAOA,WAAP;AACD,CA7DM","sourcesContent":["import { node } from \"../../usefulInterfaces\";\nimport { getDistanceMatrix } from \"../singleTarget/dijkstra\";\nimport { greedy } from \"./greedy\";\n\nexport const bruteForceTSP: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [node, number][] = (grid, pairGrid, mazeGraph, startNode, targetList) => {\n  const newTargetList: node[] = targetList;\n  newTargetList.unshift(startNode);\n  const distancesMatrix: number[][] = getDistanceMatrix(\n    grid,\n    pairGrid,\n    mazeGraph,\n    newTargetList\n  );\n  let path: [node, number][] = [[startNode, 0]];\n  let optimalPath: [node, number][] = [];\n\n  // let maxCost: number = greedy(\n  //   grid,\n  //   pairGrid,\n  //   mazeGraph,\n  //   startNode,\n  //   targetList\n  // )[1];\n  let maxCost: number = Number.MAX_VALUE;\n  const maxLength: number = targetList.length;\n  const bnbtargets: [node, number][] = targetList.map((targetNode, i) => [\n    targetNode,\n    i,\n  ]);\n\n  const branchAndBound: (\n    candidatePath: [node, number][],\n    remainingTargets: [node, number][],\n    currentCost: number\n  ) => void = (candidatePath, remainingTargets, currentCost) => {\n    console.log(candidatePath);\n    if (candidatePath.length === maxLength) {\n      if (currentCost > maxCost) return;\n      maxCost = currentCost;\n      optimalPath = candidatePath;\n      return;\n    }\n    const newRemainingTargets: [node, number][] = remainingTargets.slice();\n    remainingTargets.forEach((targetNodeAndIndex) => {\n      let prevId: number = candidatePath[candidatePath.length - 1][1];\n      candidatePath.push(targetNodeAndIndex);\n      branchAndBound(\n        candidatePath.slice(),\n        newRemainingTargets.filter(\n          (tgAndId) => tgAndId[1] !== targetNodeAndIndex[1]\n        ),\n        currentCost + distancesMatrix[prevId][targetNodeAndIndex[1]]\n      );\n      candidatePath.pop();\n    });\n  };\n  branchAndBound(path, bnbtargets, 0);\n  console.log(optimalPath);\n  return optimalPath;\n};\n"]},"metadata":{},"sourceType":"module"}