{"ast":null,"code":"import _createForOfIteratorHelper from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import{retrieveTwoEndedPath}from\"../retrievePath\";import{ensure}from\"../../ensureNotUndefined\";export var twoEndedBfs=function twoEndedBfs(grid,pairGrid,mazeGraph,startNode,targetList){var m=grid.length,n=grid[0].length;// Initialize the predecessor array\nvar predecessor=[];for(var i=0;i<m*n;i++){predecessor.push(startNode);}predecessor[startNode.id]=startNode;var successor=[];for(var _i=0;_i<m*n;_i++){successor.push(targetList[0]);}successor[targetList[0].id]=targetList[0];var source=[];for(var _i2=0;_i2<m*n;_i2++){source.push(targetList[0]);}source[startNode.id]=startNode;source[targetList[0].id]=targetList[0];// Initialize the visited nodes array\nvar visited=[];// Initialize the discovered array\nvar discovered=[startNode,targetList[0]];// Initialize the Queue TODO: IMPLEMENT A BETTER VERSION OF THE QUEUE WITH O(1) OPERATIONS\nvar q=[startNode,targetList[0]];// While the queue is not empty\nvar _loop=function _loop(){// Get the element in front of the queue\nvar currentNode=ensure(q.shift());if(visited.find(function(visitedNode){return visitedNode===currentNode;}))return\"continue\";// Put the currentNode node in the visited set\nvisited.push(currentNode);// iterate through the neighbors of the currentNode node\nvar _iterator=_createForOfIteratorHelper(ensure(mazeGraph.get(pairGrid[currentNode.x][currentNode.y]))),_step;try{var _loop2=function _loop2(){var neighbor=_step.value;// Get the coordinates of the neighbor node\nvar neighborX=neighbor[0][0],neighborY=neighbor[0][1];if(neighborX<0||neighborX>=m||neighborY<0||neighborY>=n)return\"continue\";// Get the node in the grid\nvar nextNode=grid[neighborX][neighborY];// Store the result of the find function for later\nvar foundNode=visited.find(function(visitedNode){return visitedNode===nextNode;});// If we found the end node, return the path to it\nif(foundNode&&source[currentNode.id]!==source[foundNode.id]){if(source[currentNode.id]===startNode)predecessor[nextNode.id]=currentNode;else successor[nextNode.id]=currentNode;// Retrieve the shortest path\nvar shortestPath=retrieveTwoEndedPath(predecessor,successor,nextNode,startNode,targetList[0]);return{v:{v:[visited,shortestPath]}};}if(discovered.find(function(discoveredNode){return discoveredNode===grid[neighborX][neighborY];}))return\"continue\";source[nextNode.id]=source[currentNode.id];if(source[currentNode.id]===startNode){// update the predecessor array\npredecessor[nextNode.id]=currentNode;}else{successor[nextNode.id]=currentNode;}// Add the node to the visited nodes\ndiscovered.push(nextNode);// Push the next node to the queue\nq.push(nextNode);};for(_iterator.s();!(_step=_iterator.n()).done;){var _ret2=_loop2();if(_ret2===\"continue\")continue;if(typeof _ret2===\"object\")return _ret2.v;}}catch(err){_iterator.e(err);}finally{_iterator.f();}};while(q.length>0){var _ret=_loop();if(_ret===\"continue\")continue;if(typeof _ret===\"object\")return _ret.v;}return[visited,[]];};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helperFunctions/shortestPathAlgorithms/singleTarget/twoEndedBfs.ts"],"names":["retrieveTwoEndedPath","ensure","twoEndedBfs","grid","pairGrid","mazeGraph","startNode","targetList","m","length","n","predecessor","i","push","id","successor","source","visited","discovered","q","currentNode","shift","find","visitedNode","get","x","y","neighbor","neighborX","neighborY","nextNode","foundNode","shortestPath","discoveredNode"],"mappings":"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","sourcesContent":["import { node } from \"../../usefulInterfaces\";\nimport { retrieveTwoEndedPath } from \"../retrievePath\";\nimport { ensure } from \"../../ensureNotUndefined\";\n\nexport const twoEndedBfs: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, targetList) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    predecessor.push(startNode);\n  }\n  predecessor[startNode.id] = startNode;\n\n  const successor: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    successor.push(targetList[0]);\n  }\n  successor[targetList[0].id] = targetList[0];\n\n  const source: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    source.push(targetList[0]);\n  }\n  source[startNode.id] = startNode;\n  source[targetList[0].id] = targetList[0];\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  // Initialize the discovered array\n  let discovered: node[] = [startNode, targetList[0]];\n\n  // Initialize the Queue TODO: IMPLEMENT A BETTER VERSION OF THE QUEUE WITH O(1) OPERATIONS\n  let q: node[] = [startNode, targetList[0]];\n\n  // While the queue is not empty\n  while (q.length > 0) {\n    // Get the element in front of the queue\n    let currentNode: node = ensure(q.shift());\n\n    if (visited.find((visitedNode) => visitedNode === currentNode)) continue;\n\n    // Put the currentNode node in the visited set\n    visited.push(currentNode);\n\n    // iterate through the neighbors of the currentNode node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentNode.x][currentNode.y])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0][0],\n        neighborY: number = neighbor[0][1];\n\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n)\n        continue;\n\n      // Get the node in the grid\n      let nextNode: node = grid[neighborX][neighborY];\n\n      // Store the result of the find function for later\n      const foundNode: node | undefined = visited.find(\n        (visitedNode) => visitedNode === nextNode\n      );\n\n      // If we found the end node, return the path to it\n      if (foundNode && source[currentNode.id] !== source[foundNode.id]) {\n        if (source[currentNode.id] === startNode)\n          predecessor[nextNode.id] = currentNode;\n        else successor[nextNode.id] = currentNode;\n        // Retrieve the shortest path\n        const shortestPath = retrieveTwoEndedPath(\n          predecessor,\n          successor,\n          nextNode,\n          startNode,\n          targetList[0]\n        );\n        return [visited, shortestPath];\n      }\n\n      if (\n        discovered.find(\n          (discoveredNode) => discoveredNode === grid[neighborX][neighborY]\n        )\n      )\n        continue;\n\n      source[nextNode.id] = source[currentNode.id];\n\n      if (source[currentNode.id] === startNode) {\n        // update the predecessor array\n        predecessor[nextNode.id] = currentNode;\n      } else {\n        successor[nextNode.id] = currentNode;\n      }\n\n      // Add the node to the visited nodes\n      discovered.push(nextNode);\n\n      // Push the next node to the queue\n      q.push(nextNode);\n    }\n  }\n\n  return [visited, []];\n};\n"]},"metadata":{},"sourceType":"module"}