{"ast":null,"code":"// This function (Not a React Component!) is made to initialize the grid rendered in the App component.\nexport const constructGrid = (numberOfRow, numberOfColumn, startNode, endNode) => {\n  let result = [];\n\n  for (let i = 0; i < numberOfColumn; i++) {\n    let currentRow = [];\n\n    for (let j = 0; j < numberOfRow; j++) {\n      let currentNode = {\n        id: i + j * numberOfColumn,\n        x: i,\n        y: j,\n        isStart: false,\n        isEnd: false,\n        isVisited: false,\n        isShortestPath: false,\n        waitClassChange: 0,\n        className: \"grid-node\",\n        hasCheese: false\n      };\n      currentRow.push(currentNode);\n    }\n\n    result.push(currentRow);\n  }\n\n  result[startNode[0]][startNode[1]] = { ...result[startNode[0]][startNode[1]],\n    isStart: true,\n    className: \"grid-node start-node\"\n  };\n  result[endNode[0]][endNode[1]] = { ...result[endNode[0]][endNode[1]],\n    isEnd: true,\n    className: \"grid-node end-node\"\n  }; // result = piecesOfCheese(result, numberOfColumn, numberOfRow, 21);\n\n  return [result, result[startNode[0]][startNode[1]], result[endNode[0]][endNode[1]]];\n};\n\nconst piecesOfCheese = (grid, m, n, cheeseNum) => {\n  let visited = new Array(n);\n\n  for (let i = 0; i < n; ++i) {\n    visited[i] = new Array(n);\n  }\n\n  for (let i = 0; i < n; ++i) {\n    for (let j = 0; j < n; ++j) {\n      visited[i][j] = false;\n    }\n  }\n\n  visited[0][0] = true;\n  visited[n - 1][n - 1] = true;\n\n  for (let k = 0; k < cheeseNum / 2; k++) {\n    let i = -1,\n        j = -1;\n\n    do {\n      i = Math.floor(Math.random() * n);\n      j = Math.floor(Math.random() * n);\n    } while (visited[i][j]);\n\n    visited[i][j] = true;\n    visited[n - 1 - i][n - 1 - j] = true;\n    grid[i][j].hasCheese = true;\n    grid[n - 1 - i][n - 1 - j].hasCheese = true;\n  }\n\n  grid[Math.floor(n / 2)][Math.floor(n / 2)].hasCheese = true;\n  return grid;\n};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helper_functions/constructGrid.ts"],"names":["constructGrid","numberOfRow","numberOfColumn","startNode","endNode","result","i","currentRow","j","currentNode","id","x","y","isStart","isEnd","isVisited","isShortestPath","waitClassChange","className","hasCheese","push","piecesOfCheese","grid","m","n","cheeseNum","visited","Array","k","Math","floor","random"],"mappings":"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","sourcesContent":["import { node } from \"./usefulInterfaces\";\n\n// This function (Not a React Component!) is made to initialize the grid rendered in the App component.\nexport const constructGrid: (\n  numberOfRows: number,\n  numberOfColumn: number,\n  startNode: [number, number],\n  endNode: [number, number]\n) => [node[][], node, node] = (\n  numberOfRow,\n  numberOfColumn,\n  startNode,\n  endNode\n) => {\n  let result: node[][] = [];\n  for (let i: number = 0; i < numberOfColumn; i++) {\n    let currentRow: node[] = [];\n    for (let j: number = 0; j < numberOfRow; j++) {\n      let currentNode = {\n        id: i + j * numberOfColumn,\n        x: i,\n        y: j,\n        isStart: false,\n        isEnd: false,\n        isVisited: false,\n        isShortestPath: false,\n        waitClassChange: 0,\n        className: \"grid-node\",\n        hasCheese: false,\n      };\n      currentRow.push(currentNode);\n    }\n    result.push(currentRow);\n  }\n  result[startNode[0]][startNode[1]] = {\n    ...result[startNode[0]][startNode[1]],\n    isStart: true,\n    className: \"grid-node start-node\",\n  };\n  result[endNode[0]][endNode[1]] = {\n    ...result[endNode[0]][endNode[1]],\n    isEnd: true,\n    className: \"grid-node end-node\",\n  };\n  // result = piecesOfCheese(result, numberOfColumn, numberOfRow, 21);\n  return [\n    result,\n    result[startNode[0]][startNode[1]],\n    result[endNode[0]][endNode[1]],\n  ];\n};\n\nconst piecesOfCheese: (\n  grid: node[][],\n  m: number,\n  n: number,\n  cheeseNum: number\n) => node[][] = (grid, m, n, cheeseNum) => {\n  let visited: boolean[][] = new Array(n);\n  for (let i: number = 0; i < n; ++i) {\n    visited[i] = new Array(n);\n  }\n  for (let i: number = 0; i < n; ++i) {\n    for (let j: number = 0; j < n; ++j) {\n      visited[i][j] = false;\n    }\n  }\n\n  visited[0][0] = true;\n  visited[n - 1][n - 1] = true;\n  for (let k: number = 0; k < cheeseNum / 2; k++) {\n    let i = -1,\n      j = -1;\n    do {\n      i = Math.floor(Math.random() * n);\n      j = Math.floor(Math.random() * n);\n    } while (visited[i][j]);\n    visited[i][j] = true;\n    visited[n - 1 - i][n - 1 - j] = true;\n    grid[i][j].hasCheese = true;\n    grid[n - 1 - i][n - 1 - j].hasCheese = true;\n  }\n  grid[Math.floor(n / 2)][Math.floor(n / 2)].hasCheese = true;\n  return grid;\n};\n"]},"metadata":{},"sourceType":"module"}