{"ast":null,"code":"import _slicedToArray from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{ensure}from\"../ensureNotUndefined\";var MUD_WEIGHT=5;var createMazeGraph=function createMazeGraph(rowLength,columnLength,grid){var pairGrid=[];for(var i=0;i<columnLength;i++){var pairRow=[];for(var j=0;j<rowLength;j++){var _currentNode=grid[i][j];pairRow.push([_currentNode.x,_currentNode.y]);}pairGrid.push(pairRow);}// Create the maze graph\nvar mazeGraph=new Map();for(var _i=0;_i<columnLength;_i++){for(var _j=0;_j<rowLength;_j++){mazeGraph.set(pairGrid[_i][_j],[]);}}return[pairGrid,mazeGraph];};export var createEmptyMazeGraph=function createEmptyMazeGraph(rowLength,columnLength,grid){var pairGrid=[];for(var i=0;i<columnLength;i++){var pairRow=[];for(var j=0;j<rowLength;j++){var _currentNode2=grid[i][j];pairRow.push([_currentNode2.x,_currentNode2.y]);}pairGrid.push(pairRow);}// Create the maze graph\nvar mazeGraph=new Map();for(var _i2=0;_i2<columnLength;_i2++){for(var _j2=0;_j2<rowLength;_j2++){var neighbors=getNeighborsEmpty(pairGrid,[_i2,_j2],columnLength,rowLength);mazeGraph.set(pairGrid[_i2][_j2],neighbors);}}return[pairGrid,mazeGraph];};export var generateMazeGraph=function generateMazeGraph(rowLength,columnLength,grid,wallsDensity,mudDensity){var _createMazeGraph=createMazeGraph(rowLength,columnLength,grid),_createMazeGraph2=_slicedToArray(_createMazeGraph,2),pairGrid=_createMazeGraph2[0],mazeGraph=_createMazeGraph2[1];var currentWallsCount=2*(rowLength-1)*(columnLength-1)+rowLength+columnLength-2,maxWallsOrMud=currentWallsCount;// I. Generate a maze where each cells is reachable (with a DFS)\n// 1. Choose the initial cell, mark it as visited and push it to the stack\nvar startNode=pairGrid[0][0];var stack=[startNode];var visited=[startNode];// 2. While the stack is not empty\nwhile(stack.length>0){// 1. Pop a cell from the stack and make it a current cell\nvar _currentNode3=ensure(stack.pop());var currentNonVisitedNeighbors=getNeighbors(pairGrid,_currentNode3,rowLength,columnLength,visited);// 2. If the current cell has any neighbours which have not been visited\nif(currentNonVisitedNeighbors.length>0){// 1. Push the current cell to the stack\nstack.push(_currentNode3);// 2. Choose one of the unvisited neighbours\nvar randIndex=Math.floor(Math.random()*currentNonVisitedNeighbors.length);var neighborNode=currentNonVisitedNeighbors[randIndex];// 3. Remove the wall between the current cell and the chosen cell\nvar currentNodeNeighbors=ensure(mazeGraph.get(_currentNode3));currentNodeNeighbors.push([neighborNode,1]);var neighborNodeNeighbors=ensure(mazeGraph.get(neighborNode));neighborNodeNeighbors.push([_currentNode3,1]);// 4. Mark the ch// mazeGraph.set(neighborNode, neighborNodeNeighbors);osen cell as visited and push it to the stack\nvisited.push(neighborNode);stack.push(neighborNode);// 5. Remove 1 from the currentWallsCount\ncurrentWallsCount--;}}// II. Remove walls until the desired density is achieved\nvar maxWallsCount=currentWallsCount;while(currentWallsCount*(1/maxWallsCount)>wallsDensity){// 1. Choose a node randomly\nvar randRow=Math.floor(Math.random()*rowLength);var randCol=Math.floor(Math.random()*columnLength);var _currentNode4=pairGrid[randCol][randRow];// 2. Get the cells with a wall with the current cell\nvar neighbors=getWalledOffNeighbors(pairGrid,_currentNode4,rowLength,columnLength,mazeGraph);if(neighbors.length>0){// 3. Choose one of the cells with a wall\nvar _randIndex=Math.floor(Math.random()*neighbors.length);var _neighborNode=pairGrid[neighbors[_randIndex][0]][neighbors[_randIndex][1]];// 4. Remove the wall between the 2 cells\nvar _currentNodeNeighbors=ensure(mazeGraph.get(_currentNode4));_currentNodeNeighbors.push([_neighborNode,1]);var _neighborNodeNeighbors=ensure(mazeGraph.get(_neighborNode));_neighborNodeNeighbors.push([_currentNode4,1]);currentWallsCount--;}}// III. Add mud to the graph until we get the desired mud density\nvar currentMud=0,maxMud=maxWallsOrMud-currentWallsCount;var _loop=function _loop(){// 1. Choose a node randomly\nvar randRow=Math.floor(Math.random()*rowLength);var randCol=Math.floor(Math.random()*columnLength);var currentNode=pairGrid[randCol][randRow];// 2. Get the neighbors than have no mud\nvar neighbors=ensure(mazeGraph.get(currentNode)).filter(function(item){return item[1]===1;});if(neighbors.length>0){// 3. Get a random neighbor\nvar _randIndex2=Math.floor(Math.random()*neighbors.length);var _neighborNode2=pairGrid[neighbors[_randIndex2][0][0]][neighbors[_randIndex2][0][1]];neighbors[_randIndex2][1]=MUD_WEIGHT;var _neighborNodeNeighbors2=ensure(mazeGraph.get(_neighborNode2));var currentNodeAndDistance=ensure(_neighborNodeNeighbors2.find(function(item){return item[0]===currentNode;}));currentNodeAndDistance[1]=MUD_WEIGHT;currentMud++;}};while(currentMud*(1/maxMud)<mudDensity){_loop();}console.log(mazeGraph);return[pairGrid,mazeGraph];};var getNeighbors=function getNeighbors(pairGrid,currentNode,rowLength,columnLength,visited){var directions=[[1,0],[0,-1],[-1,0],[0,1]];var neighbors=[];var neighborX=-1;var neighborY=-1;for(var _i3=0,_directions=directions;_i3<_directions.length;_i3++){var dir=_directions[_i3];neighborX=currentNode[0]+dir[0];neighborY=currentNode[1]+dir[1];if(neighborX>=0&&neighborX<columnLength&&neighborY>=0&&neighborY<rowLength&&!visited.includes(pairGrid[neighborX][neighborY])){neighbors.push(pairGrid[neighborX][neighborY]);}}return neighbors;};export var getNeighborsEmpty=function getNeighborsEmpty(pairGrid,currentNode,columnLength,rowLength){var directions=[[1,0],[0,-1],[-1,0],[0,1]];var neighbors=[];var neighborX=-1;var neighborY=-1;for(var _i4=0,_directions2=directions;_i4<_directions2.length;_i4++){var dir=_directions2[_i4];neighborX=currentNode[0]+dir[0];neighborY=currentNode[1]+dir[1];if(neighborX>=0&&neighborX<columnLength&&neighborY>=0&&neighborY<rowLength){neighbors.push(pairGrid[neighborX][neighborY]);}}return neighbors;};// This function returns the neighbors which have a wall with the current node\nvar getWalledOffNeighbors=function getWalledOffNeighbors(pairGrid,currentNode,rowLength,columnLength,mazeGraph){var directions=[[1,0],[0,-1],[-1,0],[0,1]];var neighbors=[];var neighborX=-1;var neighborY=-1;var findCallback=function findCallback(neighbor){return neighbor[0]===pairGrid[neighborX][neighborY];};for(var _i5=0,_directions3=directions;_i5<_directions3.length;_i5++){var _mazeGraph$get;var dir=_directions3[_i5];neighborX=currentNode[0]+dir[0];neighborY=currentNode[1]+dir[1];if(neighborX>=0&&neighborX<columnLength&&neighborY>=0&&neighborY<rowLength&&// !mazeGraph.get(currentNode)?.includes(pairGrid[neighborX][neighborY])\n!((_mazeGraph$get=mazeGraph.get(currentNode))===null||_mazeGraph$get===void 0?void 0:_mazeGraph$get.find(findCallback))){neighbors.push(pairGrid[neighborX][neighborY]);}}return neighbors;};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helperFunctions/mazeGenerators/mazeGraph.ts"],"names":["ensure","MUD_WEIGHT","createMazeGraph","rowLength","columnLength","grid","pairGrid","i","pairRow","j","currentNode","push","x","y","mazeGraph","Map","set","createEmptyMazeGraph","neighbors","getNeighborsEmpty","generateMazeGraph","wallsDensity","mudDensity","currentWallsCount","maxWallsOrMud","startNode","stack","visited","length","pop","currentNonVisitedNeighbors","getNeighbors","randIndex","Math","floor","random","neighborNode","currentNodeNeighbors","get","neighborNodeNeighbors","maxWallsCount","randRow","randCol","getWalledOffNeighbors","currentMud","maxMud","filter","item","currentNodeAndDistance","find","console","log","directions","neighborX","neighborY","dir","includes","findCallback","neighbor"],"mappings":"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","sourcesContent":["import { constructGrid } from \"../constructGrid\";\nimport { ensure } from \"../ensureNotUndefined\";\nimport { node } from \"../usefulInterfaces\";\n\nconst MUD_WEIGHT = 5;\n\nconst createMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][]\n) => [\n  [number, number][][],\n  Map<[number, number], [[number, number], number][]>\n] = (rowLength, columnLength, grid) => {\n  let pairGrid: [number, number][][] = [];\n  for (let i: number = 0; i < columnLength; i++) {\n    let pairRow: [number, number][] = [];\n    for (let j: number = 0; j < rowLength; j++) {\n      let currentNode: node = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n    pairGrid.push(pairRow);\n  }\n\n  // Create the maze graph\n  let mazeGraph: Map<\n    [number, number],\n    [[number, number], number][]\n  > = new Map();\n  for (let i: number = 0; i < columnLength; i++) {\n    for (let j: number = 0; j < rowLength; j++) {\n      mazeGraph.set(pairGrid[i][j], []);\n    }\n  }\n\n  return [pairGrid, mazeGraph];\n};\n\nexport const createEmptyMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][]\n) => [[number, number][][], Map<[number, number], [number, number][]>] = (\n  rowLength,\n  columnLength,\n  grid\n) => {\n  let pairGrid: [number, number][][] = [];\n  for (let i: number = 0; i < columnLength; i++) {\n    let pairRow: [number, number][] = [];\n    for (let j: number = 0; j < rowLength; j++) {\n      let currentNode: node = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n    pairGrid.push(pairRow);\n  }\n  // Create the maze graph\n  let mazeGraph: Map<[number, number], [number, number][]> = new Map();\n  for (let i: number = 0; i < columnLength; i++) {\n    for (let j: number = 0; j < rowLength; j++) {\n      let neighbors: [number, number][] = getNeighborsEmpty(\n        pairGrid,\n        [i, j],\n        columnLength,\n        rowLength\n      );\n\n      mazeGraph.set(pairGrid[i][j], neighbors);\n    }\n  }\n  return [pairGrid, mazeGraph];\n};\n\nexport const generateMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][],\n  wallsDensity: number,\n  mudDendity: number\n) => [\n  [number, number][][],\n  Map<[number, number], [[number, number], number][]>\n] = (rowLength, columnLength, grid, wallsDensity, mudDensity) => {\n  let [pairGrid, mazeGraph]: [\n    [number, number][][],\n    Map<[number, number], [[number, number], number][]>\n  ] = createMazeGraph(rowLength, columnLength, grid);\n\n  let currentWallsCount: number =\n      2 * (rowLength - 1) * (columnLength - 1) + rowLength + columnLength - 2,\n    maxWallsOrMud = currentWallsCount;\n\n  // I. Generate a maze where each cells is reachable (with a DFS)\n\n  // 1. Choose the initial cell, mark it as visited and push it to the stack\n  let startNode: [number, number] = pairGrid[0][0];\n  let stack: [number, number][] = [startNode];\n  let visited: [number, number][] = [startNode];\n\n  // 2. While the stack is not empty\n  while (stack.length > 0) {\n    // 1. Pop a cell from the stack and make it a current cell\n    let currentNode: [number, number] = ensure(stack.pop());\n    let currentNonVisitedNeighbors: [number, number][] = getNeighbors(\n      pairGrid,\n      currentNode,\n      rowLength,\n      columnLength,\n      visited\n    );\n    // 2. If the current cell has any neighbours which have not been visited\n    if (currentNonVisitedNeighbors.length > 0) {\n      // 1. Push the current cell to the stack\n      stack.push(currentNode);\n\n      // 2. Choose one of the unvisited neighbours\n      let randIndex: number = Math.floor(\n        Math.random() * currentNonVisitedNeighbors.length\n      );\n      let neighborNode: [number, number] =\n        currentNonVisitedNeighbors[randIndex];\n\n      // 3. Remove the wall between the current cell and the chosen cell\n      let currentNodeNeighbors: [[number, number], number][] = ensure(\n        mazeGraph.get(currentNode)\n      );\n      currentNodeNeighbors.push([neighborNode, 1]);\n\n      let neighborNodeNeighbors: [[number, number], number][] = ensure(\n        mazeGraph.get(neighborNode)\n      );\n      neighborNodeNeighbors.push([currentNode, 1]);\n\n      // 4. Mark the ch// mazeGraph.set(neighborNode, neighborNodeNeighbors);osen cell as visited and push it to the stack\n      visited.push(neighborNode);\n      stack.push(neighborNode);\n\n      // 5. Remove 1 from the currentWallsCount\n      currentWallsCount--;\n    }\n  }\n\n  // II. Remove walls until the desired density is achieved\n  let maxWallsCount: number = currentWallsCount;\n  while (currentWallsCount * (1 / maxWallsCount) > wallsDensity) {\n    // 1. Choose a node randomly\n    let randRow: number = Math.floor(Math.random() * rowLength);\n    let randCol: number = Math.floor(Math.random() * columnLength);\n    let currentNode: [number, number] = pairGrid[randCol][randRow];\n\n    // 2. Get the cells with a wall with the current cell\n    let neighbors: [number, number][] = getWalledOffNeighbors(\n      pairGrid,\n      currentNode,\n      rowLength,\n      columnLength,\n      mazeGraph\n    );\n\n    if (neighbors.length > 0) {\n      // 3. Choose one of the cells with a wall\n      let randIndex: number = Math.floor(Math.random() * neighbors.length);\n      let neighborNode: [number, number] =\n        pairGrid[neighbors[randIndex][0]][neighbors[randIndex][1]];\n\n      // 4. Remove the wall between the 2 cells\n      let currentNodeNeighbors: [[number, number], number][] = ensure(\n        mazeGraph.get(currentNode)\n      );\n      currentNodeNeighbors.push([neighborNode, 1]);\n\n      let neighborNodeNeighbors: [[number, number], number][] = ensure(\n        mazeGraph.get(neighborNode)\n      );\n      neighborNodeNeighbors.push([currentNode, 1]);\n\n      currentWallsCount--;\n    }\n  }\n\n  // III. Add mud to the graph until we get the desired mud density\n  let currentMud: number = 0,\n    maxMud: number = maxWallsOrMud - currentWallsCount;\n  while (currentMud * (1 / maxMud) < mudDensity) {\n    // 1. Choose a node randomly\n    let randRow: number = Math.floor(Math.random() * rowLength);\n    let randCol: number = Math.floor(Math.random() * columnLength);\n    let currentNode: [number, number] = pairGrid[randCol][randRow];\n\n    // 2. Get the neighbors than have no mud\n    let neighbors: [[number, number], number][] = ensure(\n      mazeGraph.get(currentNode)\n    ).filter((item: [[number, number], number]) => item[1] === 1);\n\n    if (neighbors.length > 0) {\n      // 3. Get a random neighbor\n      let randIndex: number = Math.floor(Math.random() * neighbors.length);\n      let neighborNode: [number, number] =\n        pairGrid[neighbors[randIndex][0][0]][neighbors[randIndex][0][1]];\n\n      neighbors[randIndex][1] = MUD_WEIGHT;\n\n      let neighborNodeNeighbors: [[number, number], number][] = ensure(\n        mazeGraph.get(neighborNode)\n      );\n      let currentNodeAndDistance: [[number, number], number] = ensure(\n        neighborNodeNeighbors.find(\n          (item: [[number, number], number]) => item[0] === currentNode\n        )\n      );\n      currentNodeAndDistance[1] = MUD_WEIGHT;\n      currentMud++;\n    }\n  }\n\n  console.log(mazeGraph);\n\n  return [pairGrid, mazeGraph];\n};\n\nconst getNeighbors: (\n  grid: [number, number][][],\n  currentNode: [number, number],\n  rowLength: number,\n  columnLength: number,\n  visited: [number, number][]\n) => [number, number][] = (\n  pairGrid,\n  currentNode,\n  rowLength,\n  columnLength,\n  visited\n) => {\n  const directions = [\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n    [0, 1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength &&\n      !visited.includes(pairGrid[neighborX][neighborY])\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n\nexport const getNeighborsEmpty: (\n  pairGrid: [number, number][][],\n  currentNode: [number, number],\n  columnLength: number,\n  rowLength: number\n) => [number, number][] = (pairGrid, currentNode, columnLength, rowLength) => {\n  const directions = [\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n    [0, 1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n\n// This function returns the neighbors which have a wall with the current node\nconst getWalledOffNeighbors: (\n  pairGrid: [number, number][][],\n  currentNode: [number, number],\n  rowLength: number,\n  columnLength: number,\n  mazeGraph: Map<[number, number], [[number, number], number][]>\n) => [number, number][] = (\n  pairGrid,\n  currentNode,\n  rowLength,\n  columnLength,\n  mazeGraph\n) => {\n  const directions = [\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n    [0, 1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  const findCallback: (neighbor: [[number, number], number]) => boolean = (\n    neighbor\n  ) => {\n    return neighbor[0] === pairGrid[neighborX][neighborY];\n  };\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength &&\n      // !mazeGraph.get(currentNode)?.includes(pairGrid[neighborX][neighborY])\n      !mazeGraph.get(currentNode)?.find(findCallback)\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n"]},"metadata":{},"sourceType":"module"}