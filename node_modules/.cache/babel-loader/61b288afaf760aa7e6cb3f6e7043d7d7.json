{"ast":null,"code":"import { retrievePath } from \"./retrievePath\";\nimport { ensure } from \"../ensureNotUndefined\";\nexport const bfs = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n        n = grid[0].length; // Initialize the predecessor array\n\n  const predecessor = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode; // Initialize the visited nodes array\n\n  let visited = [startNode]; // Initialize the Queue TODO: IMPLEMENT A BETTER VERSION OF THE QUEUE WITH O(1) OPERATIONS\n\n  let q = [startNode]; // While the queue is not empty\n\n  while (q.length > 0) {\n    // Get the element in front of the queue\n    let currentNode = ensure(q.shift()); // Put the currentNode node in the visited set\n\n    visited.push(currentNode); // If we found the end node, return the path to it\n\n    if (currentNode === endNode) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, endNode);\n      return [visited, shortestPath];\n    } // iterate through the neighbors of the currentNode node\n\n\n    for (const neighbor of ensure(mazeGraph.get(pairGrid[currentNode.x][currentNode.y]))) {\n      // Get the coordinates of the neighbor node\n      let neighborX = neighbor[0],\n          neighborY = neighbor[1];\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n) continue; // Get the node in the grid\n\n      let nextNode = grid[neighborX][neighborY];\n      if (visited.fing(visitedNode => visitedNode === nextNode)) continue; // update the predecessor array\n\n      predecessor[nextNode.id] = currentNode; // Add the node to the visited nodes\n\n      visited.push(nextNode); // Push the next node to the queue\n\n      q.push(nextNode);\n    }\n  }\n\n  return [visited, []];\n};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helper_functions/shortestPathAlgorithms/bfs.ts"],"names":["retrievePath","ensure","bfs","grid","pairGrid","mazeGraph","startNode","endNode","m","length","n","predecessor","fill","id","visited","q","currentNode","shift","push","shortestPath","neighbor","get","x","y","neighborX","neighborY","nextNode","fing","visitedNode"],"mappings":"AACA,SAASA,YAAT,QAA6B,gBAA7B;AACA,SAASC,MAAT,QAAuB,uBAAvB;AAEA,OAAO,MAAMC,GAMQ,GAAG,CAACC,IAAD,EAAOC,QAAP,EAAiBC,SAAjB,EAA4BC,SAA5B,EAAuCC,OAAvC,KAAmD;AACzE,QAAMC,CAAC,GAAGL,IAAI,CAACM,MAAf;AAAA,QACEC,CAAC,GAAGP,IAAI,CAAC,CAAD,CAAJ,CAAQM,MADd,CADyE,CAIzE;;AACA,QAAME,WAAmB,GAAG,EAA5B;AACAA,EAAAA,WAAW,CAACC,IAAZ,CAAiBN,SAAjB,EAA4B,CAA5B,EAA+BE,CAAC,GAAGE,CAAnC;AACAC,EAAAA,WAAW,CAACL,SAAS,CAACO,EAAX,CAAX,GAA4BP,SAA5B,CAPyE,CASzE;;AACA,MAAIQ,OAAe,GAAG,CAACR,SAAD,CAAtB,CAVyE,CAYzE;;AACA,MAAIS,CAAS,GAAG,CAACT,SAAD,CAAhB,CAbyE,CAezE;;AACA,SAAOS,CAAC,CAACN,MAAF,GAAW,CAAlB,EAAqB;AACnB;AACA,QAAIO,WAAiB,GAAGf,MAAM,CAACc,CAAC,CAACE,KAAF,EAAD,CAA9B,CAFmB,CAInB;;AACAH,IAAAA,OAAO,CAACI,IAAR,CAAaF,WAAb,EALmB,CAOnB;;AACA,QAAIA,WAAW,KAAKT,OAApB,EAA6B;AAC3B;AACA,YAAMY,YAAY,GAAGnB,YAAY,CAACW,WAAD,EAAcL,SAAd,EAAyBC,OAAzB,CAAjC;AACA,aAAO,CAACO,OAAD,EAAUK,YAAV,CAAP;AACD,KAZkB,CAcnB;;;AACA,SAAK,MAAMC,QAAX,IAAuBnB,MAAM,CAC3BI,SAAS,CAACgB,GAAV,CAAcjB,QAAQ,CAACY,WAAW,CAACM,CAAb,CAAR,CAAwBN,WAAW,CAACO,CAApC,CAAd,CAD2B,CAA7B,EAEG;AACD;AACA,UAAIC,SAAiB,GAAGJ,QAAQ,CAAC,CAAD,CAAhC;AAAA,UACEK,SAAiB,GAAGL,QAAQ,CAAC,CAAD,CAD9B;AAGA,UAAII,SAAS,GAAG,CAAZ,IAAiBA,SAAS,IAAIhB,CAA9B,IAAmCiB,SAAS,GAAG,CAA/C,IAAoDA,SAAS,IAAIf,CAArE,EACE,SAND,CAQD;;AACA,UAAIgB,QAAc,GAAGvB,IAAI,CAACqB,SAAD,CAAJ,CAAgBC,SAAhB,CAArB;AAEA,UAAIX,OAAO,CAACa,IAAR,CAAcC,WAAD,IAAiBA,WAAW,KAAKF,QAA9C,CAAJ,EAA6D,SAX5D,CAaD;;AACAf,MAAAA,WAAW,CAACe,QAAQ,CAACb,EAAV,CAAX,GAA2BG,WAA3B,CAdC,CAgBD;;AACAF,MAAAA,OAAO,CAACI,IAAR,CAAaQ,QAAb,EAjBC,CAmBD;;AACAX,MAAAA,CAAC,CAACG,IAAF,CAAOQ,QAAP;AACD;AACF;;AAED,SAAO,CAACZ,OAAD,EAAU,EAAV,CAAP;AACD,CAhEM","sourcesContent":["import { node } from \"../usefulInterfaces\";\nimport { retrievePath } from \"./retrievePath\";\nimport { ensure } from \"../ensureNotUndefined\";\n\nexport const bfs: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [number, number][]>,\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [startNode];\n\n  // Initialize the Queue TODO: IMPLEMENT A BETTER VERSION OF THE QUEUE WITH O(1) OPERATIONS\n  let q: node[] = [startNode];\n\n  // While the queue is not empty\n  while (q.length > 0) {\n    // Get the element in front of the queue\n    let currentNode: node = ensure(q.shift());\n\n    // Put the currentNode node in the visited set\n    visited.push(currentNode);\n\n    // If we found the end node, return the path to it\n    if (currentNode === endNode) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, endNode);\n      return [visited, shortestPath];\n    }\n\n    // iterate through the neighbors of the currentNode node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentNode.x][currentNode.y])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0],\n        neighborY: number = neighbor[1];\n\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n)\n        continue;\n\n      // Get the node in the grid\n      let nextNode: node = grid[neighborX][neighborY];\n\n      if (visited.fing((visitedNode) => visitedNode === nextNode)) continue;\n\n      // update the predecessor array\n      predecessor[nextNode.id] = currentNode;\n\n      // Add the node to the visited nodes\n      visited.push(nextNode);\n\n      // Push the next node to the queue\n      q.push(nextNode);\n    }\n  }\n\n  return [visited, []];\n};\n"]},"metadata":{},"sourceType":"module"}