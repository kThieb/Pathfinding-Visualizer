{"ast":null,"code":"var _jsxFileName = \"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/Visualizer/Visualizer.tsx\";\nimport React, { useState } from \"react\";\nimport \"./Visualizer.css\";\nimport { Grid } from \"../Grid/Grid\";\nimport { NavBar, NavDropDownItem, DropDownMenu, DropDownAlgo, DropDownSlider, NavButton } from \"../NavBar/NavBar\";\nimport { algorithms } from \"../helper_functions/shortestPathAlgorithms/allAlgorithms\";\nimport { createEmptyMazeGraph, generateMazeGraph } from \"../helper_functions/mazeGenerators/mazeGraph\";\nimport { constructGrid } from \"../helper_functions/constructGrid\";\nconst NUMBER_OF_ROWS = 28;\nconst NUMBER_OF_COLUMN = 13;\nconst VISITED_ANIMATION_TIMEOUT = 35;\nconst PATH_ANIMATION_TIMEOUT = 75; // We define these constants out of the functional component\n// that the App uses to avoid re-running the functions to create\n// these each time there is a re-render\n\nconst [firstGrid, firstStartNode, firstEndNode] = constructGrid(NUMBER_OF_ROWS, NUMBER_OF_COLUMN, [6, 3], [6, 24]);\nconst [firstpairGrid, mazeGraph] = createEmptyMazeGraph(NUMBER_OF_ROWS, NUMBER_OF_COLUMN, firstGrid); // Component rendering everything in the webpage.\n\nconst Visualizer = () => {\n  // States managing the grid\n  const [grid, setGrid] = useState(firstGrid);\n  const [maze, setMaze] = useState(mazeGraph);\n  const [pairGrid, setPairGrid] = useState(firstpairGrid);\n  const [algorithm, setAlgorithm] = useState(\"dijkstraWithWalls\");\n  const [wallsDensity, setWallsDensity] = useState(0.7);\n  const [isVisualized, setIsVisualized] = useState(0); // const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  // States of the start and end node\n\n  const [startNode, setStartNode] = useState(firstStartNode);\n  const [endNode, setEndNode] = useState(firstEndNode); // This function is there to visualize the algorithm chosen in the drop down menu\n\n  const visualizeAlgorithm = (visited, path) => {\n    const n = visited.length;\n\n    for (let i = 0; i < n; i++) {\n      setTimeout(() => {\n        const newGrid = grid.slice();\n        const node = visited[i]; // define the x and y of the current node\n\n        const x = node.x;\n        const y = node.y;\n        const newNode = { ...node,\n          isVisited: true\n        };\n        newGrid[x][y] = newNode;\n        setGrid(newGrid);\n      }, VISITED_ANIMATION_TIMEOUT * i);\n    }\n\n    const m = path.length;\n\n    for (let i = 0; i < m; i++) {\n      setTimeout(() => {\n        const newGrid = grid.slice();\n        const node = path[i]; // define the x and y of the current node\n\n        const x = node.x;\n        const y = node.y;\n        const newNode = { ...node,\n          isVisited: false,\n          isShortestPath: true\n        };\n        newGrid[x][y] = newNode;\n        setGrid(newGrid);\n      }, VISITED_ANIMATION_TIMEOUT * n + PATH_ANIMATION_TIMEOUT * i);\n    }\n  }; // This function is passed to the drop down menu to handle the change of algorithm\n\n\n  const handleAlgorithmChange = algorithmName => {\n    setAlgorithm(algorithmName);\n  }; // This function changes the algorithm that will be run, at the moment only dijkstra is implemented\n\n\n  const chooseAlgorithm = () => {\n    return algorithms[algorithm];\n  };\n\n  const handleVisualization = () => {\n    if (isVisualized === 0) {\n      setIsVisualized(1);\n      const [visited, path] = chooseAlgorithm()(grid, pairGrid, maze, startNode, endNode);\n      const n = visited.length,\n            m = path.length;\n      visualizeAlgorithm(visited, path);\n      setTimeout(() => {\n        setIsVisualized(2);\n      }, VISITED_ANIMATION_TIMEOUT * n + PATH_ANIMATION_TIMEOUT * m);\n    }\n  }; // This function calls the generate maze function\n\n\n  const generateMaze = () => {\n    if (isVisualized === 0) {\n      const newGrid = grid.slice();\n      const [newPairGrid, newMaze] = generateMazeGraph(NUMBER_OF_ROWS, NUMBER_OF_COLUMN, newGrid, wallsDensity);\n      setGrid(newGrid);\n      setPairGrid(newPairGrid);\n      setMaze(newMaze);\n    }\n  }; // Reinitialize the the board\n\n\n  const reinitialize = () => {\n    const [newGrid, newStartNode, newEndNode] = constructGrid(NUMBER_OF_ROWS, NUMBER_OF_COLUMN, [startNode.x, startNode.y], [endNode.x, endNode.y]);\n    const [newPairGrid, newMaze] = createEmptyMazeGraph(NUMBER_OF_ROWS, NUMBER_OF_COLUMN, newGrid);\n    setGrid(newGrid);\n    setPairGrid(newPairGrid);\n    setMaze(newMaze);\n    setStartNode(newStartNode);\n    setEndNode(newEndNode);\n    setIsVisualized(0);\n  }; // The following block of functions handles the making of walls in the grid\n  // This feature is currently not used as it is not a good fit with the current direction of the app\n  // const toggleWall: (x: number, y: number) => void = (x, y) => {\n  //   const newGrid: node[][] = grid.slice();\n  //   let newNode;\n  //   if (!newGrid[x][y].isWall) {\n  //     newNode = {\n  //       ...newGrid[x][y],\n  //       isWall: !newGrid[x][y].isWall,\n  //       className: \"grid-node wall-node\",\n  //     };\n  //   } else {\n  //     newNode = {\n  //       ...newGrid[x][y],\n  //       isWall: !newGrid[x][y].isWall,\n  //       className: \"grid-node\",\n  //     };\n  //   }\n  //   newGrid[x][y] = newNode;\n  //   setGrid(newGrid);\n  // };\n  // // handles the case when the mouse button is down\n  // const handleMouseDown: (x: number, y: number) => void = (x, y) => {\n  //   toggleWall(x, y);\n  //   setMouseIsPressed(false);\n  // };\n  // // handles the case whan the mouse button is down and you enter a node\n  // const handleMouseEnter: (x: number, y: number) => void = (x, y) => {\n  //   if (mouseIsPressed) {\n  //     toggleWall(x, y);\n  //   }\n  // };\n  // // handles the case when you mouse up\n  // const handleMouseUp: () => void = () => {\n  //   setMouseIsPressed(false);\n  // };\n  // Render the app\n\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"App\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 214,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(NavBar, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 215,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(NavButton, {\n    text: \"Reinitialize\",\n    isVisualized: isVisualized,\n    className: \"reinitialize\",\n    visualizingClassName: \"greyed-out\",\n    visualizedClassName: \"highlight\",\n    handleClick: reinitialize,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 216,\n      columnNumber: 9\n    }\n  }), /*#__PURE__*/React.createElement(NavButton, {\n    text: \"Generate Maze\",\n    isVisualized: isVisualized,\n    className: \"generate-maze\",\n    visualizingClassName: \"greyed-out\",\n    visualizedClassName: \"greyed-out\",\n    handleClick: generateMaze,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 224,\n      columnNumber: 9\n    }\n  }), /*#__PURE__*/React.createElement(NavDropDownItem, {\n    text: \"Maze options\",\n    id: \"maze-options\",\n    isVisualized: isVisualized,\n    shouldGreyOut: true,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 232,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(DropDownMenu, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 238,\n      columnNumber: 11\n    }\n  }, /*#__PURE__*/React.createElement(DropDownSlider, {\n    text: \"Density of walls\",\n    minValue: 0.1,\n    maxValue: 1,\n    defaultValue: wallsDensity,\n    handleChange: setWallsDensity,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 239,\n      columnNumber: 13\n    }\n  }))), /*#__PURE__*/React.createElement(NavButton, {\n    text: \"Visualize!\",\n    isVisualized: isVisualized,\n    className: \"visualize-button\",\n    visualizingClassName: \"greyed-out\",\n    visualizedClassName: \"greyed-out\",\n    handleClick: handleVisualization,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 248,\n      columnNumber: 9\n    }\n  }), /*#__PURE__*/React.createElement(NavDropDownItem, {\n    text: \"Algorithm\",\n    id: \"algorithms\",\n    isVisualized: isVisualized,\n    shouldGreyOut: false,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 256,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(DropDownMenu, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 262,\n      columnNumber: 11\n    }\n  }, /*#__PURE__*/React.createElement(DropDownAlgo, {\n    changeAlgorithm: handleAlgorithmChange,\n    algorithmName: \"dijkstraWithWalls\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 263,\n      columnNumber: 13\n    }\n  }, /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 267,\n      columnNumber: 15\n    }\n  }, \"Dijkstra's Algorithm\"), algorithm === \"dijkstraWithWalls\" ? /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 268,\n      columnNumber: 52\n    }\n  }, \"\\u2713\") : \"\")))), /*#__PURE__*/React.createElement(Grid, {\n    grid: grid,\n    pairGrid: pairGrid,\n    maze: maze,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 297,\n      columnNumber: 7\n    }\n  }));\n};\n\nexport default Visualizer;","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/Visualizer/Visualizer.tsx"],"names":["React","useState","Grid","NavBar","NavDropDownItem","DropDownMenu","DropDownAlgo","DropDownSlider","NavButton","algorithms","createEmptyMazeGraph","generateMazeGraph","constructGrid","NUMBER_OF_ROWS","NUMBER_OF_COLUMN","VISITED_ANIMATION_TIMEOUT","PATH_ANIMATION_TIMEOUT","firstGrid","firstStartNode","firstEndNode","firstpairGrid","mazeGraph","Visualizer","grid","setGrid","maze","setMaze","pairGrid","setPairGrid","algorithm","setAlgorithm","wallsDensity","setWallsDensity","isVisualized","setIsVisualized","startNode","setStartNode","endNode","setEndNode","visualizeAlgorithm","visited","path","n","length","i","setTimeout","newGrid","slice","node","x","y","newNode","isVisited","m","isShortestPath","handleAlgorithmChange","algorithmName","chooseAlgorithm","handleVisualization","generateMaze","newPairGrid","newMaze","reinitialize","newStartNode","newEndNode"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,QAAhB,QAAgC,OAAhC;AACA,OAAO,kBAAP;AACA,SAASC,IAAT,QAAqB,cAArB;AACA,SACEC,MADF,EAEEC,eAFF,EAGEC,YAHF,EAIEC,YAJF,EAKEC,cALF,EAMEC,SANF,QAOO,kBAPP;AASA,SAASC,UAAT,QAA2B,0DAA3B;AACA,SACEC,oBADF,EAEEC,iBAFF,QAGO,8CAHP;AAIA,SAASC,aAAT,QAA8B,mCAA9B;AAEA,MAAMC,cAAsB,GAAG,EAA/B;AACA,MAAMC,gBAAwB,GAAG,EAAjC;AACA,MAAMC,yBAAiC,GAAG,EAA1C;AACA,MAAMC,sBAA8B,GAAG,EAAvC,C,CAEA;AACA;AACA;;AACA,MAAM,CAACC,SAAD,EAAYC,cAAZ,EAA4BC,YAA5B,IAA4CP,aAAa,CAC7DC,cAD6D,EAE7DC,gBAF6D,EAG7D,CAAC,CAAD,EAAI,CAAJ,CAH6D,EAI7D,CAAC,CAAD,EAAI,EAAJ,CAJ6D,CAA/D;AAOA,MAAM,CAACM,aAAD,EAAgBC,SAAhB,IAA6BX,oBAAoB,CACrDG,cADqD,EAErDC,gBAFqD,EAGrDG,SAHqD,CAAvD,C,CAMA;;AACA,MAAMK,UAAoB,GAAG,MAAM;AACjC;AACA,QAAM,CAACC,IAAD,EAAOC,OAAP,IAAkBvB,QAAQ,CAACgB,SAAD,CAAhC;AACA,QAAM,CAACQ,IAAD,EAAOC,OAAP,IAAkBzB,QAAQ,CAACoB,SAAD,CAAhC;AACA,QAAM,CAACM,QAAD,EAAWC,WAAX,IAA0B3B,QAAQ,CAACmB,aAAD,CAAxC;AACA,QAAM,CAACS,SAAD,EAAYC,YAAZ,IAA4B7B,QAAQ,CAAC,mBAAD,CAA1C;AACA,QAAM,CAAC8B,YAAD,EAAeC,eAAf,IAAkC/B,QAAQ,CAAC,GAAD,CAAhD;AACA,QAAM,CAACgC,YAAD,EAAeC,eAAf,IAAkCjC,QAAQ,CAAC,CAAD,CAAhD,CAPiC,CAQjC;AAEA;;AACA,QAAM,CAACkC,SAAD,EAAYC,YAAZ,IAA4BnC,QAAQ,CAACiB,cAAD,CAA1C;AACA,QAAM,CAACmB,OAAD,EAAUC,UAAV,IAAwBrC,QAAQ,CAACkB,YAAD,CAAtC,CAZiC,CAcjC;;AACA,QAAMoB,kBAA2D,GAAG,CAClEC,OADkE,EAElEC,IAFkE,KAG/D;AACH,UAAMC,CAAC,GAAGF,OAAO,CAACG,MAAlB;;AACA,SAAK,IAAIC,CAAS,GAAG,CAArB,EAAwBA,CAAC,GAAGF,CAA5B,EAA+BE,CAAC,EAAhC,EAAoC;AAClCC,MAAAA,UAAU,CAAC,MAAM;AACf,cAAMC,OAAO,GAAGvB,IAAI,CAACwB,KAAL,EAAhB;AACA,cAAMC,IAAI,GAAGR,OAAO,CAACI,CAAD,CAApB,CAFe,CAGf;;AACA,cAAMK,CAAS,GAAGD,IAAI,CAACC,CAAvB;AACA,cAAMC,CAAS,GAAGF,IAAI,CAACE,CAAvB;AACA,cAAMC,OAAa,GAAG,EACpB,GAAGH,IADiB;AAEpBI,UAAAA,SAAS,EAAE;AAFS,SAAtB;AAIAN,QAAAA,OAAO,CAACG,CAAD,CAAP,CAAWC,CAAX,IAAgBC,OAAhB;AACA3B,QAAAA,OAAO,CAACsB,OAAD,CAAP;AACD,OAZS,EAYP/B,yBAAyB,GAAG6B,CAZrB,CAAV;AAaD;;AAED,UAAMS,CAAC,GAAGZ,IAAI,CAACE,MAAf;;AACA,SAAK,IAAIC,CAAS,GAAG,CAArB,EAAwBA,CAAC,GAAGS,CAA5B,EAA+BT,CAAC,EAAhC,EAAoC;AAClCC,MAAAA,UAAU,CAAC,MAAM;AACf,cAAMC,OAAO,GAAGvB,IAAI,CAACwB,KAAL,EAAhB;AACA,cAAMC,IAAI,GAAGP,IAAI,CAACG,CAAD,CAAjB,CAFe,CAGf;;AACA,cAAMK,CAAS,GAAGD,IAAI,CAACC,CAAvB;AACA,cAAMC,CAAS,GAAGF,IAAI,CAACE,CAAvB;AACA,cAAMC,OAAa,GAAG,EACpB,GAAGH,IADiB;AAEpBI,UAAAA,SAAS,EAAE,KAFS;AAGpBE,UAAAA,cAAc,EAAE;AAHI,SAAtB;AAKAR,QAAAA,OAAO,CAACG,CAAD,CAAP,CAAWC,CAAX,IAAgBC,OAAhB;AACA3B,QAAAA,OAAO,CAACsB,OAAD,CAAP;AACD,OAbS,EAaP/B,yBAAyB,GAAG2B,CAA5B,GAAgC1B,sBAAsB,GAAG4B,CAblD,CAAV;AAcD;AACF,GAtCD,CAfiC,CAuDjC;;;AACA,QAAMW,qBAAsD,GAC1DC,aAD6D,IAE1D;AACH1B,IAAAA,YAAY,CAAC0B,aAAD,CAAZ;AACD,GAJD,CAxDiC,CA8DjC;;;AACA,QAAMC,eAMe,GAAG,MAAM;AAC5B,WAAOhD,UAAU,CAACoB,SAAD,CAAjB;AACD,GARD;;AAUA,QAAM6B,mBAA+B,GAAG,MAAM;AAC5C,QAAIzB,YAAY,KAAK,CAArB,EAAwB;AACtBC,MAAAA,eAAe,CAAC,CAAD,CAAf;AACA,YAAM,CAACM,OAAD,EAAUC,IAAV,IAAoCgB,eAAe,GACvDlC,IADuD,EAEvDI,QAFuD,EAGvDF,IAHuD,EAIvDU,SAJuD,EAKvDE,OALuD,CAAzD;AAOA,YAAMK,CAAS,GAAGF,OAAO,CAACG,MAA1B;AAAA,YACEU,CAAS,GAAGZ,IAAI,CAACE,MADnB;AAEAJ,MAAAA,kBAAkB,CAACC,OAAD,EAAUC,IAAV,CAAlB;AACAI,MAAAA,UAAU,CAAC,MAAM;AACfX,QAAAA,eAAe,CAAC,CAAD,CAAf;AACD,OAFS,EAEPnB,yBAAyB,GAAG2B,CAA5B,GAAgC1B,sBAAsB,GAAGqC,CAFlD,CAAV;AAGD;AACF,GAjBD,CAzEiC,CA4FjC;;;AACA,QAAMM,YAAwB,GAAG,MAAM;AACrC,QAAI1B,YAAY,KAAK,CAArB,EAAwB;AACtB,YAAMa,OAAO,GAAGvB,IAAI,CAACwB,KAAL,EAAhB;AACA,YAAM,CAACa,WAAD,EAAcC,OAAd,IAAyBlD,iBAAiB,CAC9CE,cAD8C,EAE9CC,gBAF8C,EAG9CgC,OAH8C,EAI9Cf,YAJ8C,CAAhD;AAMAP,MAAAA,OAAO,CAACsB,OAAD,CAAP;AACAlB,MAAAA,WAAW,CAACgC,WAAD,CAAX;AACAlC,MAAAA,OAAO,CAACmC,OAAD,CAAP;AACD;AACF,GAbD,CA7FiC,CA4GjC;;;AACA,QAAMC,YAAwB,GAAG,MAAM;AACrC,UAAM,CAAChB,OAAD,EAAUiB,YAAV,EAAwBC,UAAxB,IAAsCpD,aAAa,CACvDC,cADuD,EAEvDC,gBAFuD,EAGvD,CAACqB,SAAS,CAACc,CAAX,EAAcd,SAAS,CAACe,CAAxB,CAHuD,EAIvD,CAACb,OAAO,CAACY,CAAT,EAAYZ,OAAO,CAACa,CAApB,CAJuD,CAAzD;AAMA,UAAM,CAACU,WAAD,EAAcC,OAAd,IAAyBnD,oBAAoB,CACjDG,cADiD,EAEjDC,gBAFiD,EAGjDgC,OAHiD,CAAnD;AAKAtB,IAAAA,OAAO,CAACsB,OAAD,CAAP;AACAlB,IAAAA,WAAW,CAACgC,WAAD,CAAX;AACAlC,IAAAA,OAAO,CAACmC,OAAD,CAAP;AACAzB,IAAAA,YAAY,CAAC2B,YAAD,CAAZ;AACAzB,IAAAA,UAAU,CAAC0B,UAAD,CAAV;AACA9B,IAAAA,eAAe,CAAC,CAAD,CAAf;AACD,GAlBD,CA7GiC,CAiIjC;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AACA,sBACE;AAAK,IAAA,SAAS,EAAC,KAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACE,oBAAC,MAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACE,oBAAC,SAAD;AACE,IAAA,IAAI,EAAC,cADP;AAEE,IAAA,YAAY,EAAED,YAFhB;AAGE,IAAA,SAAS,EAAC,cAHZ;AAIE,IAAA,oBAAoB,EAAC,YAJvB;AAKE,IAAA,mBAAmB,EAAC,WALtB;AAME,IAAA,WAAW,EAAE6B,YANf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IADF,eASE,oBAAC,SAAD;AACE,IAAA,IAAI,EAAC,eADP;AAEE,IAAA,YAAY,EAAE7B,YAFhB;AAGE,IAAA,SAAS,EAAC,eAHZ;AAIE,IAAA,oBAAoB,EAAC,YAJvB;AAKE,IAAA,mBAAmB,EAAC,YALtB;AAME,IAAA,WAAW,EAAE0B,YANf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IATF,eAiBE,oBAAC,eAAD;AACE,IAAA,IAAI,EAAC,cADP;AAEE,IAAA,EAAE,EAAC,cAFL;AAGE,IAAA,YAAY,EAAE1B,YAHhB;AAIE,IAAA,aAAa,EAAE,IAJjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAME,oBAAC,YAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACE,oBAAC,cAAD;AACE,IAAA,IAAI,EAAC,kBADP;AAEE,IAAA,QAAQ,EAAE,GAFZ;AAGE,IAAA,QAAQ,EAAE,CAHZ;AAIE,IAAA,YAAY,EAAEF,YAJhB;AAKE,IAAA,YAAY,EAAEC,eALhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IADF,CANF,CAjBF,eAiCE,oBAAC,SAAD;AACE,IAAA,IAAI,EAAC,YADP;AAEE,IAAA,YAAY,EAAEC,YAFhB;AAGE,IAAA,SAAS,EAAC,kBAHZ;AAIE,IAAA,oBAAoB,EAAC,YAJvB;AAKE,IAAA,mBAAmB,EAAC,YALtB;AAME,IAAA,WAAW,EAAEyB,mBANf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAjCF,eAyCE,oBAAC,eAAD;AACE,IAAA,IAAI,EAAC,WADP;AAEE,IAAA,EAAE,EAAC,YAFL;AAGE,IAAA,YAAY,EAAEzB,YAHhB;AAIE,IAAA,aAAa,EAAE,KAJjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAME,oBAAC,YAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACE,oBAAC,YAAD;AACE,IAAA,eAAe,EAAEsB,qBADnB;AAEE,IAAA,aAAa,EAAC,mBAFhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAIE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,4BAJF,EAKG1B,SAAS,KAAK,mBAAd,gBAAoC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cAApC,GAA+C,EALlD,CADF,CANF,CAzCF,CADF,eAmFE,oBAAC,IAAD;AAAM,IAAA,IAAI,EAAEN,IAAZ;AAAkB,IAAA,QAAQ,EAAEI,QAA5B;AAAsC,IAAA,IAAI,EAAEF,IAA5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAnFF,CADF;AAuFD,CAlQD;;AAoQA,eAAeH,UAAf","sourcesContent":["import React, { useState } from \"react\";\nimport \"./Visualizer.css\";\nimport { Grid } from \"../Grid/Grid\";\nimport {\n  NavBar,\n  NavDropDownItem,\n  DropDownMenu,\n  DropDownAlgo,\n  DropDownSlider,\n  NavButton,\n} from \"../NavBar/NavBar\";\nimport { node } from \"../helper_functions/usefulInterfaces\";\nimport { algorithms } from \"../helper_functions/shortestPathAlgorithms/allAlgorithms\";\nimport {\n  createEmptyMazeGraph,\n  generateMazeGraph,\n} from \"../helper_functions/mazeGenerators/mazeGraph\";\nimport { constructGrid } from \"../helper_functions/constructGrid\";\n\nconst NUMBER_OF_ROWS: number = 28;\nconst NUMBER_OF_COLUMN: number = 13;\nconst VISITED_ANIMATION_TIMEOUT: number = 35;\nconst PATH_ANIMATION_TIMEOUT: number = 75;\n\n// We define these constants out of the functional component\n// that the App uses to avoid re-running the functions to create\n// these each time there is a re-render\nconst [firstGrid, firstStartNode, firstEndNode] = constructGrid(\n  NUMBER_OF_ROWS,\n  NUMBER_OF_COLUMN,\n  [6, 3],\n  [6, 24]\n);\n\nconst [firstpairGrid, mazeGraph] = createEmptyMazeGraph(\n  NUMBER_OF_ROWS,\n  NUMBER_OF_COLUMN,\n  firstGrid\n);\n\n// Component rendering everything in the webpage.\nconst Visualizer: React.FC = () => {\n  // States managing the grid\n  const [grid, setGrid] = useState(firstGrid);\n  const [maze, setMaze] = useState(mazeGraph);\n  const [pairGrid, setPairGrid] = useState(firstpairGrid);\n  const [algorithm, setAlgorithm] = useState(\"dijkstraWithWalls\");\n  const [wallsDensity, setWallsDensity] = useState(0.7);\n  const [isVisualized, setIsVisualized] = useState(0);\n  // const [mouseIsPressed, setMouseIsPressed] = useState(false);\n\n  // States of the start and end node\n  const [startNode, setStartNode] = useState(firstStartNode);\n  const [endNode, setEndNode] = useState(firstEndNode);\n\n  // This function is there to visualize the algorithm chosen in the drop down menu\n  const visualizeAlgorithm: (visited: node[], path: node[]) => void = (\n    visited,\n    path\n  ) => {\n    const n = visited.length;\n    for (let i: number = 0; i < n; i++) {\n      setTimeout(() => {\n        const newGrid = grid.slice();\n        const node = visited[i];\n        // define the x and y of the current node\n        const x: number = node.x;\n        const y: number = node.y;\n        const newNode: node = {\n          ...node,\n          isVisited: true,\n        };\n        newGrid[x][y] = newNode;\n        setGrid(newGrid);\n      }, VISITED_ANIMATION_TIMEOUT * i);\n    }\n\n    const m = path.length;\n    for (let i: number = 0; i < m; i++) {\n      setTimeout(() => {\n        const newGrid = grid.slice();\n        const node = path[i];\n        // define the x and y of the current node\n        const x: number = node.x;\n        const y: number = node.y;\n        const newNode: node = {\n          ...node,\n          isVisited: false,\n          isShortestPath: true,\n        };\n        newGrid[x][y] = newNode;\n        setGrid(newGrid);\n      }, VISITED_ANIMATION_TIMEOUT * n + PATH_ANIMATION_TIMEOUT * i);\n    }\n  };\n\n  // This function is passed to the drop down menu to handle the change of algorithm\n  const handleAlgorithmChange: (algorithmName: string) => void = (\n    algorithmName\n  ) => {\n    setAlgorithm(algorithmName);\n  };\n\n  // This function changes the algorithm that will be run, at the moment only dijkstra is implemented\n  const chooseAlgorithm: () => (\n    grid: node[][],\n    pairGrid: [number, number][][],\n    mazeGraph: Map<[number, number], [number, number][]>,\n    startNode: node,\n    endNode: node\n  ) => [node[], node[]] = () => {\n    return algorithms[algorithm];\n  };\n\n  const handleVisualization: () => void = () => {\n    if (isVisualized === 0) {\n      setIsVisualized(1);\n      const [visited, path]: [node[], node[]] = chooseAlgorithm()(\n        grid,\n        pairGrid,\n        maze,\n        startNode,\n        endNode\n      );\n      const n: number = visited.length,\n        m: number = path.length;\n      visualizeAlgorithm(visited, path);\n      setTimeout(() => {\n        setIsVisualized(2);\n      }, VISITED_ANIMATION_TIMEOUT * n + PATH_ANIMATION_TIMEOUT * m);\n    }\n  };\n\n  // This function calls the generate maze function\n  const generateMaze: () => void = () => {\n    if (isVisualized === 0) {\n      const newGrid = grid.slice();\n      const [newPairGrid, newMaze] = generateMazeGraph(\n        NUMBER_OF_ROWS,\n        NUMBER_OF_COLUMN,\n        newGrid,\n        wallsDensity\n      );\n      setGrid(newGrid);\n      setPairGrid(newPairGrid);\n      setMaze(newMaze);\n    }\n  };\n\n  // Reinitialize the the board\n  const reinitialize: () => void = () => {\n    const [newGrid, newStartNode, newEndNode] = constructGrid(\n      NUMBER_OF_ROWS,\n      NUMBER_OF_COLUMN,\n      [startNode.x, startNode.y],\n      [endNode.x, endNode.y]\n    );\n    const [newPairGrid, newMaze] = createEmptyMazeGraph(\n      NUMBER_OF_ROWS,\n      NUMBER_OF_COLUMN,\n      newGrid\n    );\n    setGrid(newGrid);\n    setPairGrid(newPairGrid);\n    setMaze(newMaze);\n    setStartNode(newStartNode);\n    setEndNode(newEndNode);\n    setIsVisualized(0);\n  };\n\n  // The following block of functions handles the making of walls in the grid\n  // This feature is currently not used as it is not a good fit with the current direction of the app\n\n  // const toggleWall: (x: number, y: number) => void = (x, y) => {\n  //   const newGrid: node[][] = grid.slice();\n  //   let newNode;\n  //   if (!newGrid[x][y].isWall) {\n  //     newNode = {\n  //       ...newGrid[x][y],\n  //       isWall: !newGrid[x][y].isWall,\n  //       className: \"grid-node wall-node\",\n  //     };\n  //   } else {\n  //     newNode = {\n  //       ...newGrid[x][y],\n  //       isWall: !newGrid[x][y].isWall,\n  //       className: \"grid-node\",\n  //     };\n  //   }\n  //   newGrid[x][y] = newNode;\n  //   setGrid(newGrid);\n  // };\n\n  // // handles the case when the mouse button is down\n  // const handleMouseDown: (x: number, y: number) => void = (x, y) => {\n  //   toggleWall(x, y);\n  //   setMouseIsPressed(false);\n  // };\n\n  // // handles the case whan the mouse button is down and you enter a node\n  // const handleMouseEnter: (x: number, y: number) => void = (x, y) => {\n  //   if (mouseIsPressed) {\n  //     toggleWall(x, y);\n  //   }\n  // };\n\n  // // handles the case when you mouse up\n  // const handleMouseUp: () => void = () => {\n  //   setMouseIsPressed(false);\n  // };\n\n  // Render the app\n  return (\n    <div className=\"App\">\n      <NavBar>\n        <NavButton\n          text=\"Reinitialize\"\n          isVisualized={isVisualized}\n          className=\"reinitialize\"\n          visualizingClassName=\"greyed-out\"\n          visualizedClassName=\"highlight\"\n          handleClick={reinitialize}\n        />\n        <NavButton\n          text=\"Generate Maze\"\n          isVisualized={isVisualized}\n          className=\"generate-maze\"\n          visualizingClassName=\"greyed-out\"\n          visualizedClassName=\"greyed-out\"\n          handleClick={generateMaze}\n        />\n        <NavDropDownItem\n          text=\"Maze options\"\n          id=\"maze-options\"\n          isVisualized={isVisualized}\n          shouldGreyOut={true}\n        >\n          <DropDownMenu>\n            <DropDownSlider\n              text=\"Density of walls\"\n              minValue={0.1}\n              maxValue={1}\n              defaultValue={wallsDensity}\n              handleChange={setWallsDensity}\n            ></DropDownSlider>\n          </DropDownMenu>\n        </NavDropDownItem>\n        <NavButton\n          text=\"Visualize!\"\n          isVisualized={isVisualized}\n          className=\"visualize-button\"\n          visualizingClassName=\"greyed-out\"\n          visualizedClassName=\"greyed-out\"\n          handleClick={handleVisualization}\n        />\n        <NavDropDownItem\n          text=\"Algorithm\"\n          id=\"algorithms\"\n          isVisualized={isVisualized}\n          shouldGreyOut={false}\n        >\n          <DropDownMenu>\n            <DropDownAlgo\n              changeAlgorithm={handleAlgorithmChange}\n              algorithmName=\"dijkstraWithWalls\"\n            >\n              <p>Dijkstra's Algorithm</p>\n              {algorithm === \"dijkstraWithWalls\" ? <p>✓</p> : \"\"}\n            </DropDownAlgo>\n            {/* <DropDownAlgo\n              changeAlgorithm={handleAlgorithmChange}\n              algorithmName=\"A*\"\n            >\n              A* Algorithm\n            </DropDownAlgo> */}\n          </DropDownMenu>\n        </NavDropDownItem>\n      </NavBar>\n      {/* <SecondaryHeader>\n        <button\n          className=\"visualize-button\"\n          onClick={(e) => {\n            visualizeAlgorithm(\n              ...chooseAlgorithm(algorithm)(\n                grid,\n                pairGrid,\n                mazeGraph,\n                startNode,\n                endNode\n              )\n            );\n          }}\n        >\n          Visualize the path!\n        </button>\n      </SecondaryHeader> */}\n      <Grid grid={grid} pairGrid={pairGrid} maze={maze} />\n    </div>\n  );\n};\n\nexport default Visualizer;\n"]},"metadata":{},"sourceType":"module"}