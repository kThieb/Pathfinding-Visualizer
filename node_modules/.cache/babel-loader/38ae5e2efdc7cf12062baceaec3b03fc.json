{"ast":null,"code":"import { retrieveTwoEndedPath } from \"../retrievePath\";\nimport { ensure } from \"../../ensureNotUndefined\";\nexport const twoEndedBfs = (grid, pairGrid, mazeGraph, startNode, targetList) => {\n  const m = grid.length,\n        n = grid[0].length; // Initialize the predecessor array\n\n  const predecessor = [];\n\n  for (let i = 0; i < m * n; i++) {\n    predecessor.push(startNode);\n  }\n\n  predecessor[startNode.id] = startNode;\n  const successor = [];\n\n  for (let i = 0; i < m * n; i++) {\n    successor.push(targetList[0]);\n  }\n\n  successor[targetList[0].id] = targetList[0];\n  const source = [];\n\n  for (let i = 0; i < m * n; i++) {\n    source.push(targetList[0]);\n  }\n\n  source[startNode.id] = startNode;\n  source[targetList[0].id] = targetList[0]; // Initialize the visited nodes array\n\n  let visited = []; // Initialize the discovered array\n\n  let discovered = [startNode, targetList[0]]; // Initialize the Queue TODO: IMPLEMENT A BETTER VERSION OF THE QUEUE WITH O(1) OPERATIONS\n\n  let q = [startNode, targetList[0]]; // While the queue is not empty\n\n  while (q.length > 0) {\n    // Get the element in front of the queue\n    let currentNode = ensure(q.shift());\n    if (visited.find(visitedNode => visitedNode === currentNode)) continue; // Put the currentNode node in the visited set\n\n    visited.push(currentNode); // iterate through the neighbors of the currentNode node\n\n    for (const neighbor of ensure(mazeGraph.get(pairGrid[currentNode.x][currentNode.y]))) {\n      // Get the coordinates of the neighbor node\n      let neighborX = neighbor[0][0],\n          neighborY = neighbor[0][1];\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n) continue; // Get the node in the grid\n\n      let nextNode = grid[neighborX][neighborY]; // Store the result of the find function for later\n\n      const foundNode = visited.find(visitedNode => visitedNode === nextNode); // If we found the end node, return the path to it\n\n      if (foundNode && source[currentNode.id] !== source[foundNode.id]) {\n        if (source[currentNode.id] === startNode) predecessor[nextNode.id] = currentNode;else successor[nextNode.id] = currentNode; // Retrieve the shortest path\n\n        const shortestPath = retrieveTwoEndedPath(predecessor, successor, nextNode, startNode, targetList[0]);\n        return [visited, shortestPath];\n      }\n\n      if (discovered.find(discoveredNode => discoveredNode === grid[neighborX][neighborY])) continue;\n      source[nextNode.id] = source[currentNode.id];\n\n      if (source[currentNode.id] === startNode) {\n        // update the predecessor array\n        predecessor[nextNode.id] = currentNode;\n      } else {\n        successor[nextNode.id] = currentNode;\n      } // Add the node to the visited nodes\n\n\n      discovered.push(nextNode); // Push the next node to the queue\n\n      q.push(nextNode);\n    }\n  }\n\n  return [[visited, []], 0];\n};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helperFunctions/shortestPathAlgorithms/singleTarget/twoEndedBfs.ts"],"names":["retrieveTwoEndedPath","ensure","twoEndedBfs","grid","pairGrid","mazeGraph","startNode","targetList","m","length","n","predecessor","i","push","id","successor","source","visited","discovered","q","currentNode","shift","find","visitedNode","neighbor","get","x","y","neighborX","neighborY","nextNode","foundNode","shortestPath","discoveredNode"],"mappings":"AACA,SAASA,oBAAT,QAAqC,iBAArC;AACA,SAASC,MAAT,QAAuB,0BAAvB;AAEA,OAAO,MAAMC,WAMkB,GAAG,CAChCC,IADgC,EAEhCC,QAFgC,EAGhCC,SAHgC,EAIhCC,SAJgC,EAKhCC,UALgC,KAM7B;AACH,QAAMC,CAAC,GAAGL,IAAI,CAACM,MAAf;AAAA,QACEC,CAAC,GAAGP,IAAI,CAAC,CAAD,CAAJ,CAAQM,MADd,CADG,CAIH;;AACA,QAAME,WAAmB,GAAG,EAA5B;;AACA,OAAK,IAAIC,CAAS,GAAG,CAArB,EAAwBA,CAAC,GAAGJ,CAAC,GAAGE,CAAhC,EAAmCE,CAAC,EAApC,EAAwC;AACtCD,IAAAA,WAAW,CAACE,IAAZ,CAAiBP,SAAjB;AACD;;AACDK,EAAAA,WAAW,CAACL,SAAS,CAACQ,EAAX,CAAX,GAA4BR,SAA5B;AAEA,QAAMS,SAAiB,GAAG,EAA1B;;AACA,OAAK,IAAIH,CAAS,GAAG,CAArB,EAAwBA,CAAC,GAAGJ,CAAC,GAAGE,CAAhC,EAAmCE,CAAC,EAApC,EAAwC;AACtCG,IAAAA,SAAS,CAACF,IAAV,CAAeN,UAAU,CAAC,CAAD,CAAzB;AACD;;AACDQ,EAAAA,SAAS,CAACR,UAAU,CAAC,CAAD,CAAV,CAAcO,EAAf,CAAT,GAA8BP,UAAU,CAAC,CAAD,CAAxC;AAEA,QAAMS,MAAc,GAAG,EAAvB;;AACA,OAAK,IAAIJ,CAAS,GAAG,CAArB,EAAwBA,CAAC,GAAGJ,CAAC,GAAGE,CAAhC,EAAmCE,CAAC,EAApC,EAAwC;AACtCI,IAAAA,MAAM,CAACH,IAAP,CAAYN,UAAU,CAAC,CAAD,CAAtB;AACD;;AACDS,EAAAA,MAAM,CAACV,SAAS,CAACQ,EAAX,CAAN,GAAuBR,SAAvB;AACAU,EAAAA,MAAM,CAACT,UAAU,CAAC,CAAD,CAAV,CAAcO,EAAf,CAAN,GAA2BP,UAAU,CAAC,CAAD,CAArC,CAtBG,CAwBH;;AACA,MAAIU,OAAe,GAAG,EAAtB,CAzBG,CA2BH;;AACA,MAAIC,UAAkB,GAAG,CAACZ,SAAD,EAAYC,UAAU,CAAC,CAAD,CAAtB,CAAzB,CA5BG,CA8BH;;AACA,MAAIY,CAAS,GAAG,CAACb,SAAD,EAAYC,UAAU,CAAC,CAAD,CAAtB,CAAhB,CA/BG,CAiCH;;AACA,SAAOY,CAAC,CAACV,MAAF,GAAW,CAAlB,EAAqB;AACnB;AACA,QAAIW,WAAiB,GAAGnB,MAAM,CAACkB,CAAC,CAACE,KAAF,EAAD,CAA9B;AAEA,QAAIJ,OAAO,CAACK,IAAR,CAAcC,WAAD,IAAiBA,WAAW,KAAKH,WAA9C,CAAJ,EAAgE,SAJ7C,CAMnB;;AACAH,IAAAA,OAAO,CAACJ,IAAR,CAAaO,WAAb,EAPmB,CASnB;;AACA,SAAK,MAAMI,QAAX,IAAuBvB,MAAM,CAC3BI,SAAS,CAACoB,GAAV,CAAcrB,QAAQ,CAACgB,WAAW,CAACM,CAAb,CAAR,CAAwBN,WAAW,CAACO,CAApC,CAAd,CAD2B,CAA7B,EAEG;AACD;AACA,UAAIC,SAAiB,GAAGJ,QAAQ,CAAC,CAAD,CAAR,CAAY,CAAZ,CAAxB;AAAA,UACEK,SAAiB,GAAGL,QAAQ,CAAC,CAAD,CAAR,CAAY,CAAZ,CADtB;AAGA,UAAII,SAAS,GAAG,CAAZ,IAAiBA,SAAS,IAAIpB,CAA9B,IAAmCqB,SAAS,GAAG,CAA/C,IAAoDA,SAAS,IAAInB,CAArE,EACE,SAND,CAQD;;AACA,UAAIoB,QAAc,GAAG3B,IAAI,CAACyB,SAAD,CAAJ,CAAgBC,SAAhB,CAArB,CATC,CAWD;;AACA,YAAME,SAA2B,GAAGd,OAAO,CAACK,IAAR,CACjCC,WAAD,IAAiBA,WAAW,KAAKO,QADC,CAApC,CAZC,CAgBD;;AACA,UAAIC,SAAS,IAAIf,MAAM,CAACI,WAAW,CAACN,EAAb,CAAN,KAA2BE,MAAM,CAACe,SAAS,CAACjB,EAAX,CAAlD,EAAkE;AAChE,YAAIE,MAAM,CAACI,WAAW,CAACN,EAAb,CAAN,KAA2BR,SAA/B,EACEK,WAAW,CAACmB,QAAQ,CAAChB,EAAV,CAAX,GAA2BM,WAA3B,CADF,KAEKL,SAAS,CAACe,QAAQ,CAAChB,EAAV,CAAT,GAAyBM,WAAzB,CAH2D,CAIhE;;AACA,cAAMY,YAAY,GAAGhC,oBAAoB,CACvCW,WADuC,EAEvCI,SAFuC,EAGvCe,QAHuC,EAIvCxB,SAJuC,EAKvCC,UAAU,CAAC,CAAD,CAL6B,CAAzC;AAOA,eAAO,CAACU,OAAD,EAAUe,YAAV,CAAP;AACD;;AAED,UACEd,UAAU,CAACI,IAAX,CACGW,cAAD,IAAoBA,cAAc,KAAK9B,IAAI,CAACyB,SAAD,CAAJ,CAAgBC,SAAhB,CADzC,CADF,EAKE;AAEFb,MAAAA,MAAM,CAACc,QAAQ,CAAChB,EAAV,CAAN,GAAsBE,MAAM,CAACI,WAAW,CAACN,EAAb,CAA5B;;AAEA,UAAIE,MAAM,CAACI,WAAW,CAACN,EAAb,CAAN,KAA2BR,SAA/B,EAA0C;AACxC;AACAK,QAAAA,WAAW,CAACmB,QAAQ,CAAChB,EAAV,CAAX,GAA2BM,WAA3B;AACD,OAHD,MAGO;AACLL,QAAAA,SAAS,CAACe,QAAQ,CAAChB,EAAV,CAAT,GAAyBM,WAAzB;AACD,OA9CA,CAgDD;;;AACAF,MAAAA,UAAU,CAACL,IAAX,CAAgBiB,QAAhB,EAjDC,CAmDD;;AACAX,MAAAA,CAAC,CAACN,IAAF,CAAOiB,QAAP;AACD;AACF;;AAED,SAAO,CAAC,CAACb,OAAD,EAAU,EAAV,CAAD,EAAgB,CAAhB,CAAP;AACD,CAnHM","sourcesContent":["import { node } from \"../../usefulInterfaces\";\nimport { retrieveTwoEndedPath } from \"../retrievePath\";\nimport { ensure } from \"../../ensureNotUndefined\";\n\nexport const twoEndedBfs: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [[node[], node[]], number] = (\n  grid,\n  pairGrid,\n  mazeGraph,\n  startNode,\n  targetList\n) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    predecessor.push(startNode);\n  }\n  predecessor[startNode.id] = startNode;\n\n  const successor: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    successor.push(targetList[0]);\n  }\n  successor[targetList[0].id] = targetList[0];\n\n  const source: node[] = [];\n  for (let i: number = 0; i < m * n; i++) {\n    source.push(targetList[0]);\n  }\n  source[startNode.id] = startNode;\n  source[targetList[0].id] = targetList[0];\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  // Initialize the discovered array\n  let discovered: node[] = [startNode, targetList[0]];\n\n  // Initialize the Queue TODO: IMPLEMENT A BETTER VERSION OF THE QUEUE WITH O(1) OPERATIONS\n  let q: node[] = [startNode, targetList[0]];\n\n  // While the queue is not empty\n  while (q.length > 0) {\n    // Get the element in front of the queue\n    let currentNode: node = ensure(q.shift());\n\n    if (visited.find((visitedNode) => visitedNode === currentNode)) continue;\n\n    // Put the currentNode node in the visited set\n    visited.push(currentNode);\n\n    // iterate through the neighbors of the currentNode node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentNode.x][currentNode.y])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0][0],\n        neighborY: number = neighbor[0][1];\n\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n)\n        continue;\n\n      // Get the node in the grid\n      let nextNode: node = grid[neighborX][neighborY];\n\n      // Store the result of the find function for later\n      const foundNode: node | undefined = visited.find(\n        (visitedNode) => visitedNode === nextNode\n      );\n\n      // If we found the end node, return the path to it\n      if (foundNode && source[currentNode.id] !== source[foundNode.id]) {\n        if (source[currentNode.id] === startNode)\n          predecessor[nextNode.id] = currentNode;\n        else successor[nextNode.id] = currentNode;\n        // Retrieve the shortest path\n        const shortestPath = retrieveTwoEndedPath(\n          predecessor,\n          successor,\n          nextNode,\n          startNode,\n          targetList[0]\n        );\n        return [visited, shortestPath];\n      }\n\n      if (\n        discovered.find(\n          (discoveredNode) => discoveredNode === grid[neighborX][neighborY]\n        )\n      )\n        continue;\n\n      source[nextNode.id] = source[currentNode.id];\n\n      if (source[currentNode.id] === startNode) {\n        // update the predecessor array\n        predecessor[nextNode.id] = currentNode;\n      } else {\n        successor[nextNode.id] = currentNode;\n      }\n\n      // Add the node to the visited nodes\n      discovered.push(nextNode);\n\n      // Push the next node to the queue\n      q.push(nextNode);\n    }\n  }\n\n  return [[visited, []], 0];\n};\n"]},"metadata":{},"sourceType":"module"}