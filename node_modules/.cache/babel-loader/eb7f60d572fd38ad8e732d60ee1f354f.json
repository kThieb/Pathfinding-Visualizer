{"ast":null,"code":"import { dijkstra, getDistanceMatrix } from \"../singleTarget/dijkstra\";\nimport { greedy } from \"./greedy\";\nexport const bruteForceTSP = (grid, pairGrid, mazeGraph, startNode, targetList) => {\n  const newTargetList = targetList.slice();\n  newTargetList.unshift(startNode);\n  const distancesMatrix = getDistanceMatrix(grid, pairGrid, mazeGraph, newTargetList);\n  let path = [[startNode, 0]];\n  let optimalPath = [];\n  let maxCost = greedy(grid, pairGrid, mazeGraph, startNode, targetList)[1];\n  const maxLength = targetList.length + 1;\n  const bnbtargets = targetList.map((targetNode, i) => [targetNode, i]);\n\n  const branchAndBound = (candidatePath, remainingTargets, currentCost) => {\n    if (candidatePath.length === maxLength) {\n      if (currentCost > maxCost) return;\n      maxCost = currentCost;\n      optimalPath = candidatePath;\n      return;\n    }\n\n    const newRemainingTargets = remainingTargets.slice();\n    remainingTargets.forEach(targetNodeAndIndex => {\n      let prevId = candidatePath[candidatePath.length - 1][1];\n      candidatePath.push(targetNodeAndIndex);\n      branchAndBound(candidatePath.slice(), newRemainingTargets.filter(tgAndId => tgAndId[1] !== targetNodeAndIndex[1]), currentCost + distancesMatrix[prevId][targetNodeAndIndex[1]]);\n      candidatePath.pop();\n    });\n  };\n\n  branchAndBound(path, bnbtargets, 0);\n  console.log(optimalPath);\n  return [getTrueOptimalPath(grid, pairGrid, mazeGraph, optimalPath.map(valueIndexPair => valueIndexPair[0])), maxCost];\n};\n\nconst getTrueOptimalPath = (grid, pairGrid, mazeGraph, optimalPath) => {\n  let actualPath = [];\n\n  for (let i = 0; i < optimalPath.length - 1; i++) {\n    let path = dijkstra(grid, pairGrid, mazeGraph, optimalPath[i], [optimalPath[i + 1]])[1];\n    actualPath.push([[], path.slice()]);\n  }\n\n  return actualPath;\n};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helperFunctions/shortestPathAlgorithms/multipleTarget/bruteForce.ts"],"names":["dijkstra","getDistanceMatrix","greedy","bruteForceTSP","grid","pairGrid","mazeGraph","startNode","targetList","newTargetList","slice","unshift","distancesMatrix","path","optimalPath","maxCost","maxLength","length","bnbtargets","map","targetNode","i","branchAndBound","candidatePath","remainingTargets","currentCost","newRemainingTargets","forEach","targetNodeAndIndex","prevId","push","filter","tgAndId","pop","console","log","getTrueOptimalPath","valueIndexPair","actualPath"],"mappings":"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","sourcesContent":["import { node } from \"../../usefulInterfaces\";\nimport { dijkstra, getDistanceMatrix } from \"../singleTarget/dijkstra\";\nimport { greedy } from \"./greedy\";\n\nexport const bruteForceTSP: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [[node[], node[]][], number] = (\n  grid,\n  pairGrid,\n  mazeGraph,\n  startNode,\n  targetList\n) => {\n  const newTargetList: node[] = targetList.slice();\n  newTargetList.unshift(startNode);\n  const distancesMatrix: number[][] = getDistanceMatrix(\n    grid,\n    pairGrid,\n    mazeGraph,\n    newTargetList\n  );\n  let path: [node, number][] = [[startNode, 0]];\n  let optimalPath: [node, number][] = [];\n\n  let maxCost: number = greedy(\n    grid,\n    pairGrid,\n    mazeGraph,\n    startNode,\n    targetList\n  )[1];\n  const maxLength: number = targetList.length + 1;\n  const bnbtargets: [node, number][] = targetList.map((targetNode, i) => [\n    targetNode,\n    i,\n  ]);\n\n  const branchAndBound: (\n    candidatePath: [node, number][],\n    remainingTargets: [node, number][],\n    currentCost: number\n  ) => void = (candidatePath, remainingTargets, currentCost) => {\n    if (candidatePath.length === maxLength) {\n      if (currentCost > maxCost) return;\n      maxCost = currentCost;\n      optimalPath = candidatePath;\n      return;\n    }\n    const newRemainingTargets: [node, number][] = remainingTargets.slice();\n    remainingTargets.forEach((targetNodeAndIndex) => {\n      let prevId: number = candidatePath[candidatePath.length - 1][1];\n      candidatePath.push(targetNodeAndIndex);\n      branchAndBound(\n        candidatePath.slice(),\n        newRemainingTargets.filter(\n          (tgAndId) => tgAndId[1] !== targetNodeAndIndex[1]\n        ),\n        currentCost + distancesMatrix[prevId][targetNodeAndIndex[1]]\n      );\n      candidatePath.pop();\n    });\n  };\n  branchAndBound(path, bnbtargets, 0);\n  console.log(optimalPath);\n  return [\n    getTrueOptimalPath(\n      grid,\n      pairGrid,\n      mazeGraph,\n      optimalPath.map((valueIndexPair) => valueIndexPair[0])\n    ),\n    maxCost,\n  ];\n};\n\nconst getTrueOptimalPath: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  optimalPath: node[]\n) => [node[], node[]][] = (grid, pairGrid, mazeGraph, optimalPath) => {\n  let actualPath: [node[], node[]][] = [];\n  for (let i: number = 0; i < optimalPath.length - 1; i++) {\n    let path = dijkstra(grid, pairGrid, mazeGraph, optimalPath[i], [\n      optimalPath[i + 1],\n    ])[1];\n    actualPath.push([[], path.slice()]);\n  }\n  return actualPath;\n};\n"]},"metadata":{},"sourceType":"module"}