{"ast":null,"code":"import _classCallCheck from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import{ensure}from\"../ensureNotUndefined\";export var BinaryHeap=/*#__PURE__*/function(){function BinaryHeap(scoreFunction){var _this=this;_classCallCheck(this,BinaryHeap);this.content=void 0;this.scoreFunction=void 0;this.index=void 0;this.compare=function(a,b){if(_this.scoreFunction(a[0])!==_this.scoreFunction(b[0])){return _this.scoreFunction(a[0])<_this.scoreFunction(b[0]);}return a[1]<b[1];};this.content=[];this.scoreFunction=scoreFunction;this.index=1;}_createClass(BinaryHeap,[{key:\"push\",value:function push(element){this.content.push([element,this.index++]);this.bubbleUp(this.content.length-1);}},{key:\"pop\",value:function pop(){var result=ensure(this.content[0]);var end=this.content.pop();if(this.content.length>0){this.content[0]=end;this.sinkDown(0);}return ensure(result)[0];}},{key:\"remove\",value:function remove(node){var length=this.content.length;// To remove a value, we must search through the array to find\n// it.\nfor(var i=0;i<length;i++){if(ensure(this.content[i])[0]!==node)continue;// When it is found, the process seen in 'pop' is repeated\n// to fill up the hole.\nvar end=this.content.pop();// If the element we popped was the one we needed to remove,\n// we're done.\nif(i===length-1)break;// Otherwise, we replace the removed element with the popped\n// one, and allow it to float up or sink down as appropriate.\nthis.content[i]=end;this.bubbleUp(i);this.sinkDown(i);break;}}},{key:\"size\",value:function size(){return this.content.length;}},{key:\"bubbleUp\",value:function bubbleUp(n){// Fetch the element that has to be moved.\nvar element=ensure(this.content[n]);// When at 0, an element can not go up any further.\nwhile(n>0){// Compute the parent element's index, and fetch it.\nvar parentN=Math.floor((n+1)/2)-1,parent=ensure(this.content[parentN]);// If the parent has a lesser score, things are in order and we\n// are done.\n// if (\n//   score > this.scoreFunction(ensure(parent)[0]) ||\n//   (score === this.scoreFunction(ensure(parent)[0]) &&\n//     ensure(element)[1] > ensure(parent)[1])\n// )\n//   break;\nif(this.compare(parent,element))break;// Otherwise, swap the parent with the current element and\n// continue.\nthis.content[parentN]=element;this.content[n]=parent;n=parentN;}}},{key:\"sinkDown\",value:function sinkDown(n){// Look up the target element and its score.\nvar length=this.content.length,element=ensure(this.content[n]);while(true){// Compute the indices of the child elements.\nvar child2N=(n+1)*2,child1N=child2N-1;var swap=n;// This is used to store the new position of the element, if any.\n// If the first child exists (is inside the array)...\nif(child1N<length&&this.compare(ensure(this.content[child1N]),element))swap=child1N;if(child2N<length&&this.compare(ensure(this.content[child2N]),ensure(this.content[swap])))swap=child2N;// If the order is good, we exit the loop\nif(swap===n)break;// Otherwise, swap and continue.\nthis.content[n]=this.content[swap];this.content[swap]=element;n=swap;}}}]);return BinaryHeap;}();","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helper_functions/dataStructures/binaryHeap.ts"],"names":["ensure","BinaryHeap","scoreFunction","content","index","compare","a","b","element","push","bubbleUp","length","result","end","pop","sinkDown","node","i","n","parentN","Math","floor","parent","child2N","child1N","swap"],"mappings":"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","sourcesContent":["import { ensure } from \"../ensureNotUndefined\";\n\nexport class BinaryHeap<T> {\n  content: ([T, number] | undefined)[];\n  scoreFunction: (x: T) => number;\n  index: number;\n\n  constructor(scoreFunction: (x: T) => number) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n    this.index = 1;\n  }\n\n  compare: (a: [T, number], b: [T, number]) => boolean = (a, b) => {\n    if (this.scoreFunction(a[0]) !== this.scoreFunction(b[0])) {\n      return this.scoreFunction(a[0]) < this.scoreFunction(b[0]);\n    }\n    return a[1] < b[1];\n  };\n\n  push(element: T) {\n    this.content.push([element, this.index++]);\n    this.bubbleUp(this.content.length - 1);\n  }\n\n  pop(): T | undefined {\n    let result: [T, number] = ensure(this.content[0]);\n    let end: [T, number] | undefined = this.content.pop();\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n    return ensure(result)[0];\n  }\n\n  remove(node: T) {\n    let length: number = this.content.length;\n    // To remove a value, we must search through the array to find\n    // it.\n    for (let i: number = 0; i < length; i++) {\n      if (ensure(this.content[i])[0] !== node) continue;\n      // When it is found, the process seen in 'pop' is repeated\n      // to fill up the hole.\n      let end: [T, number] | undefined = this.content.pop();\n      // If the element we popped was the one we needed to remove,\n      // we're done.\n      if (i === length - 1) break;\n      // Otherwise, we replace the removed element with the popped\n      // one, and allow it to float up or sink down as appropriate.\n      this.content[i] = end;\n      this.bubbleUp(i);\n      this.sinkDown(i);\n      break;\n    }\n  }\n\n  size() {\n    return this.content.length;\n  }\n\n  private bubbleUp(n: number) {\n    // Fetch the element that has to be moved.\n    let element: [T, number] = ensure(this.content[n]);\n    // When at 0, an element can not go up any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      let parentN: number = Math.floor((n + 1) / 2) - 1,\n        parent: [T, number] = ensure(this.content[parentN]);\n      // If the parent has a lesser score, things are in order and we\n      // are done.\n      // if (\n      //   score > this.scoreFunction(ensure(parent)[0]) ||\n      //   (score === this.scoreFunction(ensure(parent)[0]) &&\n      //     ensure(element)[1] > ensure(parent)[1])\n      // )\n      //   break;\n      if (this.compare(parent, element)) break;\n\n      // Otherwise, swap the parent with the current element and\n      // continue.\n      this.content[parentN] = element;\n      this.content[n] = parent;\n      n = parentN;\n    }\n  }\n\n  private sinkDown(n: number) {\n    // Look up the target element and its score.\n    let length: number = this.content.length,\n      element: [T, number] = ensure(this.content[n]);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      let child2N: number = (n + 1) * 2,\n        child1N: number = child2N - 1;\n      let swap: number = n;\n      // This is used to store the new position of the element, if any.\n      // If the first child exists (is inside the array)...\n      if (\n        child1N < length &&\n        this.compare(ensure(this.content[child1N]), element)\n      )\n        swap = child1N;\n      if (\n        child2N < length &&\n        this.compare(ensure(this.content[child2N]), ensure(this.content[swap]))\n      )\n        swap = child2N;\n\n      // If the order is good, we exit the loop\n      if (swap === n) break;\n\n      // Otherwise, swap and continue.\n      this.content[n] = this.content[swap];\n      this.content[swap] = element;\n      n = swap;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}