{"ast":null,"code":"import { BinaryHeap } from \"../binaryHeap\";\nimport { retrievePath } from \"./retrievePath\";\nexport const dijkstra = (grid, startNode, endNode) => {\n  const m = grid.length,\n        n = grid[0].length; // Initialize the distances array\n\n  const distances = [];\n\n  for (let i = 0; i < m; i++) {\n    distances.push([]);\n\n    for (let j = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0; // Initialize the predecessor array\n\n  const predecessor = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode; // Initialize the visited nodes array\n\n  let visited = []; // Initialize the directions array we will use to perform Dijkstra's algorithm\n\n  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n  let index = 1; //   Initialize the Binary Heap\n\n  let pq = new BinaryHeap((a, b) => {\n    if (distances[a.x][a.y] != distances[b.x][b.y]) {\n      return distances[a.x][a.y] < distances[b.x][b.y];\n    }\n\n    return a.pqIndex < b.pqIndex;\n  });\n  startNode.pqIndex = index++;\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode = ensure(pq.pop()); // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n\n    visited.push(currentNode); // Get the coordinates of the nodes\n\n    let currentX = currentNode.x;\n    let currentY = currentNode.y; // Iterate the neighbors of the node\n\n    for (const dir of directions) {\n      // Get the coordinates of the next node\n      let nextX = currentX + dir[0];\n      let nextY = currentY + dir[1]; // Check if the coordinates are valid\n\n      if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n) {\n        let nextNode = grid[nextX][nextY]; // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n\n        if (!visited.find(currentNode => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          nextNode.pqIndex = index++;\n          pq.push(nextNode);\n        } // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n\n\n        let currentDistance = distances[currentX][currentY] + 1; // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n\n        if (currentDistance < distances[nextX][nextY]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[nextX][nextY] = currentDistance;\n        } // If we found the target node then we return what we need\n\n\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrievePath(predecessor, startNode, endNode);\n          visited.shift(); // return the correct value\n\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n};\nexport const dijkstraWithWalls = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n        n = grid[0].length; // Initialize the distances array\n\n  const distances = [];\n\n  for (let i = 0; i < m; i++) {\n    distances.push([]);\n\n    for (let j = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0; // Initialize the predecessor array\n\n  const predecessor = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode; // Initialize the visited nodes array\n\n  let visited = [];\n  let index = 1; //   Initialize the Binary Heap\n\n  let pq = new BinaryHeap((a, b) => {\n    if (distances[a.x][a.y] != distances[b.x][b.y]) {\n      return distances[a.x][a.y] > distances[b.x][b.y];\n    }\n\n    return a.pqIndex > b.pqIndex;\n  });\n  startNode.pqIndex = index++;\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode = ensure(pq.pop()); // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n\n    visited.push(currentNode); // Get the coordinates of the nodes\n\n    let currentX = currentNode.x;\n    let currentY = currentNode.y; // Iterate the neighbors of the node\n\n    const neighbors = ensure(mazeGraph.get(pairGrid[currentX][currentY]));\n    neighbors.sort((a, b) => {\n      return a[0] - b[0];\n    });\n    console.log(neighbors);\n\n    for (const neighbor of ensure(mazeGraph.get(pairGrid[currentX][currentY]))) {\n      // Check if the coordinates are valid\n      if (neighbor[0] >= 0 && neighbor[0] < m && neighbor[1] >= 0 && neighbor[1] < n) {\n        let nextNode = grid[neighbor[0]][neighbor[1]]; // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n\n        if (!visited.find(currentNode => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          nextNode.pqIndex = index++;\n          pq.push(nextNode);\n        } // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n\n\n        let currentDistance = distances[currentX][currentY] + 1; // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n\n        if (currentDistance < distances[neighbor[0]][neighbor[1]]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[neighbor[0]][neighbor[1]] = currentDistance;\n        } // If we found the target node then we return what we need\n\n\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrievePath(predecessor, startNode, endNode);\n          visited.push(endNode);\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n}; // This function is here to ensure that a value is not undefined (especially when using arrays).\n\nfunction ensure(argument, message = \"This value was promised to be there.\") {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helper_functions/shortestPathAlgorithms/dijkstra.ts"],"names":["BinaryHeap","retrievePath","dijkstra","grid","startNode","endNode","m","length","n","distances","i","push","j","Number","MAX_SAFE_INTEGER","x","y","predecessor","fill","id","visited","directions","index","pq","a","b","pqIndex","size","currentNode","ensure","pop","currentX","currentY","dir","nextX","nextY","nextNode","find","remove","currentDistance","shortestPath","shift","dijkstraWithWalls","pairGrid","mazeGraph","neighbors","get","sort","console","log","neighbor","argument","message","undefined","TypeError"],"mappings":"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","sourcesContent":["import { node } from \"../usefulInterfaces\";\nimport { BinaryHeap } from \"../binaryHeap\";\nimport { retrievePath } from \"./retrievePath\";\n\nexport const dijkstra: (\n  grid: node[][],\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  // Initialize the directions array we will use to perform Dijkstra's algorithm\n  const directions: number[][] = [\n    [0, 1],\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n  ];\n\n  let index: number = 1;\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>((a: node, b: node) => {\n    if (distances[a.x][a.y] != distances[b.x][b.y]) {\n      return distances[a.x][a.y] < distances[b.x][b.y];\n    }\n    return a.pqIndex < b.pqIndex;\n  });\n  startNode.pqIndex = index++;\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n    visited.push(currentNode);\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const dir of directions) {\n      // Get the coordinates of the next node\n      let nextX: number = currentX + dir[0];\n      let nextY: number = currentY + dir[1];\n\n      // Check if the coordinates are valid\n      if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n) {\n        let nextNode: node = grid[nextX][nextY];\n\n        // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n        if (!visited.find((currentNode) => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          nextNode.pqIndex = index++;\n          pq.push(nextNode);\n        }\n\n        // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n        let currentDistance: number = distances[currentX][currentY] + 1;\n\n        // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n        if (currentDistance < distances[nextX][nextY]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[nextX][nextY] = currentDistance;\n        }\n\n        // If we found the target node then we return what we need\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrievePath(predecessor, startNode, endNode);\n          visited.shift();\n          // return the correct value\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n};\n\nexport const dijkstraWithWalls: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [number, number][]>,\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  let index: number = 1;\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>((a: node, b: node) => {\n    if (distances[a.x][a.y] != distances[b.x][b.y]) {\n      return distances[a.x][a.y] > distances[b.x][b.y];\n    }\n    return a.pqIndex > b.pqIndex;\n  });\n  startNode.pqIndex = index++;\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n    visited.push(currentNode);\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    const neighbors = ensure(mazeGraph.get(pairGrid[currentX][currentY]));\n    neighbors.sort((a: [number, number], b: [number, number]) => {\n      return a[0] - b[0];\n    });\n    console.log(neighbors);\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentX][currentY])\n    )) {\n      // Check if the coordinates are valid\n      if (\n        neighbor[0] >= 0 &&\n        neighbor[0] < m &&\n        neighbor[1] >= 0 &&\n        neighbor[1] < n\n      ) {\n        let nextNode: node = grid[neighbor[0]][neighbor[1]];\n\n        // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n        if (!visited.find((currentNode) => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          nextNode.pqIndex = index++;\n          pq.push(nextNode);\n        }\n\n        // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n        let currentDistance: number = distances[currentX][currentY] + 1;\n\n        // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n        if (currentDistance < distances[neighbor[0]][neighbor[1]]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[neighbor[0]][neighbor[1]] = currentDistance;\n        }\n\n        // If we found the target node then we return what we need\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrievePath(predecessor, startNode, endNode);\n          visited.push(endNode);\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n};\n\n// This function is here to ensure that a value is not undefined (especially when using arrays).\nfunction ensure<T>(\n  argument: T | undefined | null,\n  message: string = \"This value was promised to be there.\"\n): T {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}\n"]},"metadata":{},"sourceType":"module"}