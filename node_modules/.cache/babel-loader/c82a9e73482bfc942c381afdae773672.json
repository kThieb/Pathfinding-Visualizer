{"ast":null,"code":"import _classCallCheck from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import{ensure}from\"../ensureNotUndefined\";export var BinaryHeap=/*#__PURE__*/function(){function BinaryHeap(compare){_classCallCheck(this,BinaryHeap);this.content=void 0;this.compare=void 0;this.index=void 0;this.content=[];this.index=1;this.compare=compare;}_createClass(BinaryHeap,[{key:\"push\",value:function push(element){this.content.push([element,this.index++]);this.bubbleUp(this.content.length-1);}},{key:\"pop\",value:function pop(){var result=ensure(this.content[0]);var end=this.content.pop();if(this.content.length>0){this.content[0]=end;this.sinkDown(0);}return ensure(result)[0];}},{key:\"remove\",value:function remove(node){var length=this.content.length;// To remove a value, we must search through the array to find\n// it.\nfor(var i=0;i<length;i++){if(ensure(this.content[i])[0]!==node)continue;// When it is found, the process seen in 'pop' is repeated\n// to fill up the hole.\nvar end=this.content.pop();// If the element we popped was the one we needed to remove,\n// we're done.\nif(i===length-1)break;// Otherwise, we replace the removed element with the popped\n// one, and allow it to float up or sink down as appropriate.\nthis.content[i]=end;this.bubbleUp(i);this.sinkDown(i);break;}}},{key:\"size\",value:function size(){return this.content.length;}},{key:\"bubbleUp\",value:function bubbleUp(n){// Fetch the element that has to be moved.\nvar element=ensure(this.content[n]);// When at 0, an element can not go up any further.\nwhile(n>0){// Compute the parent element's index, and fetch it.\nvar parentN=Math.floor((n+1)/2)-1,parent=ensure(this.content[parentN]);// If the parent has a lesser score, things are in order and we\n// are done.\n// if (\n//   score > this.scoreFunction(ensure(parent)[0]) ||\n//   (score === this.scoreFunction(ensure(parent)[0]) &&\n//     ensure(element)[1] > ensure(parent)[1])\n// )\n//   break;\nif(this.compare(parent,element))break;// Otherwise, swap the parent with the current element and\n// continue.\nthis.content[parentN]=element;this.content[n]=parent;n=parentN;}}},{key:\"sinkDown\",value:function sinkDown(n){// Look up the target element and its score.\nvar length=this.content.length,element=ensure(this.content[n]);while(true){// Compute the indices of the child elements.\nvar child2N=(n+1)*2,child1N=child2N-1;var swap=n;// This is used to store the new position of the element, if any.\n// If the first child exists (is inside the array)...\nif(child1N<length&&this.compare(ensure(this.content[child1N]),element))swap=child1N;if(child2N<length&&this.compare(ensure(this.content[child2N]),ensure(this.content[swap])))swap=child2N;// If the order is good, we exit the loop\nif(swap===n)break;// Otherwise, swap and continue.\nthis.content[n]=this.content[swap];this.content[swap]=element;n=swap;}}}]);return BinaryHeap;}();","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helperFunctions/dataStructures/binaryHeap.ts"],"names":["ensure","BinaryHeap","compare","content","index","element","push","bubbleUp","length","result","end","pop","sinkDown","node","i","n","parentN","Math","floor","parent","child2N","child1N","swap"],"mappings":"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","sourcesContent":["import { ensure } from \"../ensureNotUndefined\";\n\nexport class BinaryHeap<T> {\n  content: ([T, number] | undefined)[];\n  compare: (a: [T, number], b: [T, number]) => boolean;\n  index: number;\n\n  constructor(compare: (a: [T, number], b: [T, number]) => boolean) {\n    this.content = [];\n    this.index = 1;\n    this.compare = compare;\n  }\n\n  push(element: T) {\n    this.content.push([element, this.index++]);\n    this.bubbleUp(this.content.length - 1);\n  }\n\n  pop(): T | undefined {\n    let result: [T, number] = ensure(this.content[0]);\n    let end: [T, number] | undefined = this.content.pop();\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n    return ensure(result)[0];\n  }\n\n  remove(node: T) {\n    let length: number = this.content.length;\n    // To remove a value, we must search through the array to find\n    // it.\n    for (let i: number = 0; i < length; i++) {\n      if (ensure(this.content[i])[0] !== node) continue;\n      // When it is found, the process seen in 'pop' is repeated\n      // to fill up the hole.\n      let end: [T, number] | undefined = this.content.pop();\n      // If the element we popped was the one we needed to remove,\n      // we're done.\n      if (i === length - 1) break;\n      // Otherwise, we replace the removed element with the popped\n      // one, and allow it to float up or sink down as appropriate.\n      this.content[i] = end;\n      this.bubbleUp(i);\n      this.sinkDown(i);\n      break;\n    }\n  }\n\n  size() {\n    return this.content.length;\n  }\n\n  private bubbleUp(n: number) {\n    // Fetch the element that has to be moved.\n    let element: [T, number] = ensure(this.content[n]);\n    // When at 0, an element can not go up any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      let parentN: number = Math.floor((n + 1) / 2) - 1,\n        parent: [T, number] = ensure(this.content[parentN]);\n      // If the parent has a lesser score, things are in order and we\n      // are done.\n      // if (\n      //   score > this.scoreFunction(ensure(parent)[0]) ||\n      //   (score === this.scoreFunction(ensure(parent)[0]) &&\n      //     ensure(element)[1] > ensure(parent)[1])\n      // )\n      //   break;\n      if (this.compare(parent, element)) break;\n\n      // Otherwise, swap the parent with the current element and\n      // continue.\n      this.content[parentN] = element;\n      this.content[n] = parent;\n      n = parentN;\n    }\n  }\n\n  private sinkDown(n: number) {\n    // Look up the target element and its score.\n    let length: number = this.content.length,\n      element: [T, number] = ensure(this.content[n]);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      let child2N: number = (n + 1) * 2,\n        child1N: number = child2N - 1;\n      let swap: number = n;\n      // This is used to store the new position of the element, if any.\n      // If the first child exists (is inside the array)...\n      if (\n        child1N < length &&\n        this.compare(ensure(this.content[child1N]), element)\n      )\n        swap = child1N;\n      if (\n        child2N < length &&\n        this.compare(ensure(this.content[child2N]), ensure(this.content[swap]))\n      )\n        swap = child2N;\n\n      // If the order is good, we exit the loop\n      if (swap === n) break;\n\n      // Otherwise, swap and continue.\n      this.content[n] = this.content[swap];\n      this.content[swap] = element;\n      n = swap;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}