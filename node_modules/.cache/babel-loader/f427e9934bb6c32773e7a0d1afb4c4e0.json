{"ast":null,"code":"import { BinaryHeap } from \"../binaryHeap\";\nimport { retrievePath } from \"./retrievePath\";\nexport const dijkstra = (grid, startNode, endNode) => {\n  const m = grid.length,\n        n = grid[0].length; // Initialize the distances array\n\n  const distances = [];\n\n  for (let i = 0; i < m; i++) {\n    distances.push([]);\n\n    for (let j = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0; // Initialize the predecessor array\n\n  const predecessor = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode; // Initialize the visited nodes array\n\n  let visited = []; // Initialize the directions array we will use to perform Dijkstra's algorithm\n\n  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n  let index = 1; //   Initialize the Binary Heap\n\n  let pq = new BinaryHeap((a, b) => {\n    const n1 = a[0],\n          n2 = b[0];\n\n    if (distances[n1.x][n1.y] != distances[n2.x][n2.y]) {\n      return distances[n1.x][n1.y] < distances[n2.x][n2.y];\n    }\n\n    return a[1] < b[1];\n  });\n  pq.push([startNode, index++]);\n\n  while (pq.size() > 0) {\n    let currentNode = ensure(pq.pop()); // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n\n    visited.push(currentNode); // Get the coordinates of the nodes\n\n    let currentX = currentNode.x;\n    let currentY = currentNode.y; // Iterate the neighbors of the node\n\n    for (const dir of directions) {\n      // Get the coordinates of the next node\n      let nextX = currentX + dir[0];\n      let nextY = currentY + dir[1]; // Check if the coordinates are valid\n\n      if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n) {\n        let nextNode = grid[nextX][nextY]; // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n\n        if (!visited.find(currentNode => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          pq.push(nextNode);\n        } // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n\n\n        let currentDistance = distances[currentX][currentY] + 1; // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n\n        if (currentDistance < distances[nextX][nextY]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[nextX][nextY] = currentDistance;\n        } // If we found the target node then we return what we need\n\n\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrievePath(predecessor, startNode, endNode);\n          visited.shift(); // return the correct value\n\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n};\nexport const dijkstraWithWalls = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n        n = grid[0].length; // Initialize the distances array\n\n  const distances = [];\n\n  for (let i = 0; i < m; i++) {\n    distances.push([]);\n\n    for (let j = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0; // Initialize the predecessor array\n\n  const predecessor = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode; // Initialize the visited nodes array\n\n  let visited = []; //   Initialize the Binary Heap\n\n  let pq = new BinaryHeap(n => distances[n.x][n.y]);\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode = ensure(pq.pop()); // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n\n    visited.push(currentNode); // Get the coordinates of the nodes\n\n    let currentX = currentNode.x;\n    let currentY = currentNode.y; // Iterate the neighbors of the node\n\n    for (const neighbor of ensure(mazeGraph.get(pairGrid[currentX][currentY]))) {\n      // Check if the coordinates are valid\n      if (neighbor[0] >= 0 && neighbor[0] < m && neighbor[1] >= 0 && neighbor[1] < n) {\n        let nextNode = grid[neighbor[0]][neighbor[1]]; // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n\n        if (!visited.find(currentNode => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          pq.push(nextNode);\n        } // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n\n\n        let currentDistance = distances[currentX][currentY] + 1; // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n\n        if (currentDistance < distances[neighbor[0]][neighbor[1]]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[neighbor[0]][neighbor[1]] = currentDistance;\n        } // If we found the target node then we return what we need\n\n\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrievePath(predecessor, startNode, endNode);\n          visited.push(endNode);\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n}; // This function is here to ensure that a value is not undefined (especially when using arrays).\n\nfunction ensure(argument, message = \"This value was promised to be there.\") {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helper_functions/shortestPathAlgorithms/dijkstra.ts"],"names":["BinaryHeap","retrievePath","dijkstra","grid","startNode","endNode","m","length","n","distances","i","push","j","Number","MAX_SAFE_INTEGER","x","y","predecessor","fill","id","visited","directions","index","pq","a","b","n1","n2","size","currentNode","ensure","pop","currentX","currentY","dir","nextX","nextY","nextNode","find","remove","currentDistance","shortestPath","shift","dijkstraWithWalls","pairGrid","mazeGraph","neighbor","get","argument","message","undefined","TypeError"],"mappings":"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","sourcesContent":["import { node } from \"../usefulInterfaces\";\nimport { BinaryHeap } from \"../binaryHeap\";\nimport { retrievePath } from \"./retrievePath\";\n\nexport const dijkstra: (\n  grid: node[][],\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  // Initialize the directions array we will use to perform Dijkstra's algorithm\n  const directions: number[][] = [\n    [0, 1],\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n  ];\n\n  let index: number = 1;\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<[node, number]> = new BinaryHeap<[node, number]>(\n    (a: [node, number], b: [node, number]) => {\n      const n1 = a[0],\n        n2 = b[0];\n      if (distances[n1.x][n1.y] != distances[n2.x][n2.y]) {\n        return distances[n1.x][n1.y] < distances[n2.x][n2.y];\n      }\n      return a[1] < b[1];\n    }\n  );\n  pq.push([startNode, index++]);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n    visited.push(currentNode);\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const dir of directions) {\n      // Get the coordinates of the next node\n      let nextX: number = currentX + dir[0];\n      let nextY: number = currentY + dir[1];\n\n      // Check if the coordinates are valid\n      if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n) {\n        let nextNode: node = grid[nextX][nextY];\n\n        // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n        if (!visited.find((currentNode) => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          pq.push(nextNode);\n        }\n\n        // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n        let currentDistance: number = distances[currentX][currentY] + 1;\n\n        // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n        if (currentDistance < distances[nextX][nextY]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[nextX][nextY] = currentDistance;\n        }\n\n        // If we found the target node then we return what we need\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrievePath(predecessor, startNode, endNode);\n          visited.shift();\n          // return the correct value\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n};\n\nexport const dijkstraWithWalls: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [number, number][]>,\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>(\n    (n: node) => distances[n.x][n.y]\n  );\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n    visited.push(currentNode);\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentX][currentY])\n    )) {\n      // Check if the coordinates are valid\n      if (\n        neighbor[0] >= 0 &&\n        neighbor[0] < m &&\n        neighbor[1] >= 0 &&\n        neighbor[1] < n\n      ) {\n        let nextNode: node = grid[neighbor[0]][neighbor[1]];\n\n        // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n        if (!visited.find((currentNode) => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          pq.push(nextNode);\n        }\n\n        // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n        let currentDistance: number = distances[currentX][currentY] + 1;\n\n        // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n        if (currentDistance < distances[neighbor[0]][neighbor[1]]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[neighbor[0]][neighbor[1]] = currentDistance;\n        }\n\n        // If we found the target node then we return what we need\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrievePath(predecessor, startNode, endNode);\n          visited.push(endNode);\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n};\n\n// This function is here to ensure that a value is not undefined (especially when using arrays).\nfunction ensure<T>(\n  argument: T | undefined | null,\n  message: string = \"This value was promised to be there.\"\n): T {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}\n"]},"metadata":{},"sourceType":"module"}