{"ast":null,"code":"import _objectSpread from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _slicedToArray from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import React,{useState}from\"react\";import\"./Visualizer.css\";import{Grid}from\"../Grid/Grid\";import{NavBar,NavItem,DropDownMenu,DropDownAlgo,DropDownSlider,NavButton}from\"../NavBar/NavBar\";import{algorithms}from\"../helper_functions/shortestPathAlgorithms/allAlgorithms\";import{generateMazeGraph,createEmptyMazeGraph}from\"../helper_functions/mazeGenerators/mazeGraph\";import{constructGrid}from\"../helper_functions/constructGrid\";var NUMBER_OF_ROWS=28;var NUMBER_OF_COLUMN=13;var VISITED_ANIMATION_TIMEOUT=35;var PATH_ANIMATION_TIMEOUT=75;// We define these constants out of the functional component\n// that the App uses to avoid re-running the functions to create\n// these each time there is a re-render\nvar _constructGrid=constructGrid(NUMBER_OF_ROWS,NUMBER_OF_COLUMN,[6,3],[6,24]),_constructGrid2=_slicedToArray(_constructGrid,3),firstGrid=_constructGrid2[0],firstStartNode=_constructGrid2[1],firstEndNode=_constructGrid2[2];var _createEmptyMazeGraph=createEmptyMazeGraph(NUMBER_OF_ROWS,NUMBER_OF_COLUMN,firstGrid),_createEmptyMazeGraph2=_slicedToArray(_createEmptyMazeGraph,2),firstpairGrid=_createEmptyMazeGraph2[0],mazeGraph=_createEmptyMazeGraph2[1];// Component rendering everything in the webpage.\nvar Visualizer=function Visualizer(){// States managing the grid\nvar _useState=useState(firstGrid),_useState2=_slicedToArray(_useState,2),grid=_useState2[0],setGrid=_useState2[1];var _useState3=useState(mazeGraph),_useState4=_slicedToArray(_useState3,2),maze=_useState4[0],setMaze=_useState4[1];var _useState5=useState(firstpairGrid),_useState6=_slicedToArray(_useState5,2),pairGrid=_useState6[0],setPairGrid=_useState6[1];var _useState7=useState(\"Dijkstra's algorithm\"),_useState8=_slicedToArray(_useState7,2),algorithm=_useState8[0],setAlgorithm=_useState8[1];var _useState9=useState(0.5),_useState10=_slicedToArray(_useState9,2),wallsDensity=_useState10[0],setWallsDensity=_useState10[1];var _useState11=useState(0),_useState12=_slicedToArray(_useState11,2),isVisualized=_useState12[0],setIsVisualized=_useState12[1];// const [mouseIsPressed, setMouseIsPressed] = useState(false);\n// States of the start and end node\nvar _useState13=useState(firstStartNode),_useState14=_slicedToArray(_useState13,2),startNode=_useState14[0],setStartNode=_useState14[1];var _useState15=useState(firstEndNode),_useState16=_slicedToArray(_useState15,2),endNode=_useState16[0],setEndNode=_useState16[1];// This function is there to visualize the algorithm chosen in the drop down menu\nvar visualizeAlgorithm=function visualizeAlgorithm(visited,path){var n=visited.length;var _loop=function _loop(i){setTimeout(function(){var newGrid=grid.slice();var node=visited[i];// define the x and y of the current node\nvar x=node.x;var y=node.y;var newNode=_objectSpread(_objectSpread({},node),{},{isVisited:true});newGrid[x][y]=newNode;setGrid(newGrid);},VISITED_ANIMATION_TIMEOUT*i);};for(var i=0;i<n;i++){_loop(i);}var m=path.length;var _loop2=function _loop2(_i){setTimeout(function(){var newGrid=grid.slice();var node=path[_i];// define the x and y of the current node\nvar x=node.x;var y=node.y;var newNode=_objectSpread(_objectSpread({},node),{},{isVisited:false,isShortestPath:true});newGrid[x][y]=newNode;setGrid(newGrid);},VISITED_ANIMATION_TIMEOUT*n+PATH_ANIMATION_TIMEOUT*_i);};for(var _i=0;_i<m;_i++){_loop2(_i);}};// This function is passed to the drop down menu to handle the change of algorithm\nvar handleAlgorithmChange=function handleAlgorithmChange(algorithmName){setAlgorithm(algorithmName);};// This function changes the algorithm that will be run, at the moment only dijkstra is implemented\nvar chooseAlgorithm=function chooseAlgorithm(){return algorithms[algorithm];};var handleVisualization=function handleVisualization(){if(isVisualized===0){setIsVisualized(1);var _chooseAlgorithm=chooseAlgorithm()(grid,pairGrid,maze,startNode,endNode),_chooseAlgorithm2=_slicedToArray(_chooseAlgorithm,2),_visited=_chooseAlgorithm2[0],_path=_chooseAlgorithm2[1];var n=_visited.length,m=_path.length;visualizeAlgorithm(_visited,_path);setTimeout(function(){setIsVisualized(2);},VISITED_ANIMATION_TIMEOUT*n+PATH_ANIMATION_TIMEOUT*m);}};// This function calls the generate maze function\nvar generateMaze=function generateMaze(){if(isVisualized===0){var newGrid=grid.slice();var _generateMazeGraph=generateMazeGraph(NUMBER_OF_ROWS,NUMBER_OF_COLUMN,newGrid,wallsDensity),_generateMazeGraph2=_slicedToArray(_generateMazeGraph,2),newPairGrid=_generateMazeGraph2[0],newMaze=_generateMazeGraph2[1];setGrid(newGrid);setPairGrid(newPairGrid);setMaze(newMaze);}};// Reinitialize the the board\nvar reinitialize=function reinitialize(){if(isVisualized===2){var _constructGrid3=constructGrid(NUMBER_OF_ROWS,NUMBER_OF_COLUMN,[startNode.x,startNode.y],[endNode.x,endNode.y]),_constructGrid4=_slicedToArray(_constructGrid3,3),newGrid=_constructGrid4[0],newStartNode=_constructGrid4[1],newEndNode=_constructGrid4[2];var _createEmptyMazeGraph3=createEmptyMazeGraph(NUMBER_OF_ROWS,NUMBER_OF_COLUMN,newGrid),_createEmptyMazeGraph4=_slicedToArray(_createEmptyMazeGraph3,2),newPairGrid=_createEmptyMazeGraph4[0],newMaze=_createEmptyMazeGraph4[1];setGrid(newGrid);setPairGrid(newPairGrid);setMaze(newMaze);setStartNode(newStartNode);setEndNode(newEndNode);setIsVisualized(0);}};// The following block of functions handles the making of walls in the grid\n// This feature is currently not used as it is not a good fit with the current direction of the app\n// const toggleWall: (x: number, y: number) => void = (x, y) => {\n//   const newGrid: node[][] = grid.slice();\n//   let newNode;\n//   if (!newGrid[x][y].isWall) {\n//     newNode = {\n//       ...newGrid[x][y],\n//       isWall: !newGrid[x][y].isWall,\n//       className: \"grid-node wall-node\",\n//     };\n//   } else {\n//     newNode = {\n//       ...newGrid[x][y],\n//       isWall: !newGrid[x][y].isWall,\n//       className: \"grid-node\",\n//     };\n//   }\n//   newGrid[x][y] = newNode;\n//   setGrid(newGrid);\n// };\n// // handles the case when the mouse button is down\n// const handleMouseDown: (x: number, y: number) => void = (x, y) => {\n//   toggleWall(x, y);\n//   setMouseIsPressed(false);\n// };\n// // handles the case whan the mouse button is down and you enter a node\n// const handleMouseEnter: (x: number, y: number) => void = (x, y) => {\n//   if (mouseIsPressed) {\n//     toggleWall(x, y);\n//   }\n// };\n// // handles the case when you mouse up\n// const handleMouseUp: () => void = () => {\n//   setMouseIsPressed(false);\n// };\n// Render the app\nreturn/*#__PURE__*/React.createElement(\"div\",{className:\"App\"},/*#__PURE__*/React.createElement(NavBar,null,/*#__PURE__*/React.createElement(NavButton,{text:\"Reinitialize\",isVisualized:isVisualized,className:\"reinitialize\",startClassName:\"greyed-out\",visualizingClassName:\"greyed-out\",visualizedClassName:\"highlight\",handleClick:reinitialize}),/*#__PURE__*/React.createElement(NavButton,{text:\"Generate Maze\",isVisualized:isVisualized,className:\"generate-maze\",visualizingClassName:\"greyed-out\",visualizedClassName:\"greyed-out\",handleClick:generateMaze}),/*#__PURE__*/React.createElement(NavItem,{text:\"Maze options\",id:\"maze-options\",isVisualized:isVisualized,shouldGreyOut:true},/*#__PURE__*/React.createElement(DropDownMenu,null,/*#__PURE__*/React.createElement(DropDownSlider,{text:\"Density of walls\",minValue:0.1,maxValue:1,defaultValue:wallsDensity,handleChange:setWallsDensity}))),/*#__PURE__*/React.createElement(NavButton,{text:\"Visualize \"+algorithm+\"!\",isVisualized:isVisualized,className:\"visualize-button\",visualizingClassName:\"greyed-out\",visualizedClassName:\"greyed-out\",handleClick:handleVisualization}),/*#__PURE__*/React.createElement(NavItem,{text:\"Algorithms\",id:\"algorithms\",isVisualized:isVisualized,shouldGreyOut:false},/*#__PURE__*/React.createElement(DropDownMenu,null,/*#__PURE__*/React.createElement(DropDownAlgo,{changeAlgorithm:handleAlgorithmChange,algorithmName:\"Depth First Search\"},/*#__PURE__*/React.createElement(\"p\",null,\"Depth First Search\"),algorithm===\"Depth First Search\"?/*#__PURE__*/React.createElement(\"p\",null,\"\\u2713\"):\"\"),/*#__PURE__*/React.createElement(DropDownAlgo,{changeAlgorithm:handleAlgorithmChange,algorithmName:\"Breadth First Search\"},/*#__PURE__*/React.createElement(\"p\",null,\"Breadth First Search\"),algorithm===\"Breadth First Search\"?/*#__PURE__*/React.createElement(\"p\",null,\"\\u2713\"):\"\"),/*#__PURE__*/React.createElement(DropDownAlgo,{changeAlgorithm:handleAlgorithmChange,algorithmName:\"Dijkstra's algorithm\"},/*#__PURE__*/React.createElement(\"p\",null,\"Dijkstra's Algorithm\"),algorithm===\"Dijkstra's algorithm\"?/*#__PURE__*/React.createElement(\"p\",null,\"\\u2713\"):\"\")))),/*#__PURE__*/React.createElement(Grid,{grid:grid,pairGrid:pairGrid,maze:maze}));};export default Visualizer;","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/Visualizer/Visualizer.tsx"],"names":["React","useState","Grid","NavBar","NavItem","DropDownMenu","DropDownAlgo","DropDownSlider","NavButton","algorithms","generateMazeGraph","createEmptyMazeGraph","constructGrid","NUMBER_OF_ROWS","NUMBER_OF_COLUMN","VISITED_ANIMATION_TIMEOUT","PATH_ANIMATION_TIMEOUT","firstGrid","firstStartNode","firstEndNode","firstpairGrid","mazeGraph","Visualizer","grid","setGrid","maze","setMaze","pairGrid","setPairGrid","algorithm","setAlgorithm","wallsDensity","setWallsDensity","isVisualized","setIsVisualized","startNode","setStartNode","endNode","setEndNode","visualizeAlgorithm","visited","path","n","length","i","setTimeout","newGrid","slice","node","x","y","newNode","isVisited","m","isShortestPath","handleAlgorithmChange","algorithmName","chooseAlgorithm","handleVisualization","generateMaze","newPairGrid","newMaze","reinitialize","newStartNode","newEndNode"],"mappings":"2XAAA,MAAOA,CAAAA,KAAP,EAAgBC,QAAhB,KAAgC,OAAhC,CACA,MAAO,kBAAP,CACA,OAASC,IAAT,KAAqB,cAArB,CACA,OACEC,MADF,CAEEC,OAFF,CAGEC,YAHF,CAIEC,YAJF,CAKEC,cALF,CAMEC,SANF,KAOO,kBAPP,CASA,OAASC,UAAT,KAA2B,0DAA3B,CACA,OACEC,iBADF,CAEEC,oBAFF,KAGO,8CAHP,CAIA,OAASC,aAAT,KAA8B,mCAA9B,CAEA,GAAMC,CAAAA,cAAsB,CAAG,EAA/B,CACA,GAAMC,CAAAA,gBAAwB,CAAG,EAAjC,CACA,GAAMC,CAAAA,yBAAiC,CAAG,EAA1C,CACA,GAAMC,CAAAA,sBAA8B,CAAG,EAAvC,CAEA;AACA;AACA;mBACkDJ,aAAa,CAC7DC,cAD6D,CAE7DC,gBAF6D,CAG7D,CAAC,CAAD,CAAI,CAAJ,CAH6D,CAI7D,CAAC,CAAD,CAAI,EAAJ,CAJ6D,C,kDAAxDG,S,oBAAWC,c,oBAAgBC,Y,8CAOCR,oBAAoB,CACrDE,cADqD,CAErDC,gBAFqD,CAGrDG,SAHqD,C,gEAAhDG,a,2BAAeC,S,2BAMtB;AACA,GAAMC,CAAAA,UAAoB,CAAG,QAAvBA,CAAAA,UAAuB,EAAM,CACjC;AADiC,cAETrB,QAAQ,CAACgB,SAAD,CAFC,wCAE1BM,IAF0B,eAEpBC,OAFoB,8BAGTvB,QAAQ,CAACoB,SAAD,CAHC,yCAG1BI,IAH0B,eAGpBC,OAHoB,8BAIDzB,QAAQ,CAACmB,aAAD,CAJP,yCAI1BO,QAJ0B,eAIhBC,WAJgB,8BAKC3B,QAAQ,CAAC,sBAAD,CALT,yCAK1B4B,SAL0B,eAKfC,YALe,8BAMO7B,QAAQ,CAAC,GAAD,CANf,0CAM1B8B,YAN0B,gBAMZC,eANY,gCAOO/B,QAAQ,CAAC,CAAD,CAPf,2CAO1BgC,YAP0B,gBAOZC,eAPY,gBAQjC;AAEA;AAViC,gBAWCjC,QAAQ,CAACiB,cAAD,CAXT,2CAW1BiB,SAX0B,gBAWfC,YAXe,gCAYHnC,QAAQ,CAACkB,YAAD,CAZL,2CAY1BkB,OAZ0B,gBAYjBC,UAZiB,gBAcjC;AACA,GAAMC,CAAAA,kBAA2D,CAAG,QAA9DA,CAAAA,kBAA8D,CAClEC,OADkE,CAElEC,IAFkE,CAG/D,CACH,GAAMC,CAAAA,CAAC,CAAGF,OAAO,CAACG,MAAlB,CADG,yBAEMC,CAFN,EAGDC,UAAU,CAAC,UAAM,CACf,GAAMC,CAAAA,OAAO,CAAGvB,IAAI,CAACwB,KAAL,EAAhB,CACA,GAAMC,CAAAA,IAAI,CAAGR,OAAO,CAACI,CAAD,CAApB,CACA;AACA,GAAMK,CAAAA,CAAS,CAAGD,IAAI,CAACC,CAAvB,CACA,GAAMC,CAAAA,CAAS,CAAGF,IAAI,CAACE,CAAvB,CACA,GAAMC,CAAAA,OAAa,gCACdH,IADc,MAEjBI,SAAS,CAAE,IAFM,EAAnB,CAIAN,OAAO,CAACG,CAAD,CAAP,CAAWC,CAAX,EAAgBC,OAAhB,CACA3B,OAAO,CAACsB,OAAD,CAAP,CACD,CAZS,CAYP/B,yBAAyB,CAAG6B,CAZrB,CAAV,CAHC,EAEH,IAAK,GAAIA,CAAAA,CAAS,CAAG,CAArB,CAAwBA,CAAC,CAAGF,CAA5B,CAA+BE,CAAC,EAAhC,CAAoC,OAA3BA,CAA2B,EAcnC,CAED,GAAMS,CAAAA,CAAC,CAAGZ,IAAI,CAACE,MAAf,CAlBG,2BAmBMC,EAnBN,EAoBDC,UAAU,CAAC,UAAM,CACf,GAAMC,CAAAA,OAAO,CAAGvB,IAAI,CAACwB,KAAL,EAAhB,CACA,GAAMC,CAAAA,IAAI,CAAGP,IAAI,CAACG,EAAD,CAAjB,CACA;AACA,GAAMK,CAAAA,CAAS,CAAGD,IAAI,CAACC,CAAvB,CACA,GAAMC,CAAAA,CAAS,CAAGF,IAAI,CAACE,CAAvB,CACA,GAAMC,CAAAA,OAAa,gCACdH,IADc,MAEjBI,SAAS,CAAE,KAFM,CAGjBE,cAAc,CAAE,IAHC,EAAnB,CAKAR,OAAO,CAACG,CAAD,CAAP,CAAWC,CAAX,EAAgBC,OAAhB,CACA3B,OAAO,CAACsB,OAAD,CAAP,CACD,CAbS,CAaP/B,yBAAyB,CAAG2B,CAA5B,CAAgC1B,sBAAsB,CAAG4B,EAblD,CAAV,CApBC,EAmBH,IAAK,GAAIA,CAAAA,EAAS,CAAG,CAArB,CAAwBA,EAAC,CAAGS,CAA5B,CAA+BT,EAAC,EAAhC,CAAoC,QAA3BA,EAA2B,EAenC,CACF,CAtCD,CAwCA;AACA,GAAMW,CAAAA,qBAAsD,CAAG,QAAzDA,CAAAA,qBAAyD,CAC7DC,aAD6D,CAE1D,CACH1B,YAAY,CAAC0B,aAAD,CAAZ,CACD,CAJD,CAMA;AACA,GAAMC,CAAAA,eAMe,CAAG,QANlBA,CAAAA,eAMkB,EAAM,CAC5B,MAAOhD,CAAAA,UAAU,CAACoB,SAAD,CAAjB,CACD,CARD,CAUA,GAAM6B,CAAAA,mBAA+B,CAAG,QAAlCA,CAAAA,mBAAkC,EAAM,CAC5C,GAAIzB,YAAY,GAAK,CAArB,CAAwB,CACtBC,eAAe,CAAC,CAAD,CAAf,CADsB,qBAEoBuB,eAAe,GACvDlC,IADuD,CAEvDI,QAFuD,CAGvDF,IAHuD,CAIvDU,SAJuD,CAKvDE,OALuD,CAFnC,sDAEfG,QAFe,sBAENC,KAFM,sBAStB,GAAMC,CAAAA,CAAS,CAAGF,QAAO,CAACG,MAA1B,CACEU,CAAS,CAAGZ,KAAI,CAACE,MADnB,CAEAJ,kBAAkB,CAACC,QAAD,CAAUC,KAAV,CAAlB,CACAI,UAAU,CAAC,UAAM,CACfX,eAAe,CAAC,CAAD,CAAf,CACD,CAFS,CAEPnB,yBAAyB,CAAG2B,CAA5B,CAAgC1B,sBAAsB,CAAGqC,CAFlD,CAAV,CAGD,CACF,CAjBD,CAmBA;AACA,GAAMM,CAAAA,YAAwB,CAAG,QAA3BA,CAAAA,YAA2B,EAAM,CACrC,GAAI1B,YAAY,GAAK,CAArB,CAAwB,CACtB,GAAMa,CAAAA,OAAO,CAAGvB,IAAI,CAACwB,KAAL,EAAhB,CADsB,uBAESrC,iBAAiB,CAC9CG,cAD8C,CAE9CC,gBAF8C,CAG9CgC,OAH8C,CAI9Cf,YAJ8C,CAF1B,0DAEf6B,WAFe,wBAEFC,OAFE,wBAQtBrC,OAAO,CAACsB,OAAD,CAAP,CACAlB,WAAW,CAACgC,WAAD,CAAX,CACAlC,OAAO,CAACmC,OAAD,CAAP,CACD,CACF,CAbD,CAeA;AACA,GAAMC,CAAAA,YAAwB,CAAG,QAA3BA,CAAAA,YAA2B,EAAM,CACrC,GAAI7B,YAAY,GAAK,CAArB,CAAwB,qBACsBrB,aAAa,CACvDC,cADuD,CAEvDC,gBAFuD,CAGvD,CAACqB,SAAS,CAACc,CAAX,CAAcd,SAAS,CAACe,CAAxB,CAHuD,CAIvD,CAACb,OAAO,CAACY,CAAT,CAAYZ,OAAO,CAACa,CAApB,CAJuD,CADnC,mDACfJ,OADe,oBACNiB,YADM,oBACQC,UADR,+CAOSrD,oBAAoB,CACjDE,cADiD,CAEjDC,gBAFiD,CAGjDgC,OAHiD,CAP7B,iEAOfc,WAPe,2BAOFC,OAPE,2BAYtBrC,OAAO,CAACsB,OAAD,CAAP,CACAlB,WAAW,CAACgC,WAAD,CAAX,CACAlC,OAAO,CAACmC,OAAD,CAAP,CACAzB,YAAY,CAAC2B,YAAD,CAAZ,CACAzB,UAAU,CAAC0B,UAAD,CAAV,CACA9B,eAAe,CAAC,CAAD,CAAf,CACD,CACF,CApBD,CAsBA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA,mBACE,2BAAK,SAAS,CAAC,KAAf,eACE,oBAAC,MAAD,mBACE,oBAAC,SAAD,EACE,IAAI,CAAC,cADP,CAEE,YAAY,CAAED,YAFhB,CAGE,SAAS,CAAC,cAHZ,CAIE,cAAc,CAAC,YAJjB,CAKE,oBAAoB,CAAC,YALvB,CAME,mBAAmB,CAAC,WANtB,CAOE,WAAW,CAAE6B,YAPf,EADF,cAUE,oBAAC,SAAD,EACE,IAAI,CAAC,eADP,CAEE,YAAY,CAAE7B,YAFhB,CAGE,SAAS,CAAC,eAHZ,CAIE,oBAAoB,CAAC,YAJvB,CAKE,mBAAmB,CAAC,YALtB,CAME,WAAW,CAAE0B,YANf,EAVF,cAkBE,oBAAC,OAAD,EACE,IAAI,CAAC,cADP,CAEE,EAAE,CAAC,cAFL,CAGE,YAAY,CAAE1B,YAHhB,CAIE,aAAa,CAAE,IAJjB,eAME,oBAAC,YAAD,mBACE,oBAAC,cAAD,EACE,IAAI,CAAC,kBADP,CAEE,QAAQ,CAAE,GAFZ,CAGE,QAAQ,CAAE,CAHZ,CAIE,YAAY,CAAEF,YAJhB,CAKE,YAAY,CAAEC,eALhB,EADF,CANF,CAlBF,cAkCE,oBAAC,SAAD,EACE,IAAI,CAAE,aAAeH,SAAf,CAA2B,GADnC,CAEE,YAAY,CAAEI,YAFhB,CAGE,SAAS,CAAC,kBAHZ,CAIE,oBAAoB,CAAC,YAJvB,CAKE,mBAAmB,CAAC,YALtB,CAME,WAAW,CAAEyB,mBANf,EAlCF,cA0CE,oBAAC,OAAD,EACE,IAAI,CAAC,YADP,CAEE,EAAE,CAAC,YAFL,CAGE,YAAY,CAAEzB,YAHhB,CAIE,aAAa,CAAE,KAJjB,eAME,oBAAC,YAAD,mBACE,oBAAC,YAAD,EACE,eAAe,CAAEsB,qBADnB,CAEE,aAAa,CAAC,oBAFhB,eAIE,kDAJF,CAKG1B,SAAS,GAAK,oBAAd,cAAqC,sCAArC,CAAgD,EALnD,CADF,cAQE,oBAAC,YAAD,EACE,eAAe,CAAE0B,qBADnB,CAEE,aAAa,CAAC,sBAFhB,eAIE,oDAJF,CAKG1B,SAAS,GAAK,sBAAd,cAAuC,sCAAvC,CAAkD,EALrD,CARF,cAeE,oBAAC,YAAD,EACE,eAAe,CAAE0B,qBADnB,CAEE,aAAa,CAAC,sBAFhB,eAIE,oDAJF,CAKG1B,SAAS,GAAK,sBAAd,cAAuC,sCAAvC,CAAkD,EALrD,CAfF,CANF,CA1CF,CADF,cA4FE,oBAAC,IAAD,EAAM,IAAI,CAAEN,IAAZ,CAAkB,QAAQ,CAAEI,QAA5B,CAAsC,IAAI,CAAEF,IAA5C,EA5FF,CADF,CAgGD,CA7QD,CA+QA,cAAeH,CAAAA,UAAf","sourcesContent":["import React, { useState } from \"react\";\nimport \"./Visualizer.css\";\nimport { Grid } from \"../Grid/Grid\";\nimport {\n  NavBar,\n  NavItem,\n  DropDownMenu,\n  DropDownAlgo,\n  DropDownSlider,\n  NavButton,\n} from \"../NavBar/NavBar\";\nimport { node } from \"../helper_functions/usefulInterfaces\";\nimport { algorithms } from \"../helper_functions/shortestPathAlgorithms/allAlgorithms\";\nimport {\n  generateMazeGraph,\n  createEmptyMazeGraph,\n} from \"../helper_functions/mazeGenerators/mazeGraph\";\nimport { constructGrid } from \"../helper_functions/constructGrid\";\n\nconst NUMBER_OF_ROWS: number = 28;\nconst NUMBER_OF_COLUMN: number = 13;\nconst VISITED_ANIMATION_TIMEOUT: number = 35;\nconst PATH_ANIMATION_TIMEOUT: number = 75;\n\n// We define these constants out of the functional component\n// that the App uses to avoid re-running the functions to create\n// these each time there is a re-render\nconst [firstGrid, firstStartNode, firstEndNode] = constructGrid(\n  NUMBER_OF_ROWS,\n  NUMBER_OF_COLUMN,\n  [6, 3],\n  [6, 24]\n);\n\nconst [firstpairGrid, mazeGraph] = createEmptyMazeGraph(\n  NUMBER_OF_ROWS,\n  NUMBER_OF_COLUMN,\n  firstGrid\n);\n\n// Component rendering everything in the webpage.\nconst Visualizer: React.FC = () => {\n  // States managing the grid\n  const [grid, setGrid] = useState(firstGrid);\n  const [maze, setMaze] = useState(mazeGraph);\n  const [pairGrid, setPairGrid] = useState(firstpairGrid);\n  const [algorithm, setAlgorithm] = useState(\"Dijkstra's algorithm\");\n  const [wallsDensity, setWallsDensity] = useState(0.5);\n  const [isVisualized, setIsVisualized] = useState(0);\n  // const [mouseIsPressed, setMouseIsPressed] = useState(false);\n\n  // States of the start and end node\n  const [startNode, setStartNode] = useState(firstStartNode);\n  const [endNode, setEndNode] = useState(firstEndNode);\n\n  // This function is there to visualize the algorithm chosen in the drop down menu\n  const visualizeAlgorithm: (visited: node[], path: node[]) => void = (\n    visited,\n    path\n  ) => {\n    const n = visited.length;\n    for (let i: number = 0; i < n; i++) {\n      setTimeout(() => {\n        const newGrid = grid.slice();\n        const node = visited[i];\n        // define the x and y of the current node\n        const x: number = node.x;\n        const y: number = node.y;\n        const newNode: node = {\n          ...node,\n          isVisited: true,\n        };\n        newGrid[x][y] = newNode;\n        setGrid(newGrid);\n      }, VISITED_ANIMATION_TIMEOUT * i);\n    }\n\n    const m = path.length;\n    for (let i: number = 0; i < m; i++) {\n      setTimeout(() => {\n        const newGrid = grid.slice();\n        const node = path[i];\n        // define the x and y of the current node\n        const x: number = node.x;\n        const y: number = node.y;\n        const newNode: node = {\n          ...node,\n          isVisited: false,\n          isShortestPath: true,\n        };\n        newGrid[x][y] = newNode;\n        setGrid(newGrid);\n      }, VISITED_ANIMATION_TIMEOUT * n + PATH_ANIMATION_TIMEOUT * i);\n    }\n  };\n\n  // This function is passed to the drop down menu to handle the change of algorithm\n  const handleAlgorithmChange: (algorithmName: string) => void = (\n    algorithmName\n  ) => {\n    setAlgorithm(algorithmName);\n  };\n\n  // This function changes the algorithm that will be run, at the moment only dijkstra is implemented\n  const chooseAlgorithm: () => (\n    grid: node[][],\n    pairGrid: [number, number][][],\n    mazeGraph: Map<[number, number], [number, number][]>,\n    startNode: node,\n    endNode: node\n  ) => [node[], node[]] = () => {\n    return algorithms[algorithm];\n  };\n\n  const handleVisualization: () => void = () => {\n    if (isVisualized === 0) {\n      setIsVisualized(1);\n      const [visited, path]: [node[], node[]] = chooseAlgorithm()(\n        grid,\n        pairGrid,\n        maze,\n        startNode,\n        endNode\n      );\n      const n: number = visited.length,\n        m: number = path.length;\n      visualizeAlgorithm(visited, path);\n      setTimeout(() => {\n        setIsVisualized(2);\n      }, VISITED_ANIMATION_TIMEOUT * n + PATH_ANIMATION_TIMEOUT * m);\n    }\n  };\n\n  // This function calls the generate maze function\n  const generateMaze: () => void = () => {\n    if (isVisualized === 0) {\n      const newGrid = grid.slice();\n      const [newPairGrid, newMaze] = generateMazeGraph(\n        NUMBER_OF_ROWS,\n        NUMBER_OF_COLUMN,\n        newGrid,\n        wallsDensity\n      );\n      setGrid(newGrid);\n      setPairGrid(newPairGrid);\n      setMaze(newMaze);\n    }\n  };\n\n  // Reinitialize the the board\n  const reinitialize: () => void = () => {\n    if (isVisualized === 2) {\n      const [newGrid, newStartNode, newEndNode] = constructGrid(\n        NUMBER_OF_ROWS,\n        NUMBER_OF_COLUMN,\n        [startNode.x, startNode.y],\n        [endNode.x, endNode.y]\n      );\n      const [newPairGrid, newMaze] = createEmptyMazeGraph(\n        NUMBER_OF_ROWS,\n        NUMBER_OF_COLUMN,\n        newGrid\n      );\n      setGrid(newGrid);\n      setPairGrid(newPairGrid);\n      setMaze(newMaze);\n      setStartNode(newStartNode);\n      setEndNode(newEndNode);\n      setIsVisualized(0);\n    }\n  };\n\n  // The following block of functions handles the making of walls in the grid\n  // This feature is currently not used as it is not a good fit with the current direction of the app\n\n  // const toggleWall: (x: number, y: number) => void = (x, y) => {\n  //   const newGrid: node[][] = grid.slice();\n  //   let newNode;\n  //   if (!newGrid[x][y].isWall) {\n  //     newNode = {\n  //       ...newGrid[x][y],\n  //       isWall: !newGrid[x][y].isWall,\n  //       className: \"grid-node wall-node\",\n  //     };\n  //   } else {\n  //     newNode = {\n  //       ...newGrid[x][y],\n  //       isWall: !newGrid[x][y].isWall,\n  //       className: \"grid-node\",\n  //     };\n  //   }\n  //   newGrid[x][y] = newNode;\n  //   setGrid(newGrid);\n  // };\n\n  // // handles the case when the mouse button is down\n  // const handleMouseDown: (x: number, y: number) => void = (x, y) => {\n  //   toggleWall(x, y);\n  //   setMouseIsPressed(false);\n  // };\n\n  // // handles the case whan the mouse button is down and you enter a node\n  // const handleMouseEnter: (x: number, y: number) => void = (x, y) => {\n  //   if (mouseIsPressed) {\n  //     toggleWall(x, y);\n  //   }\n  // };\n\n  // // handles the case when you mouse up\n  // const handleMouseUp: () => void = () => {\n  //   setMouseIsPressed(false);\n  // };\n\n  // Render the app\n  return (\n    <div className=\"App\">\n      <NavBar>\n        <NavButton\n          text=\"Reinitialize\"\n          isVisualized={isVisualized}\n          className=\"reinitialize\"\n          startClassName=\"greyed-out\"\n          visualizingClassName=\"greyed-out\"\n          visualizedClassName=\"highlight\"\n          handleClick={reinitialize}\n        />\n        <NavButton\n          text=\"Generate Maze\"\n          isVisualized={isVisualized}\n          className=\"generate-maze\"\n          visualizingClassName=\"greyed-out\"\n          visualizedClassName=\"greyed-out\"\n          handleClick={generateMaze}\n        />\n        <NavItem\n          text=\"Maze options\"\n          id=\"maze-options\"\n          isVisualized={isVisualized}\n          shouldGreyOut={true}\n        >\n          <DropDownMenu>\n            <DropDownSlider\n              text=\"Density of walls\"\n              minValue={0.1}\n              maxValue={1}\n              defaultValue={wallsDensity}\n              handleChange={setWallsDensity}\n            ></DropDownSlider>\n          </DropDownMenu>\n        </NavItem>\n        <NavButton\n          text={\"Visualize \" + algorithm + \"!\"}\n          isVisualized={isVisualized}\n          className=\"visualize-button\"\n          visualizingClassName=\"greyed-out\"\n          visualizedClassName=\"greyed-out\"\n          handleClick={handleVisualization}\n        />\n        <NavItem\n          text=\"Algorithms\"\n          id=\"algorithms\"\n          isVisualized={isVisualized}\n          shouldGreyOut={false}\n        >\n          <DropDownMenu>\n            <DropDownAlgo\n              changeAlgorithm={handleAlgorithmChange}\n              algorithmName=\"Depth First Search\"\n            >\n              <p>Depth First Search</p>\n              {algorithm === \"Depth First Search\" ? <p>✓</p> : \"\"}\n            </DropDownAlgo>\n            <DropDownAlgo\n              changeAlgorithm={handleAlgorithmChange}\n              algorithmName=\"Breadth First Search\"\n            >\n              <p>Breadth First Search</p>\n              {algorithm === \"Breadth First Search\" ? <p>✓</p> : \"\"}\n            </DropDownAlgo>\n            <DropDownAlgo\n              changeAlgorithm={handleAlgorithmChange}\n              algorithmName=\"Dijkstra's algorithm\"\n            >\n              <p>Dijkstra's Algorithm</p>\n              {algorithm === \"Dijkstra's algorithm\" ? <p>✓</p> : \"\"}\n            </DropDownAlgo>\n          </DropDownMenu>\n        </NavItem>\n      </NavBar>\n      {/* <SecondaryHeader>\n        <button\n          className=\"visualize-button\"\n          onClick={(e) => {\n            visualizeAlgorithm(\n              ...chooseAlgorithm(algorithm)(\n                grid,\n                pairGrid,\n                mazeGraph,\n                startNode,\n                endNode\n              )\n            );\n          }}\n        >\n          Visualize the path!\n        </button>\n      </SecondaryHeader> */}\n      <Grid grid={grid} pairGrid={pairGrid} maze={maze} />\n    </div>\n  );\n};\n\nexport default Visualizer;\n"]},"metadata":{},"sourceType":"module"}