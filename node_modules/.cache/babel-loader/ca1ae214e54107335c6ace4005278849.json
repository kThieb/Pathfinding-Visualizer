{"ast":null,"code":"import _slicedToArray from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";// TODO: Refactor the code to use the different key-values pair as the nodes get changed when there is a setGrid that is applied\nvar createMazeGraph=function createMazeGraph(rowLength,columnLength,grid){var pairGrid=[];for(var i=0;i<columnLength;i++){var pairRow=[];for(var j=0;j<rowLength;j++){var _currentNode=grid[i][j];pairRow.push([_currentNode.x,_currentNode.y]);}pairGrid.push(pairRow);}// Create the maze graph\nvar mazeGraph=new Map();for(var _i=0;_i<columnLength;_i++){for(var _j=0;_j<rowLength;_j++){mazeGraph.set(pairGrid[_i][_j],[]);}}return[pairGrid,mazeGraph];};export var createEmptyMazeGraph=function createEmptyMazeGraph(rowLength,columnLength,grid){var pairGrid=[];for(var i=0;i<columnLength;i++){var pairRow=[];for(var j=0;j<rowLength;j++){var _currentNode2=grid[i][j];pairRow.push([_currentNode2.x,_currentNode2.y]);}pairGrid.push(pairRow);}// Create the maze graph\nvar mazeGraph=new Map();for(var _i2=0;_i2<columnLength;_i2++){for(var _j2=0;_j2<rowLength;_j2++){var neighbors=getNeighborsEmpty(pairGrid,[_i2,_j2],columnLength,rowLength);mazeGraph.set(pairGrid[_i2][_j2],neighbors);}}return[pairGrid,mazeGraph];};export var generateMazeGraph=function generateMazeGraph(rowLength,columnLength,grid,wallsDensity){var _createMazeGraph=createMazeGraph(rowLength,columnLength,grid),_createMazeGraph2=_slicedToArray(_createMazeGraph,2),pairGrid=_createMazeGraph2[0],mazeGraph=_createMazeGraph2[1];// I. Generate a maze where each cells is reachable (with a DFS)\nvar currentWallsCount=2*(rowLength-1)*(columnLength-1)+rowLength+columnLength-2;// 1. Choose the initial cell, mark it as visited and push it to the stack\nvar startNode=pairGrid[0][0];var stack=[startNode];var visited=[startNode];// 2. While the stack is not empty\nwhile(stack.length>0){// 1. Pop a cell from the stack and make it a current cell\nvar _currentNode3=ensure(stack.pop());var currentNonVisitedNeighbors=getNeighbors(pairGrid,_currentNode3,rowLength,columnLength,visited);// 2. If the current cell has any neighbours which have not been visited\nif(currentNonVisitedNeighbors.length>0){// 1. Push the current cell to the stack\nstack.push(_currentNode3);// 2. Choose one of the unvisited neighbours\nvar randIndex=Math.floor(Math.random()*currentNonVisitedNeighbors.length);var neighborNode=currentNonVisitedNeighbors[randIndex];// 3. Remove the wall between the current cell and the chosen cell\nvar currentNodeNeighbors=ensure(mazeGraph.get(_currentNode3));currentNodeNeighbors.push(neighborNode);// mazeGraph.set(currentNode, currentNodeNeighbors);\nvar neighborNodeNeighbors=ensure(mazeGraph.get(neighborNode));neighborNodeNeighbors.push(_currentNode3);// mazeGraph.set(neighborNode, neighborNodeNeighbors);\n// 4. Mark the chosen cell as visited and push it to the stack\nvisited.push(neighborNode);stack.push(neighborNode);// 5. Remove 1 from the currentWallsCount\ncurrentWallsCount--;}}var maxWallsCount=currentWallsCount;// II. Remove walls until the desired density is achieved\nwhile(currentWallsCount*(1/maxWallsCount)>wallsDensity){// 1. Choosse a node randomly\nvar randRow=Math.floor(Math.random()*rowLength);var randCol=Math.floor(Math.random()*columnLength);var _currentNode4=pairGrid[randCol][randRow];// 2. Get the cells with a wall with the current cell\nvar neighbors=getNeighborsII(pairGrid,_currentNode4,rowLength,columnLength,mazeGraph);if(neighbors.length>0){// 3. Choose one of the cells with a wall\nvar _randIndex=Math.floor(Math.random()*neighbors.length);var _neighborNode=pairGrid[neighbors[_randIndex][0]][neighbors[_randIndex][1]];// 4. Remove the wall between the 2 cells\nvar _currentNodeNeighbors=ensure(mazeGraph.get(_currentNode4));_currentNodeNeighbors.push(_neighborNode);// mazeGraph.set(currentNode, currentNodeNeighbors);\nvar _neighborNodeNeighbors=ensure(mazeGraph.get(_neighborNode));_neighborNodeNeighbors.push(_currentNode4);// mazeGraph.set(neighborNode, neighborNodeNeighbors);\ncurrentWallsCount--;}}return[pairGrid,mazeGraph];};var getNeighbors=function getNeighbors(pairGrid,currentNode,rowLength,columnLength,visited){var directions=[[1,0],[0,1],[-1,0],[0,-1]];var neighbors=[];var neighborX=-1;var neighborY=-1;for(var _i3=0,_directions=directions;_i3<_directions.length;_i3++){var dir=_directions[_i3];neighborX=currentNode[0]+dir[0];neighborY=currentNode[1]+dir[1];if(neighborX>=0&&neighborX<columnLength&&neighborY>=0&&neighborY<rowLength&&!visited.includes(pairGrid[neighborX][neighborY])){neighbors.push(pairGrid[neighborX][neighborY]);}}return neighbors;};export var getNeighborsEmpty=function getNeighborsEmpty(pairGrid,currentNode,columnLength,rowLength){var directions=[[1,0],[0,1],[-1,0],[0,-1]];var neighbors=[];var neighborX=-1;var neighborY=-1;for(var _i4=0,_directions2=directions;_i4<_directions2.length;_i4++){var dir=_directions2[_i4];neighborX=currentNode[0]+dir[0];neighborY=currentNode[1]+dir[1];if(neighborX>=0&&neighborX<columnLength&&neighborY>=0&&neighborY<rowLength){neighbors.push(pairGrid[neighborX][neighborY]);}}return neighbors;};var getNeighborsII=function getNeighborsII(pairGrid,currentNode,rowLength,columnLength,mazeGraph){var directions=[[1,0],[0,1],[-1,0],[0,-1]];var neighbors=[];var neighborX=-1;var neighborY=-1;for(var _i5=0,_directions3=directions;_i5<_directions3.length;_i5++){var _mazeGraph$get;var dir=_directions3[_i5];neighborX=currentNode[0]+dir[0];neighborY=currentNode[1]+dir[1];if(neighborX>=0&&neighborX<columnLength&&neighborY>=0&&neighborY<rowLength&&!((_mazeGraph$get=mazeGraph.get(currentNode))===null||_mazeGraph$get===void 0?void 0:_mazeGraph$get.includes(pairGrid[neighborX][neighborY]))){neighbors.push(pairGrid[neighborX][neighborY]);}}return neighbors;};function ensure(argument){var message=arguments.length>1&&arguments[1]!==undefined?arguments[1]:\"This value was promised to be there.\";if(argument===undefined||argument===null){throw new TypeError(message);}return argument;}","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helper_functions/mazeGenerators/mazeGraph.ts"],"names":["createMazeGraph","rowLength","columnLength","grid","pairGrid","i","pairRow","j","currentNode","push","x","y","mazeGraph","Map","set","createEmptyMazeGraph","neighbors","getNeighborsEmpty","generateMazeGraph","wallsDensity","currentWallsCount","startNode","stack","visited","length","ensure","pop","currentNonVisitedNeighbors","getNeighbors","randIndex","Math","floor","random","neighborNode","currentNodeNeighbors","get","neighborNodeNeighbors","maxWallsCount","randRow","randCol","getNeighborsII","directions","neighborX","neighborY","dir","includes","argument","message","undefined","TypeError"],"mappings":"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","sourcesContent":["import { node } from \"../usefulInterfaces\";\n\n// TODO: Refactor the code to use the different key-values pair as the nodes get changed when there is a setGrid that is applied\n\nconst createMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][]\n) => [[number, number][][], Map<[number, number], [number, number][]>] = (\n  rowLength,\n  columnLength,\n  grid\n) => {\n  let pairGrid: [number, number][][] = [];\n  for (let i: number = 0; i < columnLength; i++) {\n    let pairRow: [number, number][] = [];\n    for (let j: number = 0; j < rowLength; j++) {\n      let currentNode: node = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n    pairGrid.push(pairRow);\n  }\n\n  // Create the maze graph\n  let mazeGraph: Map<[number, number], [number, number][]> = new Map();\n  for (let i: number = 0; i < columnLength; i++) {\n    for (let j: number = 0; j < rowLength; j++) {\n      mazeGraph.set(pairGrid[i][j], []);\n    }\n  }\n  return [pairGrid, mazeGraph];\n};\n\nexport const createEmptyMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][]\n) => [[number, number][][], Map<[number, number], [number, number][]>] = (\n  rowLength,\n  columnLength,\n  grid\n) => {\n  let pairGrid: [number, number][][] = [];\n  for (let i: number = 0; i < columnLength; i++) {\n    let pairRow: [number, number][] = [];\n    for (let j: number = 0; j < rowLength; j++) {\n      let currentNode: node = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n    pairGrid.push(pairRow);\n  }\n  // Create the maze graph\n  let mazeGraph: Map<[number, number], [number, number][]> = new Map();\n  for (let i: number = 0; i < columnLength; i++) {\n    for (let j: number = 0; j < rowLength; j++) {\n      let neighbors: [number, number][] = getNeighborsEmpty(\n        pairGrid,\n        [i, j],\n        columnLength,\n        rowLength\n      );\n      mazeGraph.set(pairGrid[i][j], neighbors);\n    }\n  }\n  return [pairGrid, mazeGraph];\n};\n\nexport const generateMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][],\n  wallsDensity: number\n) => [[number, number][][], Map<[number, number], [number, number][]>] = (\n  rowLength,\n  columnLength,\n  grid,\n  wallsDensity\n) => {\n  let [pairGrid, mazeGraph] = createMazeGraph(rowLength, columnLength, grid);\n\n  // I. Generate a maze where each cells is reachable (with a DFS)\n  let currentWallsCount: number =\n    2 * (rowLength - 1) * (columnLength - 1) + rowLength + columnLength - 2;\n\n  // 1. Choose the initial cell, mark it as visited and push it to the stack\n  let startNode: [number, number] = pairGrid[0][0];\n  let stack: [number, number][] = [startNode];\n  let visited: [number, number][] = [startNode];\n\n  // 2. While the stack is not empty\n  while (stack.length > 0) {\n    // 1. Pop a cell from the stack and make it a current cell\n    let currentNode: [number, number] = ensure(stack.pop());\n    let currentNonVisitedNeighbors: [number, number][] = getNeighbors(\n      pairGrid,\n      currentNode,\n      rowLength,\n      columnLength,\n      visited\n    );\n    // 2. If the current cell has any neighbours which have not been visited\n    if (currentNonVisitedNeighbors.length > 0) {\n      // 1. Push the current cell to the stack\n      stack.push(currentNode);\n\n      // 2. Choose one of the unvisited neighbours\n      let randIndex: number = Math.floor(\n        Math.random() * currentNonVisitedNeighbors.length\n      );\n      let neighborNode: [number, number] =\n        currentNonVisitedNeighbors[randIndex];\n\n      // 3. Remove the wall between the current cell and the chosen cell\n      let currentNodeNeighbors: [number, number][] = ensure(\n        mazeGraph.get(currentNode)\n      );\n      currentNodeNeighbors.push(neighborNode);\n      // mazeGraph.set(currentNode, currentNodeNeighbors);\n\n      let neighborNodeNeighbors: [number, number][] = ensure(\n        mazeGraph.get(neighborNode)\n      );\n      neighborNodeNeighbors.push(currentNode);\n      // mazeGraph.set(neighborNode, neighborNodeNeighbors);\n\n      // 4. Mark the chosen cell as visited and push it to the stack\n      visited.push(neighborNode);\n      stack.push(neighborNode);\n\n      // 5. Remove 1 from the currentWallsCount\n      currentWallsCount--;\n    }\n  }\n\n  let maxWallsCount: number = currentWallsCount;\n  // II. Remove walls until the desired density is achieved\n  while (currentWallsCount * (1 / maxWallsCount) > wallsDensity) {\n    // 1. Choosse a node randomly\n    let randRow: number = Math.floor(Math.random() * rowLength);\n    let randCol: number = Math.floor(Math.random() * columnLength);\n    let currentNode: [number, number] = pairGrid[randCol][randRow];\n\n    // 2. Get the cells with a wall with the current cell\n    let neighbors: [number, number][] = getNeighborsII(\n      pairGrid,\n      currentNode,\n      rowLength,\n      columnLength,\n      mazeGraph\n    );\n\n    if (neighbors.length > 0) {\n      // 3. Choose one of the cells with a wall\n      let randIndex: number = Math.floor(Math.random() * neighbors.length);\n      let neighborNode: [number, number] =\n        pairGrid[neighbors[randIndex][0]][neighbors[randIndex][1]];\n\n      // 4. Remove the wall between the 2 cells\n      let currentNodeNeighbors: [number, number][] = ensure(\n        mazeGraph.get(currentNode)\n      );\n      currentNodeNeighbors.push(neighborNode);\n      // mazeGraph.set(currentNode, currentNodeNeighbors);\n\n      let neighborNodeNeighbors: [number, number][] = ensure(\n        mazeGraph.get(neighborNode)\n      );\n      neighborNodeNeighbors.push(currentNode);\n      // mazeGraph.set(neighborNode, neighborNodeNeighbors);\n\n      currentWallsCount--;\n    }\n  }\n  return [pairGrid, mazeGraph];\n};\n\nconst getNeighbors: (\n  grid: [number, number][][],\n  currentNode: [number, number],\n  rowLength: number,\n  columnLength: number,\n  visited: [number, number][]\n) => [number, number][] = (\n  pairGrid,\n  currentNode,\n  rowLength,\n  columnLength,\n  visited\n) => {\n  const directions = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength &&\n      !visited.includes(pairGrid[neighborX][neighborY])\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n\nexport const getNeighborsEmpty: (\n  pairGrid: [number, number][][],\n  currentNode: [number, number],\n  columnLength: number,\n  rowLength: number\n) => [number, number][] = (pairGrid, currentNode, columnLength, rowLength) => {\n  const directions = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n\nconst getNeighborsII: (\n  pairGrid: [number, number][][],\n  currentNode: [number, number],\n  rowLength: number,\n  columnLength: number,\n  mazeGraph: Map<[number, number], [number, number][]>\n) => [number, number][] = (\n  pairGrid,\n  currentNode,\n  rowLength,\n  columnLength,\n  mazeGraph\n) => {\n  const directions = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength &&\n      !mazeGraph.get(currentNode)?.includes(pairGrid[neighborX][neighborY])\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n\nfunction ensure<T>(\n  argument: T | undefined | null,\n  message: string = \"This value was promised to be there.\"\n): T {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}\n"]},"metadata":{},"sourceType":"module"}