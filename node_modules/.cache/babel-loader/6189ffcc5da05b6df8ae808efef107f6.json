{"ast":null,"code":"import{dijkstra,getDistanceMatrix}from\"../singleTarget/dijkstra\";import{greedy}from\"./greedy\";export var bruteForceTSP=function bruteForceTSP(grid,pairGrid,mazeGraph,startNode,targetList){var newTargetList=targetList.slice();newTargetList.unshift(startNode);var distancesMatrix=getDistanceMatrix(grid,pairGrid,mazeGraph,newTargetList);var path=[[startNode,0]];var optimalPath=[];var maxCost=greedy(grid,pairGrid,mazeGraph,startNode,targetList)[1];var maxLength=targetList.length+1;var bnbtargets=targetList.map(function(targetNode,i){return[targetNode,i+1];});var branchAndBound=function branchAndBound(candidatePath,remainingTargets,currentCost){if(candidatePath.length===maxLength){if(currentCost>maxCost)return;maxCost=currentCost;optimalPath=candidatePath;return;}var newRemainingTargets=remainingTargets.slice();remainingTargets.forEach(function(targetNodeAndIndex){var prevId=candidatePath[candidatePath.length-1][1];candidatePath.push(targetNodeAndIndex);branchAndBound(candidatePath.slice(),newRemainingTargets.filter(function(tgAndId){return tgAndId[1]!==targetNodeAndIndex[1];}),currentCost+distancesMatrix[prevId][targetNodeAndIndex[1]]);candidatePath.pop();});};branchAndBound(path,bnbtargets,0);console.log(optimalPath);return[getTrueOptimalPath(grid,pairGrid,mazeGraph,optimalPath.map(function(valueIndexPair){return valueIndexPair[0];})),maxCost];};var getTrueOptimalPath=function getTrueOptimalPath(grid,pairGrid,mazeGraph,optimalPath){var actualPath=[];for(var i=0;i<optimalPath.length-1;i++){var path=dijkstra(grid,pairGrid,mazeGraph,optimalPath[i],[optimalPath[i+1]])[1];actualPath.push([[],path.slice()]);}return actualPath;};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helperFunctions/shortestPathAlgorithms/multipleTarget/bruteForce.ts"],"names":["dijkstra","getDistanceMatrix","greedy","bruteForceTSP","grid","pairGrid","mazeGraph","startNode","targetList","newTargetList","slice","unshift","distancesMatrix","path","optimalPath","maxCost","maxLength","length","bnbtargets","map","targetNode","i","branchAndBound","candidatePath","remainingTargets","currentCost","newRemainingTargets","forEach","targetNodeAndIndex","prevId","push","filter","tgAndId","pop","console","log","getTrueOptimalPath","valueIndexPair","actualPath"],"mappings":"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","sourcesContent":["import { node } from \"../../usefulInterfaces\";\nimport { dijkstra, getDistanceMatrix } from \"../singleTarget/dijkstra\";\nimport { greedy } from \"./greedy\";\n\nexport const bruteForceTSP: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  startNode: node,\n  targetList: node[]\n) => [[node[], node[]][], number] = (\n  grid,\n  pairGrid,\n  mazeGraph,\n  startNode,\n  targetList\n) => {\n  const newTargetList: node[] = targetList.slice();\n  newTargetList.unshift(startNode);\n  const distancesMatrix: number[][] = getDistanceMatrix(\n    grid,\n    pairGrid,\n    mazeGraph,\n    newTargetList\n  );\n  let path: [node, number][] = [[startNode, 0]];\n  let optimalPath: [node, number][] = [];\n\n  let maxCost: number = greedy(\n    grid,\n    pairGrid,\n    mazeGraph,\n    startNode,\n    targetList\n  )[1];\n  const maxLength: number = targetList.length + 1;\n  const bnbtargets: [node, number][] = targetList.map((targetNode, i) => [\n    targetNode,\n    i + 1,\n  ]);\n\n  const branchAndBound: (\n    candidatePath: [node, number][],\n    remainingTargets: [node, number][],\n    currentCost: number\n  ) => void = (candidatePath, remainingTargets, currentCost) => {\n    if (candidatePath.length === maxLength) {\n      if (currentCost > maxCost) return;\n      maxCost = currentCost;\n      optimalPath = candidatePath;\n      return;\n    }\n    const newRemainingTargets: [node, number][] = remainingTargets.slice();\n    remainingTargets.forEach((targetNodeAndIndex) => {\n      let prevId: number = candidatePath[candidatePath.length - 1][1];\n      candidatePath.push(targetNodeAndIndex);\n      branchAndBound(\n        candidatePath.slice(),\n        newRemainingTargets.filter(\n          (tgAndId) => tgAndId[1] !== targetNodeAndIndex[1]\n        ),\n        currentCost + distancesMatrix[prevId][targetNodeAndIndex[1]]\n      );\n      candidatePath.pop();\n    });\n  };\n  branchAndBound(path, bnbtargets, 0);\n  console.log(optimalPath);\n  return [\n    getTrueOptimalPath(\n      grid,\n      pairGrid,\n      mazeGraph,\n      optimalPath.map((valueIndexPair) => valueIndexPair[0])\n    ),\n    maxCost,\n  ];\n};\n\nconst getTrueOptimalPath: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>,\n  optimalPath: node[]\n) => [node[], node[]][] = (grid, pairGrid, mazeGraph, optimalPath) => {\n  let actualPath: [node[], node[]][] = [];\n  for (let i: number = 0; i < optimalPath.length - 1; i++) {\n    let path = dijkstra(grid, pairGrid, mazeGraph, optimalPath[i], [\n      optimalPath[i + 1],\n    ])[1];\n    actualPath.push([[], path.slice()]);\n  }\n  return actualPath;\n};\n"]},"metadata":{},"sourceType":"module"}