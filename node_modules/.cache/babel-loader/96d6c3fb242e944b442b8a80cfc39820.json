{"ast":null,"code":"import{ensure}from\"../ensureNotUndefined\";export var retrievePath=function retrievePath(predecessor,startNode,endNode){var shortestPath=[endNode];var current=endNode;while(current.x!==startNode.x||current.y!==startNode.y){current=predecessor[current.id];shortestPath.unshift(current);}return shortestPath;};export var retrieveTwoEndedPath=function retrieveTwoEndedPath(predecessor,successor,middleNode,startNode,endNode){var shortestPath=[middleNode];var current=middleNode;while(current.x!==startNode.x||current.y!==startNode.y){current=predecessor[current.id];shortestPath.unshift(current);}current=middleNode;while(current.x!==endNode.x||current.y!==endNode.y){current=successor[current.id];shortestPath.push(current);}return shortestPath;};export var retrieveDistance=function retrieveDistance(path,pairGrid,mazeGraph){var distance=0;var _loop=function _loop(i){var predNode=path[i-1],currNode=path[i];var pred=pairGrid[predNode.x][predNode.y],curr=pairGrid[currNode.x][currNode.y];var neighbor=ensure(ensure(mazeGraph.get(pred)).find(function(neighborEdge){return neighborEdge[0][0]===curr[0]&&neighborEdge[0][1]===curr[1];}));distance+=neighbor[1];};for(var i=1;i<path.length;i++){_loop(i);}return distance;};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helperFunctions/shortestPathAlgorithms/retrievePath.ts"],"names":["ensure","retrievePath","predecessor","startNode","endNode","shortestPath","current","x","y","id","unshift","retrieveTwoEndedPath","successor","middleNode","push","retrieveDistance","path","pairGrid","mazeGraph","distance","i","predNode","currNode","pred","curr","neighbor","get","find","neighborEdge","length"],"mappings":"AAAA,OAASA,MAAT,KAAuB,uBAAvB,CAGA,MAAO,IAAMC,CAAAA,YAIF,CAAG,QAJDA,CAAAA,YAIC,CAACC,WAAD,CAAcC,SAAd,CAAyBC,OAAzB,CAAqC,CACjD,GAAIC,CAAAA,YAAY,CAAG,CAACD,OAAD,CAAnB,CACA,GAAIE,CAAAA,OAAa,CAAGF,OAApB,CACA,MAAOE,OAAO,CAACC,CAAR,GAAcJ,SAAS,CAACI,CAAxB,EAA6BD,OAAO,CAACE,CAAR,GAAcL,SAAS,CAACK,CAA5D,CAA+D,CAC7DF,OAAO,CAAGJ,WAAW,CAACI,OAAO,CAACG,EAAT,CAArB,CACAJ,YAAY,CAACK,OAAb,CAAqBJ,OAArB,EACD,CAED,MAAOD,CAAAA,YAAP,CACD,CAbM,CAeP,MAAO,IAAMM,CAAAA,oBAMF,CAAG,QANDA,CAAAA,oBAMC,CAACT,WAAD,CAAcU,SAAd,CAAyBC,UAAzB,CAAqCV,SAArC,CAAgDC,OAAhD,CAA4D,CACxE,GAAIC,CAAAA,YAAY,CAAG,CAACQ,UAAD,CAAnB,CACA,GAAIP,CAAAA,OAAa,CAAGO,UAApB,CACA,MAAOP,OAAO,CAACC,CAAR,GAAcJ,SAAS,CAACI,CAAxB,EAA6BD,OAAO,CAACE,CAAR,GAAcL,SAAS,CAACK,CAA5D,CAA+D,CAC7DF,OAAO,CAAGJ,WAAW,CAACI,OAAO,CAACG,EAAT,CAArB,CACAJ,YAAY,CAACK,OAAb,CAAqBJ,OAArB,EACD,CACDA,OAAO,CAAGO,UAAV,CACA,MAAOP,OAAO,CAACC,CAAR,GAAcH,OAAO,CAACG,CAAtB,EAA2BD,OAAO,CAACE,CAAR,GAAcJ,OAAO,CAACI,CAAxD,CAA2D,CACzDF,OAAO,CAAGM,SAAS,CAACN,OAAO,CAACG,EAAT,CAAnB,CACAJ,YAAY,CAACS,IAAb,CAAkBR,OAAlB,EACD,CACD,MAAOD,CAAAA,YAAP,CACD,CAnBM,CAqBP,MAAO,IAAMU,CAAAA,gBAIF,CAAG,QAJDA,CAAAA,gBAIC,CAACC,IAAD,CAAOC,QAAP,CAAiBC,SAAjB,CAA+B,CAC3C,GAAIC,CAAAA,QAAgB,CAAG,CAAvB,CAD2C,yBAElCC,CAFkC,EAGzC,GAAIC,CAAAA,QAAc,CAAGL,IAAI,CAACI,CAAC,CAAG,CAAL,CAAzB,CACEE,QAAc,CAAGN,IAAI,CAACI,CAAD,CADvB,CAEA,GAAIG,CAAAA,IAAsB,CAAGN,QAAQ,CAACI,QAAQ,CAACd,CAAV,CAAR,CAAqBc,QAAQ,CAACb,CAA9B,CAA7B,CACEgB,IAAsB,CAAGP,QAAQ,CAACK,QAAQ,CAACf,CAAV,CAAR,CAAqBe,QAAQ,CAACd,CAA9B,CAD3B,CAEA,GAAIiB,CAAAA,QAAoC,CAAGzB,MAAM,CAC/CA,MAAM,CAACkB,SAAS,CAACQ,GAAV,CAAcH,IAAd,CAAD,CAAN,CAA4BI,IAA5B,CACE,SAACC,YAAD,QACEA,CAAAA,YAAY,CAAC,CAAD,CAAZ,CAAgB,CAAhB,IAAuBJ,IAAI,CAAC,CAAD,CAA3B,EAAkCI,YAAY,CAAC,CAAD,CAAZ,CAAgB,CAAhB,IAAuBJ,IAAI,CAAC,CAAD,CAD/D,EADF,CAD+C,CAAjD,CAMAL,QAAQ,EAAIM,QAAQ,CAAC,CAAD,CAApB,CAbyC,EAE3C,IAAK,GAAIL,CAAAA,CAAS,CAAG,CAArB,CAAwBA,CAAC,CAAGJ,IAAI,CAACa,MAAjC,CAAyCT,CAAC,EAA1C,CAA8C,OAArCA,CAAqC,EAY7C,CACD,MAAOD,CAAAA,QAAP,CACD,CApBM","sourcesContent":["import { ensure } from \"../ensureNotUndefined\";\nimport { node } from \"../usefulInterfaces\";\n\nexport const retrievePath: (\n  predecessor: node[],\n  startNode: node,\n  endNode: node\n) => node[] = (predecessor, startNode, endNode) => {\n  let shortestPath = [endNode];\n  let current: node = endNode;\n  while (current.x !== startNode.x || current.y !== startNode.y) {\n    current = predecessor[current.id];\n    shortestPath.unshift(current);\n  }\n\n  return shortestPath;\n};\n\nexport const retrieveTwoEndedPath: (\n  predecessor: node[],\n  successor: node[],\n  middleNode: node,\n  startNode: node,\n  endNode: node\n) => node[] = (predecessor, successor, middleNode, startNode, endNode) => {\n  let shortestPath = [middleNode];\n  let current: node = middleNode;\n  while (current.x !== startNode.x || current.y !== startNode.y) {\n    current = predecessor[current.id];\n    shortestPath.unshift(current);\n  }\n  current = middleNode;\n  while (current.x !== endNode.x || current.y !== endNode.y) {\n    current = successor[current.id];\n    shortestPath.push(current);\n  }\n  return shortestPath;\n};\n\nexport const retrieveDistance: (\n  path: node[],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>\n) => number = (path, pairGrid, mazeGraph) => {\n  let distance: number = 0;\n  for (let i: number = 1; i < path.length; i++) {\n    let predNode: node = path[i - 1],\n      currNode: node = path[i];\n    let pred: [number, number] = pairGrid[predNode.x][predNode.y],\n      curr: [number, number] = pairGrid[currNode.x][currNode.y];\n    let neighbor: [[number, number], number] = ensure(\n      ensure(mazeGraph.get(pred)).find(\n        (neighborEdge) =>\n          neighborEdge[0][0] === curr[0] && neighborEdge[0][1] === curr[1]\n      )\n    );\n    distance += neighbor[1];\n  }\n  return distance;\n};\n"]},"metadata":{},"sourceType":"module"}