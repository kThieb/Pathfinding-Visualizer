{"ast":null,"code":"import { ensure } from \"../ensureNotUndefined\";\nconst MUD_WEIGHT = 5;\n\nconst createMazeGraph = (rowLength, columnLength, grid) => {\n  let pairGrid = [];\n\n  for (let i = 0; i < columnLength; i++) {\n    let pairRow = [];\n\n    for (let j = 0; j < rowLength; j++) {\n      let currentNode = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n\n    pairGrid.push(pairRow);\n  } // Create the maze graph\n\n\n  let mazeGraph = new Map();\n\n  for (let i = 0; i < columnLength; i++) {\n    for (let j = 0; j < rowLength; j++) {\n      mazeGraph.set(pairGrid[i][j], []);\n    }\n  }\n\n  return [pairGrid, mazeGraph];\n};\n\nexport const createEmptyMazeGraph = (rowLength, columnLength, grid) => {\n  let pairGrid = [];\n\n  for (let i = 0; i < columnLength; i++) {\n    let pairRow = [];\n\n    for (let j = 0; j < rowLength; j++) {\n      let currentNode = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n\n    pairGrid.push(pairRow);\n  } // Create the maze graph\n\n\n  let mazeGraph = new Map();\n\n  for (let i = 0; i < columnLength; i++) {\n    for (let j = 0; j < rowLength; j++) {\n      let neighbors = getNeighborsEmpty(pairGrid, [i, j], columnLength, rowLength);\n      mazeGraph.set(pairGrid[i][j], neighbors);\n    }\n  }\n\n  return [pairGrid, mazeGraph];\n};\nexport const reinitialize = (rowLength, columnLength, startNode, endNode, grid) => {\n  const newGrid = grid.slice();\n  let newStartNode = startNode,\n      newEndNode = endNode;\n\n  for (let i = 0; i < columnLength; i++) {\n    for (let j = 0; j < rowLength; j++) {\n      newGrid[i][j] = { ...grid[i][j],\n        isShortestPath: false,\n        isVisited: false\n      };\n      if (startNode === grid[i][j]) newStartNode = newGrid[i][j];\n      if (endNode === grid[i][j]) newEndNode = newGrid[i][j];\n    }\n  }\n\n  return [newGrid, newStartNode, newEndNode];\n};\nexport const generateMazeGraph = (rowLength, columnLength, grid, wallsDensity, mudDensity) => {\n  let [pairGrid, mazeGraph] = createMazeGraph(rowLength, columnLength, grid);\n  let currentWallsCount = 2 * (rowLength - 1) * (columnLength - 1) + rowLength + columnLength - 2,\n      maxWallsOrMud = currentWallsCount; // I. Generate a maze where each cells is reachable (with a DFS)\n  // 1. Choose the initial cell, mark it as visited and push it to the stack\n\n  let startNode = pairGrid[0][0];\n  let stack = [startNode];\n  let visited = [startNode]; // 2. While the stack is not empty\n\n  while (stack.length > 0) {\n    // 1. Pop a cell from the stack and make it a current cell\n    let currentNode = ensure(stack.pop());\n    let currentNonVisitedNeighbors = getNeighbors(pairGrid, currentNode, rowLength, columnLength, visited); // 2. If the current cell has any neighbours which have not been visited\n\n    if (currentNonVisitedNeighbors.length > 0) {\n      // 1. Push the current cell to the stack\n      stack.push(currentNode); // 2. Choose one of the unvisited neighbours\n\n      let randIndex = Math.floor(Math.random() * currentNonVisitedNeighbors.length);\n      let neighborNode = currentNonVisitedNeighbors[randIndex]; // 3. Remove the wall between the current cell and the chosen cell\n\n      let currentNodeNeighbors = ensure(mazeGraph.get(currentNode));\n      currentNodeNeighbors.push([neighborNode, 1]);\n      let neighborNodeNeighbors = ensure(mazeGraph.get(neighborNode));\n      neighborNodeNeighbors.push([currentNode, 1]); // 4. Mark the ch// mazeGraph.set(neighborNode, neighborNodeNeighbors);osen cell as visited and push it to the stack\n\n      visited.push(neighborNode);\n      stack.push(neighborNode); // 5. Remove 1 from the currentWallsCount\n\n      currentWallsCount--;\n    }\n  } // II. Remove walls until the desired density is achieved\n\n\n  let maxWallsCount = currentWallsCount;\n\n  while (currentWallsCount * (1 / maxWallsCount) > wallsDensity) {\n    // 1. Choose a node randomly\n    let randRow = Math.floor(Math.random() * rowLength);\n    let randCol = Math.floor(Math.random() * columnLength);\n    let currentNode = pairGrid[randCol][randRow]; // 2. Get the cells with a wall with the current cell\n\n    let neighbors = getWalledOffNeighbors(pairGrid, currentNode, rowLength, columnLength, mazeGraph);\n\n    if (neighbors.length > 0) {\n      // 3. Choose one of the cells with a wall\n      let randIndex = Math.floor(Math.random() * neighbors.length);\n      let neighborNode = pairGrid[neighbors[randIndex][0]][neighbors[randIndex][1]]; // 4. Remove the wall between the 2 cells\n\n      let currentNodeNeighbors = ensure(mazeGraph.get(currentNode));\n      currentNodeNeighbors.push([neighborNode, 1]);\n      let neighborNodeNeighbors = ensure(mazeGraph.get(neighborNode));\n      neighborNodeNeighbors.push([currentNode, 1]);\n      currentWallsCount--;\n    }\n  } // III. Add mud to the graph until we get the desired mud density\n\n\n  let currentMud = 0,\n      maxMud = maxWallsOrMud - currentWallsCount;\n\n  while (currentMud * (1 / maxMud) < mudDensity) {\n    // 1. Choose a node randomly\n    let randRow = Math.floor(Math.random() * rowLength);\n    let randCol = Math.floor(Math.random() * columnLength);\n    let currentNode = pairGrid[randCol][randRow]; // 2. Get the neighbors than have no mud\n\n    let neighbors = ensure(mazeGraph.get(currentNode)).filter(item => item[1] === 1);\n\n    if (neighbors.length > 0) {\n      // 3. Get a random neighbor\n      let randIndex = Math.floor(Math.random() * neighbors.length);\n      let neighborNode = pairGrid[neighbors[randIndex][0][0]][neighbors[randIndex][0][1]];\n      neighbors[randIndex][1] = MUD_WEIGHT;\n      let neighborNodeNeighbors = ensure(mazeGraph.get(neighborNode));\n      let currentNodeAndDistance = ensure(neighborNodeNeighbors.find(item => item[0] === currentNode));\n      currentNodeAndDistance[1] = MUD_WEIGHT;\n      currentMud++;\n    }\n  }\n\n  console.log(mazeGraph);\n  return [pairGrid, mazeGraph];\n};\n\nconst getNeighbors = (pairGrid, currentNode, rowLength, columnLength, visited) => {\n  const directions = [[1, 0], [0, -1], [-1, 0], [0, 1]];\n  let neighbors = [];\n  let neighborX = -1;\n  let neighborY = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n\n    if (neighborX >= 0 && neighborX < columnLength && neighborY >= 0 && neighborY < rowLength && !visited.includes(pairGrid[neighborX][neighborY])) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n\n  return neighbors;\n};\n\nexport const getNeighborsEmpty = (pairGrid, currentNode, columnLength, rowLength) => {\n  const directions = [[1, 0], [0, -1], [-1, 0], [0, 1]];\n  let neighbors = [];\n  let neighborX = -1;\n  let neighborY = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n\n    if (neighborX >= 0 && neighborX < columnLength && neighborY >= 0 && neighborY < rowLength) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n\n  return neighbors;\n}; // This function returns the neighbors which have a wall with the current node\n\nconst getWalledOffNeighbors = (pairGrid, currentNode, rowLength, columnLength, mazeGraph) => {\n  const directions = [[1, 0], [0, -1], [-1, 0], [0, 1]];\n  let neighbors = [];\n  let neighborX = -1;\n  let neighborY = -1;\n\n  const findCallback = neighbor => {\n    return neighbor[0] === pairGrid[neighborX][neighborY];\n  };\n\n  for (const dir of directions) {\n    var _mazeGraph$get;\n\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n\n    if (neighborX >= 0 && neighborX < columnLength && neighborY >= 0 && neighborY < rowLength && // !mazeGraph.get(currentNode)?.includes(pairGrid[neighborX][neighborY])\n    !((_mazeGraph$get = mazeGraph.get(currentNode)) === null || _mazeGraph$get === void 0 ? void 0 : _mazeGraph$get.find(findCallback))) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n\n  return neighbors;\n};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helperFunctions/mazeGenerators/mazeGraph.ts"],"names":["ensure","MUD_WEIGHT","createMazeGraph","rowLength","columnLength","grid","pairGrid","i","pairRow","j","currentNode","push","x","y","mazeGraph","Map","set","createEmptyMazeGraph","neighbors","getNeighborsEmpty","reinitialize","startNode","endNode","newGrid","slice","newStartNode","newEndNode","isShortestPath","isVisited","generateMazeGraph","wallsDensity","mudDensity","currentWallsCount","maxWallsOrMud","stack","visited","length","pop","currentNonVisitedNeighbors","getNeighbors","randIndex","Math","floor","random","neighborNode","currentNodeNeighbors","get","neighborNodeNeighbors","maxWallsCount","randRow","randCol","getWalledOffNeighbors","currentMud","maxMud","filter","item","currentNodeAndDistance","find","console","log","directions","neighborX","neighborY","dir","includes","findCallback","neighbor"],"mappings":"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","sourcesContent":["import { constructGrid } from \"../constructGrid\";\nimport { ensure } from \"../ensureNotUndefined\";\nimport { node } from \"../usefulInterfaces\";\n\nconst MUD_WEIGHT = 5;\n\nconst createMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][]\n) => [\n  [number, number][][],\n  Map<[number, number], [[number, number], number][]>\n] = (rowLength, columnLength, grid) => {\n  let pairGrid: [number, number][][] = [];\n  for (let i: number = 0; i < columnLength; i++) {\n    let pairRow: [number, number][] = [];\n    for (let j: number = 0; j < rowLength; j++) {\n      let currentNode: node = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n    pairGrid.push(pairRow);\n  }\n\n  // Create the maze graph\n  let mazeGraph: Map<\n    [number, number],\n    [[number, number], number][]\n  > = new Map();\n  for (let i: number = 0; i < columnLength; i++) {\n    for (let j: number = 0; j < rowLength; j++) {\n      mazeGraph.set(pairGrid[i][j], []);\n    }\n  }\n\n  return [pairGrid, mazeGraph];\n};\n\nexport const createEmptyMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][]\n) => [[number, number][][], Map<[number, number], [number, number][]>] = (\n  rowLength,\n  columnLength,\n  grid\n) => {\n  let pairGrid: [number, number][][] = [];\n  for (let i: number = 0; i < columnLength; i++) {\n    let pairRow: [number, number][] = [];\n    for (let j: number = 0; j < rowLength; j++) {\n      let currentNode: node = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n    pairGrid.push(pairRow);\n  }\n  // Create the maze graph\n  let mazeGraph: Map<[number, number], [number, number][]> = new Map();\n  for (let i: number = 0; i < columnLength; i++) {\n    for (let j: number = 0; j < rowLength; j++) {\n      let neighbors: [number, number][] = getNeighborsEmpty(\n        pairGrid,\n        [i, j],\n        columnLength,\n        rowLength\n      );\n\n      mazeGraph.set(pairGrid[i][j], neighbors);\n    }\n  }\n  return [pairGrid, mazeGraph];\n};\n\nexport const reinitialize: (\n  rowLength: number,\n  columnLength: number,\n  startNode: node,\n  endNode: node,\n  grid: node[][]\n) => [node[][], node, node] = (\n  rowLength,\n  columnLength,\n  startNode,\n  endNode,\n  grid\n) => {\n  const newGrid: node[][] = grid.slice();\n  let newStartNode: node = startNode,\n    newEndNode: node = endNode;\n  for (let i: number = 0; i < columnLength; i++) {\n    for (let j: number = 0; j < rowLength; j++) {\n      newGrid[i][j] = {\n        ...grid[i][j],\n        isShortestPath: false,\n        isVisited: false,\n      };\n      if (startNode === grid[i][j]) newStartNode = newGrid[i][j];\n      if (endNode === grid[i][j]) newEndNode = newGrid[i][j];\n    }\n  }\n  return [newGrid, newStartNode, newEndNode];\n};\n\nexport const generateMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][],\n  wallsDensity: number,\n  mudDendity: number\n) => [\n  [number, number][][],\n  Map<[number, number], [[number, number], number][]>\n] = (rowLength, columnLength, grid, wallsDensity, mudDensity) => {\n  let [pairGrid, mazeGraph]: [\n    [number, number][][],\n    Map<[number, number], [[number, number], number][]>\n  ] = createMazeGraph(rowLength, columnLength, grid);\n\n  let currentWallsCount: number =\n      2 * (rowLength - 1) * (columnLength - 1) + rowLength + columnLength - 2,\n    maxWallsOrMud = currentWallsCount;\n\n  // I. Generate a maze where each cells is reachable (with a DFS)\n\n  // 1. Choose the initial cell, mark it as visited and push it to the stack\n  let startNode: [number, number] = pairGrid[0][0];\n  let stack: [number, number][] = [startNode];\n  let visited: [number, number][] = [startNode];\n\n  // 2. While the stack is not empty\n  while (stack.length > 0) {\n    // 1. Pop a cell from the stack and make it a current cell\n    let currentNode: [number, number] = ensure(stack.pop());\n    let currentNonVisitedNeighbors: [number, number][] = getNeighbors(\n      pairGrid,\n      currentNode,\n      rowLength,\n      columnLength,\n      visited\n    );\n    // 2. If the current cell has any neighbours which have not been visited\n    if (currentNonVisitedNeighbors.length > 0) {\n      // 1. Push the current cell to the stack\n      stack.push(currentNode);\n\n      // 2. Choose one of the unvisited neighbours\n      let randIndex: number = Math.floor(\n        Math.random() * currentNonVisitedNeighbors.length\n      );\n      let neighborNode: [number, number] =\n        currentNonVisitedNeighbors[randIndex];\n\n      // 3. Remove the wall between the current cell and the chosen cell\n      let currentNodeNeighbors: [[number, number], number][] = ensure(\n        mazeGraph.get(currentNode)\n      );\n      currentNodeNeighbors.push([neighborNode, 1]);\n\n      let neighborNodeNeighbors: [[number, number], number][] = ensure(\n        mazeGraph.get(neighborNode)\n      );\n      neighborNodeNeighbors.push([currentNode, 1]);\n\n      // 4. Mark the ch// mazeGraph.set(neighborNode, neighborNodeNeighbors);osen cell as visited and push it to the stack\n      visited.push(neighborNode);\n      stack.push(neighborNode);\n\n      // 5. Remove 1 from the currentWallsCount\n      currentWallsCount--;\n    }\n  }\n\n  // II. Remove walls until the desired density is achieved\n  let maxWallsCount: number = currentWallsCount;\n  while (currentWallsCount * (1 / maxWallsCount) > wallsDensity) {\n    // 1. Choose a node randomly\n    let randRow: number = Math.floor(Math.random() * rowLength);\n    let randCol: number = Math.floor(Math.random() * columnLength);\n    let currentNode: [number, number] = pairGrid[randCol][randRow];\n\n    // 2. Get the cells with a wall with the current cell\n    let neighbors: [number, number][] = getWalledOffNeighbors(\n      pairGrid,\n      currentNode,\n      rowLength,\n      columnLength,\n      mazeGraph\n    );\n\n    if (neighbors.length > 0) {\n      // 3. Choose one of the cells with a wall\n      let randIndex: number = Math.floor(Math.random() * neighbors.length);\n      let neighborNode: [number, number] =\n        pairGrid[neighbors[randIndex][0]][neighbors[randIndex][1]];\n\n      // 4. Remove the wall between the 2 cells\n      let currentNodeNeighbors: [[number, number], number][] = ensure(\n        mazeGraph.get(currentNode)\n      );\n      currentNodeNeighbors.push([neighborNode, 1]);\n\n      let neighborNodeNeighbors: [[number, number], number][] = ensure(\n        mazeGraph.get(neighborNode)\n      );\n      neighborNodeNeighbors.push([currentNode, 1]);\n\n      currentWallsCount--;\n    }\n  }\n\n  // III. Add mud to the graph until we get the desired mud density\n  let currentMud: number = 0,\n    maxMud: number = maxWallsOrMud - currentWallsCount;\n  while (currentMud * (1 / maxMud) < mudDensity) {\n    // 1. Choose a node randomly\n    let randRow: number = Math.floor(Math.random() * rowLength);\n    let randCol: number = Math.floor(Math.random() * columnLength);\n    let currentNode: [number, number] = pairGrid[randCol][randRow];\n\n    // 2. Get the neighbors than have no mud\n    let neighbors: [[number, number], number][] = ensure(\n      mazeGraph.get(currentNode)\n    ).filter((item: [[number, number], number]) => item[1] === 1);\n\n    if (neighbors.length > 0) {\n      // 3. Get a random neighbor\n      let randIndex: number = Math.floor(Math.random() * neighbors.length);\n      let neighborNode: [number, number] =\n        pairGrid[neighbors[randIndex][0][0]][neighbors[randIndex][0][1]];\n\n      neighbors[randIndex][1] = MUD_WEIGHT;\n\n      let neighborNodeNeighbors: [[number, number], number][] = ensure(\n        mazeGraph.get(neighborNode)\n      );\n      let currentNodeAndDistance: [[number, number], number] = ensure(\n        neighborNodeNeighbors.find(\n          (item: [[number, number], number]) => item[0] === currentNode\n        )\n      );\n      currentNodeAndDistance[1] = MUD_WEIGHT;\n      currentMud++;\n    }\n  }\n\n  console.log(mazeGraph);\n\n  return [pairGrid, mazeGraph];\n};\n\nconst getNeighbors: (\n  grid: [number, number][][],\n  currentNode: [number, number],\n  rowLength: number,\n  columnLength: number,\n  visited: [number, number][]\n) => [number, number][] = (\n  pairGrid,\n  currentNode,\n  rowLength,\n  columnLength,\n  visited\n) => {\n  const directions = [\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n    [0, 1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength &&\n      !visited.includes(pairGrid[neighborX][neighborY])\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n\nexport const getNeighborsEmpty: (\n  pairGrid: [number, number][][],\n  currentNode: [number, number],\n  columnLength: number,\n  rowLength: number\n) => [number, number][] = (pairGrid, currentNode, columnLength, rowLength) => {\n  const directions = [\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n    [0, 1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n\n// This function returns the neighbors which have a wall with the current node\nconst getWalledOffNeighbors: (\n  pairGrid: [number, number][][],\n  currentNode: [number, number],\n  rowLength: number,\n  columnLength: number,\n  mazeGraph: Map<[number, number], [[number, number], number][]>\n) => [number, number][] = (\n  pairGrid,\n  currentNode,\n  rowLength,\n  columnLength,\n  mazeGraph\n) => {\n  const directions = [\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n    [0, 1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  const findCallback: (neighbor: [[number, number], number]) => boolean = (\n    neighbor\n  ) => {\n    return neighbor[0] === pairGrid[neighborX][neighborY];\n  };\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength &&\n      // !mazeGraph.get(currentNode)?.includes(pairGrid[neighborX][neighborY])\n      !mazeGraph.get(currentNode)?.find(findCallback)\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n"]},"metadata":{},"sourceType":"module"}