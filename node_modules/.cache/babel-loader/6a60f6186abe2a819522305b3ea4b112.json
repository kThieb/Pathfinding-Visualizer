{"ast":null,"code":"import _toConsumableArray from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _objectSpread from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _slicedToArray from\"/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import React,{useState}from\"react\";import\"./Visualizer.css\";import{Grid}from\"../Grid/Grid\";import{NavBar,NavItem,DropDownMenu,DropDownAlgo,DropDownSlider}from\"../NavBar/NavBar\";import{dijkstraWithWalls}from\"../helper_functions/shortestPathAlgorithms/dijkstra\";import{createEmptyMazeGraph,generateMazeGraph}from\"../helper_functions/mazeGenerators/mazeGraph\";import{constructGrid}from\"../helper_functions/constructGrid\";var NUMBER_OF_ROWS=24;var NUMBER_OF_COLUMN=11;// We define these constants out of the functional component\n// that the App uses to avoid re-running the functions to create\n// these each time there is a re-render\nvar _constructGrid=constructGrid(NUMBER_OF_ROWS,NUMBER_OF_COLUMN,[5,3],[5,20]),_constructGrid2=_slicedToArray(_constructGrid,3),firstGrid=_constructGrid2[0],firstStartNode=_constructGrid2[1],firstEndNode=_constructGrid2[2];var _createEmptyMazeGraph=createEmptyMazeGraph(NUMBER_OF_ROWS,NUMBER_OF_COLUMN,firstGrid),_createEmptyMazeGraph2=_slicedToArray(_createEmptyMazeGraph,2),firstpairGrid=_createEmptyMazeGraph2[0],mazeGraph=_createEmptyMazeGraph2[1];// Component rendering everything in the webpage.\nvar Visualizer=function Visualizer(){// States managing the grid\nvar _useState=useState(firstGrid),_useState2=_slicedToArray(_useState,2),grid=_useState2[0],setGrid=_useState2[1];var _useState3=useState(mazeGraph),_useState4=_slicedToArray(_useState3,2),maze=_useState4[0],setMaze=_useState4[1];var _useState5=useState(firstpairGrid),_useState6=_slicedToArray(_useState5,2),pairGrid=_useState6[0],setPairGrid=_useState6[1];var _useState7=useState(\"dijkstra\"),_useState8=_slicedToArray(_useState7,2),algorithm=_useState8[0],setAlgorithm=_useState8[1];var _useState9=useState(0.1),_useState10=_slicedToArray(_useState9,2),wallsDensity=_useState10[0],setWallsDensity=_useState10[1];var _useState11=useState(false),_useState12=_slicedToArray(_useState11,2),isVisualized=_useState12[0],setIsVisualized=_useState12[1];// const [mouseIsPressed, setMouseIsPressed] = useState(false);\n// States of the start and end node\nvar _useState13=useState(firstStartNode),_useState14=_slicedToArray(_useState13,2),startNode=_useState14[0],setStartNode=_useState14[1];var _useState15=useState(firstEndNode),_useState16=_slicedToArray(_useState15,2),endNode=_useState16[0],setEndNode=_useState16[1];// This function is there to visualize the algorithm chosen in the drop down menu\nvar visualizeAlgorithm=function visualizeAlgorithm(visited,path){var n=visited.length;var _loop=function _loop(i){setTimeout(function(){var newGrid=grid.slice();var node=visited[i];// define the x and y of the current node\nvar x=node.x;var y=node.y;var newNode=_objectSpread(_objectSpread({},node),{},{isVisited:true,className:\"grid-node visited-node\",waitClassChange:0});newGrid[x][y]=newNode;setGrid(newGrid);},50*i);};for(var i=0;i<n;i++){_loop(i);}var m=path.length;var _loop2=function _loop2(_i){setTimeout(function(){var newGrid=grid.slice();var node=path[_i];// define the x and y of the current node\nvar x=node.x;var y=node.y;var newNode=_objectSpread(_objectSpread({},node),{},{isShortestPath:true,className:\"grid-node shortest-path-node\",waitClassChange:0});newGrid[x][y]=newNode;setGrid(newGrid);},50*n+40*_i);};for(var _i=0;_i<m;_i++){_loop2(_i);}};// This function is passed to the drop down menu to handle the change of algorithm\nvar handleAlgorithmChange=function handleAlgorithmChange(algorithmName){setAlgorithm(algorithmName);};// This function changes the algorithm that will be run, at the moment only dijkstra is implemented\nvar chooseAlgorithm=function chooseAlgorithm(algorithmName){if(algorithmName===\"dijkstraWithWalls\"){return dijkstraWithWalls;}return dijkstraWithWalls;};// This function calls the generate maze function\nvar generateMaze=function generateMaze(){var newGrid=grid.slice();var _generateMazeGraph=generateMazeGraph(NUMBER_OF_ROWS,NUMBER_OF_COLUMN,newGrid,wallsDensity),_generateMazeGraph2=_slicedToArray(_generateMazeGraph,2),newPairGrid=_generateMazeGraph2[0],newMaze=_generateMazeGraph2[1];setGrid(newGrid);setPairGrid(newPairGrid);setMaze(newMaze);};// Reinitialize the the board\nvar reinitialize=function reinitialize(){var _constructGrid3=constructGrid(NUMBER_OF_ROWS,NUMBER_OF_COLUMN,[startNode.x,startNode.y],[endNode.x,endNode.y]),_constructGrid4=_slicedToArray(_constructGrid3,3),newGrid=_constructGrid4[0],newStartNode=_constructGrid4[1],newEndNode=_constructGrid4[2];var _createEmptyMazeGraph3=createEmptyMazeGraph(NUMBER_OF_ROWS,NUMBER_OF_COLUMN,newGrid),_createEmptyMazeGraph4=_slicedToArray(_createEmptyMazeGraph3,2),newPairGrid=_createEmptyMazeGraph4[0],newMaze=_createEmptyMazeGraph4[1];setGrid(newGrid);setPairGrid(newPairGrid);setMaze(newMaze);setStartNode(newStartNode);setEndNode(newEndNode);setIsVisualized(false);};// The following block of functions handles the making of walls in the grid\n// This feature is currently not used as it is not a good fit with the current direction of the app\n// const toggleWall: (x: number, y: number) => void = (x, y) => {\n//   const newGrid: node[][] = grid.slice();\n//   let newNode;\n//   if (!newGrid[x][y].isWall) {\n//     newNode = {\n//       ...newGrid[x][y],\n//       isWall: !newGrid[x][y].isWall,\n//       className: \"grid-node wall-node\",\n//     };\n//   } else {\n//     newNode = {\n//       ...newGrid[x][y],\n//       isWall: !newGrid[x][y].isWall,\n//       className: \"grid-node\",\n//     };\n//   }\n//   newGrid[x][y] = newNode;\n//   setGrid(newGrid);\n// };\n// // handles the case when the mouse button is down\n// const handleMouseDown: (x: number, y: number) => void = (x, y) => {\n//   toggleWall(x, y);\n//   setMouseIsPressed(false);\n// };\n// // handles the case whan the mouse button is down and you enter a node\n// const handleMouseEnter: (x: number, y: number) => void = (x, y) => {\n//   if (mouseIsPressed) {\n//     toggleWall(x, y);\n//   }\n// };\n// // handles the case when you mouse up\n// const handleMouseUp: () => void = () => {\n//   setMouseIsPressed(false);\n// };\n// Render the app\nreturn/*#__PURE__*/React.createElement(\"div\",{className:\"App\"},/*#__PURE__*/React.createElement(NavBar,null,/*#__PURE__*/React.createElement(\"li\",{className:\"reinitialize\"+(isVisualized?\" highlight\":\"\"),onClick:function onClick(e){reinitialize();}},/*#__PURE__*/React.createElement(\"p\",null,\"Reinitialize\")),/*#__PURE__*/React.createElement(\"li\",{className:\"generate-maze\",onClick:function onClick(e){generateMaze();}},/*#__PURE__*/React.createElement(\"p\",null,\"Generate Maze\")),/*#__PURE__*/React.createElement(NavItem,{icon:\"\",text:\"Maze options\"},/*#__PURE__*/React.createElement(DropDownMenu,{left:false},/*#__PURE__*/React.createElement(DropDownSlider,{minValue:0.1,maxValue:1,defaultValue:wallsDensity,text:\"Density of walls\",handleChangeWallsDensity:setWallsDensity}))),/*#__PURE__*/React.createElement(\"li\",{className:\"visualize-button\"+(isVisualized?\" grayed-out\":\"\"),onClick:function onClick(e){if(!isVisualized)visualizeAlgorithm.apply(void 0,_toConsumableArray(chooseAlgorithm(algorithm)(grid,pairGrid,maze,startNode,endNode)));setIsVisualized(true);}},/*#__PURE__*/React.createElement(\"p\",null,\"Visualize!\")),/*#__PURE__*/React.createElement(NavItem,{icon:\"\\u3233\",text:\"Algorithm\"},/*#__PURE__*/React.createElement(DropDownMenu,{left:true},/*#__PURE__*/React.createElement(DropDownAlgo,{changeAlgorithm:handleAlgorithmChange,algorithmName:\"dijkstraWithWalls\"},\"Dijkstra's Algorithm\")))),/*#__PURE__*/React.createElement(Grid,{grid:grid,pairGrid:pairGrid,maze:maze}));};export default Visualizer;","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/Visualizer/Visualizer.tsx"],"names":["React","useState","Grid","NavBar","NavItem","DropDownMenu","DropDownAlgo","DropDownSlider","dijkstraWithWalls","createEmptyMazeGraph","generateMazeGraph","constructGrid","NUMBER_OF_ROWS","NUMBER_OF_COLUMN","firstGrid","firstStartNode","firstEndNode","firstpairGrid","mazeGraph","Visualizer","grid","setGrid","maze","setMaze","pairGrid","setPairGrid","algorithm","setAlgorithm","wallsDensity","setWallsDensity","isVisualized","setIsVisualized","startNode","setStartNode","endNode","setEndNode","visualizeAlgorithm","visited","path","n","length","i","setTimeout","newGrid","slice","node","x","y","newNode","isVisited","className","waitClassChange","m","isShortestPath","handleAlgorithmChange","algorithmName","chooseAlgorithm","generateMaze","newPairGrid","newMaze","reinitialize","newStartNode","newEndNode","e"],"mappings":"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","sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport \"./Visualizer.css\";\nimport { Grid } from \"../Grid/Grid\";\nimport {\n  NavBar,\n  NavItem,\n  DropDownMenu,\n  DropDownAlgo,\n  DropDownSlider,\n} from \"../NavBar/NavBar\";\nimport { SecondaryHeader } from \"../SecondaryHeader/SecondaryHeader\";\nimport { node } from \"../helper_functions/usefulInterfaces\";\nimport {\n  dijkstra,\n  dijkstraWithWalls,\n} from \"../helper_functions/shortestPathAlgorithms/dijkstra\";\nimport {\n  createEmptyMazeGraph,\n  generateMazeGraph,\n} from \"../helper_functions/mazeGenerators/mazeGraph\";\nimport { constructGrid } from \"../helper_functions/constructGrid\";\n\nconst NUMBER_OF_ROWS: number = 24;\nconst NUMBER_OF_COLUMN: number = 11;\n\n// We define these constants out of the functional component\n// that the App uses to avoid re-running the functions to create\n// these each time there is a re-render\nconst [firstGrid, firstStartNode, firstEndNode] = constructGrid(\n  NUMBER_OF_ROWS,\n  NUMBER_OF_COLUMN,\n  [5, 3],\n  [5, 20]\n);\n\nconst [firstpairGrid, mazeGraph] = createEmptyMazeGraph(\n  NUMBER_OF_ROWS,\n  NUMBER_OF_COLUMN,\n  firstGrid\n);\n\n// Component rendering everything in the webpage.\nconst Visualizer: React.FC = () => {\n  // States managing the grid\n  const [grid, setGrid] = useState(firstGrid);\n  const [maze, setMaze] = useState(mazeGraph);\n  const [pairGrid, setPairGrid] = useState(firstpairGrid);\n  const [algorithm, setAlgorithm] = useState(\"dijkstra\");\n  const [wallsDensity, setWallsDensity] = useState(0.1);\n  const [isVisualized, setIsVisualized] = useState(false);\n  // const [mouseIsPressed, setMouseIsPressed] = useState(false);\n\n  // States of the start and end node\n  const [startNode, setStartNode] = useState(firstStartNode);\n  const [endNode, setEndNode] = useState(firstEndNode);\n\n  // This function is there to visualize the algorithm chosen in the drop down menu\n  const visualizeAlgorithm: (visited: node[], path: node[]) => void = (\n    visited,\n    path\n  ) => {\n    const n = visited.length;\n    for (let i: number = 0; i < n; i++) {\n      setTimeout(() => {\n        const newGrid = grid.slice();\n        const node = visited[i];\n        // define the x and y of the current node\n        const x: number = node.x;\n        const y: number = node.y;\n        const newNode = {\n          ...node,\n          isVisited: true,\n          className: \"grid-node visited-node\",\n          waitClassChange: 0,\n        };\n        newGrid[x][y] = newNode;\n        setGrid(newGrid);\n      }, 50 * i);\n    }\n\n    const m = path.length;\n    for (let i: number = 0; i < m; i++) {\n      setTimeout(() => {\n        const newGrid = grid.slice();\n        const node = path[i];\n        // define the x and y of the current node\n        const x: number = node.x;\n        const y: number = node.y;\n        const newNode = {\n          ...node,\n          isShortestPath: true,\n          className: \"grid-node shortest-path-node\",\n          waitClassChange: 0,\n        };\n        newGrid[x][y] = newNode;\n        setGrid(newGrid);\n      }, 50 * n + 40 * i);\n    }\n  };\n\n  // This function is passed to the drop down menu to handle the change of algorithm\n  const handleAlgorithmChange: (algorithmName: string) => void = (\n    algorithmName\n  ) => {\n    setAlgorithm(algorithmName);\n  };\n\n  // This function changes the algorithm that will be run, at the moment only dijkstra is implemented\n  const chooseAlgorithm: (\n    algorithmName: string\n  ) => (\n    grid: node[][],\n    pairGrid: [number, number][][],\n    mazeGraph: Map<[number, number], [number, number][]>,\n    startNode: node,\n    endNode: node\n  ) => [node[], node[]] = (algorithmName) => {\n    if (algorithmName === \"dijkstraWithWalls\") {\n      return dijkstraWithWalls;\n    }\n    return dijkstraWithWalls;\n  };\n\n  // This function calls the generate maze function\n  const generateMaze: () => void = () => {\n    const newGrid = grid.slice();\n    const [newPairGrid, newMaze] = generateMazeGraph(\n      NUMBER_OF_ROWS,\n      NUMBER_OF_COLUMN,\n      newGrid,\n      wallsDensity\n    );\n    setGrid(newGrid);\n    setPairGrid(newPairGrid);\n    setMaze(newMaze);\n  };\n\n  // Reinitialize the the board\n  const reinitialize: () => void = () => {\n    const [newGrid, newStartNode, newEndNode] = constructGrid(\n      NUMBER_OF_ROWS,\n      NUMBER_OF_COLUMN,\n      [startNode.x, startNode.y],\n      [endNode.x, endNode.y]\n    );\n    const [newPairGrid, newMaze] = createEmptyMazeGraph(\n      NUMBER_OF_ROWS,\n      NUMBER_OF_COLUMN,\n      newGrid\n    );\n    setGrid(newGrid);\n    setPairGrid(newPairGrid);\n    setMaze(newMaze);\n    setStartNode(newStartNode);\n    setEndNode(newEndNode);\n    setIsVisualized(false);\n  };\n\n  // The following block of functions handles the making of walls in the grid\n  // This feature is currently not used as it is not a good fit with the current direction of the app\n\n  // const toggleWall: (x: number, y: number) => void = (x, y) => {\n  //   const newGrid: node[][] = grid.slice();\n  //   let newNode;\n  //   if (!newGrid[x][y].isWall) {\n  //     newNode = {\n  //       ...newGrid[x][y],\n  //       isWall: !newGrid[x][y].isWall,\n  //       className: \"grid-node wall-node\",\n  //     };\n  //   } else {\n  //     newNode = {\n  //       ...newGrid[x][y],\n  //       isWall: !newGrid[x][y].isWall,\n  //       className: \"grid-node\",\n  //     };\n  //   }\n  //   newGrid[x][y] = newNode;\n  //   setGrid(newGrid);\n  // };\n\n  // // handles the case when the mouse button is down\n  // const handleMouseDown: (x: number, y: number) => void = (x, y) => {\n  //   toggleWall(x, y);\n  //   setMouseIsPressed(false);\n  // };\n\n  // // handles the case whan the mouse button is down and you enter a node\n  // const handleMouseEnter: (x: number, y: number) => void = (x, y) => {\n  //   if (mouseIsPressed) {\n  //     toggleWall(x, y);\n  //   }\n  // };\n\n  // // handles the case when you mouse up\n  // const handleMouseUp: () => void = () => {\n  //   setMouseIsPressed(false);\n  // };\n\n  // Render the app\n  return (\n    <div className=\"App\">\n      <NavBar>\n        {\n          <li\n            className={\"reinitialize\" + (isVisualized ? \" highlight\" : \"\")}\n            onClick={(e) => {\n              reinitialize();\n            }}\n          >\n            <p>Reinitialize</p>\n          </li>\n        }\n        {\n          <li\n            className=\"generate-maze\"\n            onClick={(e) => {\n              generateMaze();\n            }}\n          >\n            <p>Generate Maze</p>\n          </li>\n        }\n        <NavItem icon=\"\" text=\"Maze options\">\n          <DropDownMenu left={false}>\n            <DropDownSlider\n              minValue={0.1}\n              maxValue={1}\n              defaultValue={wallsDensity}\n              text=\"Density of walls\"\n              handleChangeWallsDensity={setWallsDensity}\n            ></DropDownSlider>\n          </DropDownMenu>\n        </NavItem>\n        {\n          <li\n            className={\"visualize-button\" + (isVisualized ? \" grayed-out\" : \"\")}\n            onClick={(e) => {\n              if (!isVisualized)\n                visualizeAlgorithm(\n                  ...chooseAlgorithm(algorithm)(\n                    grid,\n                    pairGrid,\n                    maze,\n                    startNode,\n                    endNode\n                  )\n                );\n              setIsVisualized(true);\n            }}\n          >\n            <p>Visualize!</p>\n          </li>\n        }\n        <NavItem icon=\"&#12851;\" text=\"Algorithm\">\n          <DropDownMenu left={true}>\n            <DropDownAlgo\n              changeAlgorithm={handleAlgorithmChange}\n              algorithmName=\"dijkstraWithWalls\"\n            >\n              Dijkstra's Algorithm\n            </DropDownAlgo>\n            {/* <DropDownAlgo\n              changeAlgorithm={handleAlgorithmChange}\n              algorithmName=\"A*\"\n            >\n              A* Algorithm\n            </DropDownAlgo> */}\n          </DropDownMenu>\n        </NavItem>\n      </NavBar>\n      {/* <SecondaryHeader>\n        <button\n          className=\"visualize-button\"\n          onClick={(e) => {\n            visualizeAlgorithm(\n              ...chooseAlgorithm(algorithm)(\n                grid,\n                pairGrid,\n                mazeGraph,\n                startNode,\n                endNode\n              )\n            );\n          }}\n        >\n          Visualize the path!\n        </button>\n      </SecondaryHeader> */}\n      <Grid grid={grid} pairGrid={pairGrid} maze={maze} />\n    </div>\n  );\n};\n\nexport default Visualizer;\n"]},"metadata":{},"sourceType":"module"}