{"ast":null,"code":"export class BinaryHeap {\n  constructor(scoreFunction) {\n    this.content = void 0;\n    this.scoreFunction = void 0;\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  push(element) {\n    this.content.push(element);\n    this.bubbleUp(this.content.length - 1);\n  }\n\n  pop() {\n    let result = this.content[0];\n    let end = this.content.pop();\n\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n\n    return result;\n  }\n\n  remove(node) {\n    let length = this.content.length; // To remove a value, we must search through the array to find\n    // it.\n\n    for (var i = 0; i < length; i++) {\n      if (this.content[i] !== node) continue; // When it is found, the process seen in 'pop' is repeated\n      // to fill up the hole.\n\n      let end = this.content.pop(); // If the element we popped was the one we needed to remove,\n      // we're done.\n\n      if (i === length - 1) break; // Otherwise, we replace the removed element with the popped\n      // one, and allow it to float up or sink down as appropriate.\n\n      this.content[i] = end;\n      this.bubbleUp(i);\n      this.sinkDown(i);\n      break;\n    }\n  }\n\n  size() {\n    return this.content.length;\n  }\n\n  bubbleUp(n) {\n    // Fetch the element that has to be moved.\n    let element = this.content[n],\n        score = this.scoreFunction(ensure(element)); // When at 0, an element can not go up any further.\n\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      let parentN = Math.floor((n + 1) / 2) - 1,\n          parent = this.content[parentN]; // If the parent has a lesser score, things are in order and we\n      // are done.\n\n      if (score >= this.scoreFunction(ensure(parent))) break; // Otherwise, swap the parent with the current element and\n      // continue.\n\n      this.content[parentN] = element;\n      this.content[n] = parent;\n      n = parentN;\n    }\n  }\n\n  sinkDown(n) {\n    // Look up the target element and its score.\n    var length = this.content.length,\n        element = this.content[n],\n        elemScore = this.scoreFunction(ensure(element));\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) * 2,\n          child1N = child2N - 1; // This is used to store the new position of the element,\n      // if any.\n\n      var swap = null; // If the first child exists (is inside the array)...\n\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N],\n            child1Score = this.scoreFunction(ensure(child1)); // If the score is less than our element's, we need to swap.\n\n        if (child1Score < elemScore) swap = child1N;\n      } // Do the same checks for the other child.\n\n\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n            child2Score = this.scoreFunction(ensure(child2));\n        if (child2Score < (swap == null ? elemScore : child2Score)) swap = child2N;\n      } // No need to swap further, we are done.\n\n\n      if (swap == null) break; // Otherwise, swap and continue.\n\n      this.content[n] = this.content[swap];\n      this.content[swap] = element;\n      n = swap;\n    }\n  }\n\n}\n\nfunction ensure(argument, message = \"This value was promised to be there.\") {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helper_functions/binaryHeap.ts"],"names":["BinaryHeap","constructor","scoreFunction","content","push","element","bubbleUp","length","pop","result","end","sinkDown","remove","node","i","size","n","score","ensure","parentN","Math","floor","parent","elemScore","child2N","child1N","swap","child1","child1Score","child2","child2Score","argument","message","undefined","TypeError"],"mappings":"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","sourcesContent":["export class BinaryHeap<T> {\n  content: (T | undefined)[];\n  scoreFunction: (x: T) => number;\n\n  constructor(scoreFunction: (x: T) => number) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  push(element: T) {\n    this.content.push(element);\n    this.bubbleUp(this.content.length - 1);\n  }\n\n  pop(): T | undefined {\n    let result = this.content[0];\n    let end = this.content.pop();\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n    return result;\n  }\n\n  remove(node: T) {\n    let length = this.content.length;\n    // To remove a value, we must search through the array to find\n    // it.\n    for (var i = 0; i < length; i++) {\n      if (this.content[i] !== node) continue;\n      // When it is found, the process seen in 'pop' is repeated\n      // to fill up the hole.\n      let end = this.content.pop();\n      // If the element we popped was the one we needed to remove,\n      // we're done.\n      if (i === length - 1) break;\n      // Otherwise, we replace the removed element with the popped\n      // one, and allow it to float up or sink down as appropriate.\n      this.content[i] = end;\n      this.bubbleUp(i);\n      this.sinkDown(i);\n      break;\n    }\n  }\n\n  size() {\n    return this.content.length;\n  }\n\n  private bubbleUp(n: number) {\n    // Fetch the element that has to be moved.\n    let element = this.content[n],\n      score = this.scoreFunction(ensure(element));\n    // When at 0, an element can not go up any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      let parentN = Math.floor((n + 1) / 2) - 1,\n        parent = this.content[parentN];\n      // If the parent has a lesser score, things are in order and we\n      // are done.\n      if (score >= this.scoreFunction(ensure(parent))) break;\n\n      // Otherwise, swap the parent with the current element and\n      // continue.\n      this.content[parentN] = element;\n      this.content[n] = parent;\n      n = parentN;\n    }\n  }\n\n  private sinkDown(n: number) {\n    // Look up the target element and its score.\n    var length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(ensure(element));\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) * 2,\n        child1N = child2N - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      var swap = null;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N],\n          child1Score = this.scoreFunction(ensure(child1));\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) swap = child1N;\n      }\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n          child2Score = this.scoreFunction(ensure(child2));\n        if (child2Score < (swap == null ? elemScore : child2Score))\n          swap = child2N;\n      }\n\n      // No need to swap further, we are done.\n      if (swap == null) break;\n\n      // Otherwise, swap and continue.\n      this.content[n] = this.content[swap];\n      this.content[swap] = element;\n      n = swap;\n    }\n  }\n}\n\nfunction ensure<T>(\n  argument: T | undefined | null,\n  message: string = \"This value was promised to be there.\"\n): T {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}\n"]},"metadata":{},"sourceType":"module"}