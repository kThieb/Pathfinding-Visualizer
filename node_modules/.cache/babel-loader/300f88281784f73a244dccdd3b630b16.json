{"ast":null,"code":"var _jsxFileName = \"/home/kevin/Documents/Projects/Simple-Visualizer/simple-visualizer/src/Visualizer/Visualizer.tsx\";\nimport React, { useState } from \"react\";\nimport \"./Visualizer.css\";\nimport { Grid } from \"../Grid/Grid\";\nimport { NavBar, NavItem, DropDownMenu, DropDownItem } from \"../NavBar/NavBar\";\nimport { dijkstraWithWalls } from \"../helper_functions/shortestPathAlgorithms/dijkstra\";\nimport { createEmptyMazeGraph } from \"../helper_functions/mazeGenerators/mazeGraph\";\nimport { constructGrid } from \"../helper_functions/constructGrid\";\nconst NUMBER_OF_ROWS = 35;\nconst NUMBER_OF_COLUMN = 16; // We define these constants out of the functional component\n// that the App uses to avoid re-running the functions to create\n// these each time there is a re-render\n\nconst [firstGrid, firstStartNode, firstEndNode] = constructGrid(NUMBER_OF_ROWS, NUMBER_OF_COLUMN, [7, 8], [7, 26]);\nconst [firstpairGrid, mazeGraph] = createEmptyMazeGraph(NUMBER_OF_ROWS, NUMBER_OF_COLUMN, firstGrid); // Component rendering everything in the webpage.\n\nconst Visualizer = () => {\n  // States managing the grid\n  const [grid, setGrid] = useState(firstGrid);\n  const [maze, setMaze] = useState(mazeGraph);\n  const [pairGrid, setPairGrid] = useState(firstpairGrid);\n  const [algorithm, setAlgorithm] = useState(\"dijkstra\");\n  const [mouseIsPressed, setMouseIsPressed] = useState(false); // States of the start and end node\n\n  const [startNode, setStartNode] = useState(firstStartNode);\n  const [endNode, setEndNode] = useState(firstEndNode); // This function is there to visualize the algorithm chosen in the drop down menu\n\n  const visualizeAlgorithm = (visited, path) => {\n    const n = visited.length;\n\n    for (let i = 0; i < n; i++) {\n      setTimeout(() => {\n        const newGrid = grid.slice();\n        const node = visited[i]; // define the x and y of the current node\n\n        const x = node.x;\n        const y = node.y;\n        const newNode = { ...node,\n          isVisited: true,\n          className: \"grid-node visited-node\",\n          waitClassChange: 0\n        };\n        newGrid[x][y] = newNode;\n        setGrid(newGrid);\n      }, 50 * i);\n    }\n\n    const m = path.length;\n\n    for (let i = 0; i < m; i++) {\n      setTimeout(() => {\n        const newGrid = grid.slice();\n        const node = path[i]; // define the x and y of the current node\n\n        const x = node.x;\n        const y = node.y;\n        const newNode = { ...node,\n          isShortestPath: true,\n          className: \"grid-node shortest-path-node\",\n          waitClassChange: 0\n        };\n        newGrid[x][y] = newNode;\n        setGrid(newGrid);\n      }, 50 * n + 40 * i);\n    }\n  }; // This function is passed to the drop down menu to handle the change of algorithm\n\n\n  const handleAlgorithmChange = algorithmName => {\n    setAlgorithm(algorithmName);\n  }; // This function changes the algorithm that will be run, at the moment only dijkstra is implemented\n\n\n  const chooseAlgorithm = algorithmName => {\n    if (algorithmName === \"dijkstraWithWalls\") {\n      return dijkstraWithWalls;\n    }\n\n    return dijkstraWithWalls;\n  }; // The following block of functions handles the making of walls in the grid\n  // This feature is currently not used as it is not a good fit with the current direction of the app\n  // const toggleWall: (x: number, y: number) => void = (x, y) => {\n  //   const newGrid: node[][] = grid.slice();\n  //   let newNode;\n  //   if (!newGrid[x][y].isWall) {\n  //     newNode = {\n  //       ...newGrid[x][y],\n  //       isWall: !newGrid[x][y].isWall,\n  //       className: \"grid-node wall-node\",\n  //     };\n  //   } else {\n  //     newNode = {\n  //       ...newGrid[x][y],\n  //       isWall: !newGrid[x][y].isWall,\n  //       className: \"grid-node\",\n  //     };\n  //   }\n  //   newGrid[x][y] = newNode;\n  //   setGrid(newGrid);\n  // };\n  // // handles the case when the mouse button is down\n  // const handleMouseDown: (x: number, y: number) => void = (x, y) => {\n  //   toggleWall(x, y);\n  //   setMouseIsPressed(false);\n  // };\n  // // handles the case whan the mouse button is down and you enter a node\n  // const handleMouseEnter: (x: number, y: number) => void = (x, y) => {\n  //   if (mouseIsPressed) {\n  //     toggleWall(x, y);\n  //   }\n  // };\n  // // handles the case when you mouse up\n  // const handleMouseUp: () => void = () => {\n  //   setMouseIsPressed(false);\n  // };\n  // Render the app\n\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"App\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 159,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(NavBar, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 160,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(NavItem, {\n    icon: \"\\u3233\",\n    text: \"\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 161,\n      columnNumber: 9\n    }\n  }), /*#__PURE__*/React.createElement(\"li\", {\n    className: \"nav-item\",\n    onClick: e => {\n      visualizeAlgorithm(...chooseAlgorithm(algorithm)(grid, pairGrid, mazeGraph, startNode, endNode));\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 163,\n      columnNumber: 11\n    }\n  }, /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 177,\n      columnNumber: 13\n    }\n  }, \"Visualize\")), /*#__PURE__*/React.createElement(NavItem, {\n    icon: \"\\u3233\",\n    text: \"Algorithm\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 180,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(DropDownMenu, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 181,\n      columnNumber: 11\n    }\n  }, /*#__PURE__*/React.createElement(DropDownItem, {\n    changeAlgorithm: handleAlgorithmChange,\n    algorithmName: \"dijkstra\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 182,\n      columnNumber: 13\n    }\n  }, \"Dijkstra's algorithm\"), /*#__PURE__*/React.createElement(DropDownItem, {\n    changeAlgorithm: handleAlgorithmChange,\n    algorithmName: \"dijkstraWithWalls\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 188,\n      columnNumber: 13\n    }\n  }, \"Dijkstra's algorithm with a maze\"), /*#__PURE__*/React.createElement(DropDownItem, {\n    changeAlgorithm: handleAlgorithmChange,\n    algorithmName: \"A*\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 194,\n      columnNumber: 13\n    }\n  }, \"A* Algorithm\"), /*#__PURE__*/React.createElement(DropDownItem, {\n    changeAlgorithm: handleAlgorithmChange,\n    algorithmName: \"greedy\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 200,\n      columnNumber: 13\n    }\n  }, \"Greedy Algorithm\")))), /*#__PURE__*/React.createElement(Grid, {\n    grid: grid,\n    pairGrid: pairGrid,\n    maze: maze,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 227,\n      columnNumber: 7\n    }\n  }));\n};\n\nexport default Visualizer;","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/simple-visualizer/src/Visualizer/Visualizer.tsx"],"names":["React","useState","Grid","NavBar","NavItem","DropDownMenu","DropDownItem","dijkstraWithWalls","createEmptyMazeGraph","constructGrid","NUMBER_OF_ROWS","NUMBER_OF_COLUMN","firstGrid","firstStartNode","firstEndNode","firstpairGrid","mazeGraph","Visualizer","grid","setGrid","maze","setMaze","pairGrid","setPairGrid","algorithm","setAlgorithm","mouseIsPressed","setMouseIsPressed","startNode","setStartNode","endNode","setEndNode","visualizeAlgorithm","visited","path","n","length","i","setTimeout","newGrid","slice","node","x","y","newNode","isVisited","className","waitClassChange","m","isShortestPath","handleAlgorithmChange","algorithmName","chooseAlgorithm","e"],"mappings":"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","sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport \"./Visualizer.css\";\nimport { Grid } from \"../Grid/Grid\";\nimport { NavBar, NavItem, DropDownMenu, DropDownItem } from \"../NavBar/NavBar\";\nimport { SecondaryHeader } from \"../SecondaryHeader/SecondaryHeader\";\nimport { node } from \"../helper_functions/usefulInterfaces\";\nimport {\n  dijkstra,\n  dijkstraWithWalls,\n} from \"../helper_functions/shortestPathAlgorithms/dijkstra\";\nimport {\n  createEmptyMazeGraph,\n  generateMazeGraph,\n} from \"../helper_functions/mazeGenerators/mazeGraph\";\nimport { constructGrid } from \"../helper_functions/constructGrid\";\n\nconst NUMBER_OF_ROWS: number = 35;\nconst NUMBER_OF_COLUMN: number = 16;\n\n// We define these constants out of the functional component\n// that the App uses to avoid re-running the functions to create\n// these each time there is a re-render\nconst [firstGrid, firstStartNode, firstEndNode] = constructGrid(\n  NUMBER_OF_ROWS,\n  NUMBER_OF_COLUMN,\n  [7, 8],\n  [7, 26]\n);\n\nconst [firstpairGrid, mazeGraph] = createEmptyMazeGraph(\n  NUMBER_OF_ROWS,\n  NUMBER_OF_COLUMN,\n  firstGrid\n);\n\n// Component rendering everything in the webpage.\nconst Visualizer: React.FC = () => {\n  // States managing the grid\n  const [grid, setGrid] = useState(firstGrid);\n  const [maze, setMaze] = useState(mazeGraph);\n  const [pairGrid, setPairGrid] = useState(firstpairGrid);\n  const [algorithm, setAlgorithm] = useState(\"dijkstra\");\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n\n  // States of the start and end node\n  const [startNode, setStartNode] = useState(firstStartNode);\n  const [endNode, setEndNode] = useState(firstEndNode);\n\n  // This function is there to visualize the algorithm chosen in the drop down menu\n  const visualizeAlgorithm: (visited: node[], path: node[]) => void = (\n    visited,\n    path\n  ) => {\n    const n = visited.length;\n    for (let i: number = 0; i < n; i++) {\n      setTimeout(() => {\n        const newGrid = grid.slice();\n        const node = visited[i];\n        // define the x and y of the current node\n        const x: number = node.x;\n        const y: number = node.y;\n        const newNode = {\n          ...node,\n          isVisited: true,\n          className: \"grid-node visited-node\",\n          waitClassChange: 0,\n        };\n        newGrid[x][y] = newNode;\n        setGrid(newGrid);\n      }, 50 * i);\n    }\n\n    const m = path.length;\n    for (let i: number = 0; i < m; i++) {\n      setTimeout(() => {\n        const newGrid = grid.slice();\n        const node = path[i];\n        // define the x and y of the current node\n        const x: number = node.x;\n        const y: number = node.y;\n        const newNode = {\n          ...node,\n          isShortestPath: true,\n          className: \"grid-node shortest-path-node\",\n          waitClassChange: 0,\n        };\n        newGrid[x][y] = newNode;\n        setGrid(newGrid);\n      }, 50 * n + 40 * i);\n    }\n  };\n\n  // This function is passed to the drop down menu to handle the change of algorithm\n  const handleAlgorithmChange: (algorithmName: string) => void = (\n    algorithmName\n  ) => {\n    setAlgorithm(algorithmName);\n  };\n\n  // This function changes the algorithm that will be run, at the moment only dijkstra is implemented\n  const chooseAlgorithm: (\n    algorithmName: string\n  ) => (\n    grid: node[][],\n    pairGrid: [number, number][][],\n    mazeGraph: Map<[number, number], [number, number][]>,\n    startNode: node,\n    endNode: node\n  ) => [node[], node[]] = (algorithmName) => {\n    if (algorithmName === \"dijkstraWithWalls\") {\n      return dijkstraWithWalls;\n    }\n    return dijkstraWithWalls;\n  };\n\n  // The following block of functions handles the making of walls in the grid\n  // This feature is currently not used as it is not a good fit with the current direction of the app\n\n  // const toggleWall: (x: number, y: number) => void = (x, y) => {\n  //   const newGrid: node[][] = grid.slice();\n  //   let newNode;\n  //   if (!newGrid[x][y].isWall) {\n  //     newNode = {\n  //       ...newGrid[x][y],\n  //       isWall: !newGrid[x][y].isWall,\n  //       className: \"grid-node wall-node\",\n  //     };\n  //   } else {\n  //     newNode = {\n  //       ...newGrid[x][y],\n  //       isWall: !newGrid[x][y].isWall,\n  //       className: \"grid-node\",\n  //     };\n  //   }\n  //   newGrid[x][y] = newNode;\n  //   setGrid(newGrid);\n  // };\n\n  // // handles the case when the mouse button is down\n  // const handleMouseDown: (x: number, y: number) => void = (x, y) => {\n  //   toggleWall(x, y);\n  //   setMouseIsPressed(false);\n  // };\n\n  // // handles the case whan the mouse button is down and you enter a node\n  // const handleMouseEnter: (x: number, y: number) => void = (x, y) => {\n  //   if (mouseIsPressed) {\n  //     toggleWall(x, y);\n  //   }\n  // };\n\n  // // handles the case when you mouse up\n  // const handleMouseUp: () => void = () => {\n  //   setMouseIsPressed(false);\n  // };\n\n  // Render the app\n  return (\n    <div className=\"App\">\n      <NavBar>\n        <NavItem icon=\"&#12851;\" text=\"\"></NavItem>\n        {\n          <li\n            className=\"nav-item\"\n            onClick={(e) => {\n              visualizeAlgorithm(\n                ...chooseAlgorithm(algorithm)(\n                  grid,\n                  pairGrid,\n                  mazeGraph,\n                  startNode,\n                  endNode\n                )\n              );\n            }}\n          >\n            <p>Visualize</p>\n          </li>\n        }\n        <NavItem icon=\"&#12851;\" text=\"Algorithm\">\n          <DropDownMenu>\n            <DropDownItem\n              changeAlgorithm={handleAlgorithmChange}\n              algorithmName=\"dijkstra\"\n            >\n              Dijkstra's algorithm\n            </DropDownItem>\n            <DropDownItem\n              changeAlgorithm={handleAlgorithmChange}\n              algorithmName=\"dijkstraWithWalls\"\n            >\n              Dijkstra's algorithm with a maze\n            </DropDownItem>\n            <DropDownItem\n              changeAlgorithm={handleAlgorithmChange}\n              algorithmName=\"A*\"\n            >\n              A* Algorithm\n            </DropDownItem>\n            <DropDownItem\n              changeAlgorithm={handleAlgorithmChange}\n              algorithmName=\"greedy\"\n            >\n              Greedy Algorithm\n            </DropDownItem>\n          </DropDownMenu>\n        </NavItem>\n      </NavBar>\n      {/* <SecondaryHeader>\n        <button\n          className=\"visualize-button\"\n          onClick={(e) => {\n            visualizeAlgorithm(\n              ...chooseAlgorithm(algorithm)(\n                grid,\n                pairGrid,\n                mazeGraph,\n                startNode,\n                endNode\n              )\n            );\n          }}\n        >\n          Visualize the path!\n        </button>\n      </SecondaryHeader> */}\n      <Grid grid={grid} pairGrid={pairGrid} maze={maze} />\n    </div>\n  );\n};\n\nexport default Visualizer;\n"]},"metadata":{},"sourceType":"module"}