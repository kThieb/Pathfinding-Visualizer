{"ast":null,"code":"import { ensure } from \"../ensureNotUndefined\";\nexport class BinaryHeap {\n  constructor(scoreFunction) {\n    this.content = void 0;\n    this.scoreFunction = void 0;\n    this.compare = void 0;\n    this.index = void 0;\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n    this.index = 1;\n  } // compare: (a: [T, number], b: [T, number]) => boolean = (a, b) => {\n  //   if (this.scoreFunction(a[0]) !== this.scoreFunction(b[0])) {\n  //     return this.scoreFunction(a[0]) < this.scoreFunction(b[0]);\n  //   }\n  //   return a[1] < b[1];\n  // };\n\n\n  push(element) {\n    this.content.push([element, this.index++]);\n    this.bubbleUp(this.content.length - 1);\n  }\n\n  pop() {\n    let result = ensure(this.content[0]);\n    let end = this.content.pop();\n\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n\n    return ensure(result)[0];\n  }\n\n  remove(node) {\n    let length = this.content.length; // To remove a value, we must search through the array to find\n    // it.\n\n    for (let i = 0; i < length; i++) {\n      if (ensure(this.content[i])[0] !== node) continue; // When it is found, the process seen in 'pop' is repeated\n      // to fill up the hole.\n\n      let end = this.content.pop(); // If the element we popped was the one we needed to remove,\n      // we're done.\n\n      if (i === length - 1) break; // Otherwise, we replace the removed element with the popped\n      // one, and allow it to float up or sink down as appropriate.\n\n      this.content[i] = end;\n      this.bubbleUp(i);\n      this.sinkDown(i);\n      break;\n    }\n  }\n\n  size() {\n    return this.content.length;\n  }\n\n  bubbleUp(n) {\n    // Fetch the element that has to be moved.\n    let element = ensure(this.content[n]); // When at 0, an element can not go up any further.\n\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      let parentN = Math.floor((n + 1) / 2) - 1,\n          parent = ensure(this.content[parentN]); // If the parent has a lesser score, things are in order and we\n      // are done.\n      // if (\n      //   score > this.scoreFunction(ensure(parent)[0]) ||\n      //   (score === this.scoreFunction(ensure(parent)[0]) &&\n      //     ensure(element)[1] > ensure(parent)[1])\n      // )\n      //   break;\n\n      if (this.compare(parent, element)) break; // Otherwise, swap the parent with the current element and\n      // continue.\n\n      this.content[parentN] = element;\n      this.content[n] = parent;\n      n = parentN;\n    }\n  }\n\n  sinkDown(n) {\n    // Look up the target element and its score.\n    let length = this.content.length,\n        element = ensure(this.content[n]);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      let child2N = (n + 1) * 2,\n          child1N = child2N - 1;\n      let swap = n; // This is used to store the new position of the element, if any.\n      // If the first child exists (is inside the array)...\n\n      if (child1N < length && this.compare(ensure(this.content[child1N]), element)) swap = child1N;\n      if (child2N < length && this.compare(ensure(this.content[child2N]), ensure(this.content[swap]))) swap = child2N; // If the order is good, we exit the loop\n\n      if (swap === n) break; // Otherwise, swap and continue.\n\n      this.content[n] = this.content[swap];\n      this.content[swap] = element;\n      n = swap;\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helperFunctions/dataStructures/binaryHeap.ts"],"names":["ensure","BinaryHeap","constructor","scoreFunction","content","compare","index","push","element","bubbleUp","length","pop","result","end","sinkDown","remove","node","i","size","n","parentN","Math","floor","parent","child2N","child1N","swap"],"mappings":"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","sourcesContent":["import { ensure } from \"../ensureNotUndefined\";\n\nexport class BinaryHeap<T> {\n  content: ([T, number] | undefined)[];\n  scoreFunction: (x: T) => number;\n  compare: (a: [T, number], b: [T, number]) => boolean;\n  index: number;\n\n  constructor(scoreFunction: (x: T) => number) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n    this.index = 1;\n  }\n\n  // compare: (a: [T, number], b: [T, number]) => boolean = (a, b) => {\n  //   if (this.scoreFunction(a[0]) !== this.scoreFunction(b[0])) {\n  //     return this.scoreFunction(a[0]) < this.scoreFunction(b[0]);\n  //   }\n  //   return a[1] < b[1];\n  // };\n\n  push(element: T) {\n    this.content.push([element, this.index++]);\n    this.bubbleUp(this.content.length - 1);\n  }\n\n  pop(): T | undefined {\n    let result: [T, number] = ensure(this.content[0]);\n    let end: [T, number] | undefined = this.content.pop();\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n    return ensure(result)[0];\n  }\n\n  remove(node: T) {\n    let length: number = this.content.length;\n    // To remove a value, we must search through the array to find\n    // it.\n    for (let i: number = 0; i < length; i++) {\n      if (ensure(this.content[i])[0] !== node) continue;\n      // When it is found, the process seen in 'pop' is repeated\n      // to fill up the hole.\n      let end: [T, number] | undefined = this.content.pop();\n      // If the element we popped was the one we needed to remove,\n      // we're done.\n      if (i === length - 1) break;\n      // Otherwise, we replace the removed element with the popped\n      // one, and allow it to float up or sink down as appropriate.\n      this.content[i] = end;\n      this.bubbleUp(i);\n      this.sinkDown(i);\n      break;\n    }\n  }\n\n  size() {\n    return this.content.length;\n  }\n\n  private bubbleUp(n: number) {\n    // Fetch the element that has to be moved.\n    let element: [T, number] = ensure(this.content[n]);\n    // When at 0, an element can not go up any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      let parentN: number = Math.floor((n + 1) / 2) - 1,\n        parent: [T, number] = ensure(this.content[parentN]);\n      // If the parent has a lesser score, things are in order and we\n      // are done.\n      // if (\n      //   score > this.scoreFunction(ensure(parent)[0]) ||\n      //   (score === this.scoreFunction(ensure(parent)[0]) &&\n      //     ensure(element)[1] > ensure(parent)[1])\n      // )\n      //   break;\n      if (this.compare(parent, element)) break;\n\n      // Otherwise, swap the parent with the current element and\n      // continue.\n      this.content[parentN] = element;\n      this.content[n] = parent;\n      n = parentN;\n    }\n  }\n\n  private sinkDown(n: number) {\n    // Look up the target element and its score.\n    let length: number = this.content.length,\n      element: [T, number] = ensure(this.content[n]);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      let child2N: number = (n + 1) * 2,\n        child1N: number = child2N - 1;\n      let swap: number = n;\n      // This is used to store the new position of the element, if any.\n      // If the first child exists (is inside the array)...\n      if (\n        child1N < length &&\n        this.compare(ensure(this.content[child1N]), element)\n      )\n        swap = child1N;\n      if (\n        child2N < length &&\n        this.compare(ensure(this.content[child2N]), ensure(this.content[swap]))\n      )\n        swap = child2N;\n\n      // If the order is good, we exit the loop\n      if (swap === n) break;\n\n      // Otherwise, swap and continue.\n      this.content[n] = this.content[swap];\n      this.content[swap] = element;\n      n = swap;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}