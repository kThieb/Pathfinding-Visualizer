{"ast":null,"code":"import { BinaryHeap } from \"../dataStructures/binaryHeap\";\nimport { retrievePath } from \"./retrievePath\";\nimport { ensure } from \"../ensureNotUndefined\";\nexport const aStar = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n        n = grid[0].length; // Initialize the distances array\n\n  const distances = [];\n\n  for (let i = 0; i < m; i++) {\n    distances.push([]);\n\n    for (let j = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0; // Initialize the predecessor array\n\n  const predecessor = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode; // Initialize the visited nodes array\n\n  let visited = []; //   Initialize the Binary Heap\n\n  let pq = new BinaryHeap((a, b) => {\n    let dA = manhattanDistance(a[0], endNode),\n        dB = manhattanDistance(b[0], endNode);\n\n    if (distances[a[0].x][a[0].y] + dA === distances[b[0].x][b[0].y] + dB) {\n      return distances[a[0].x][a[0].y] < distances[b[0].x][b[0].y];\n    }\n\n    return a[1] < b[1];\n  });\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode = ensure(pq.pop()); // add the current node to the visited nodes\n\n    visited.push(currentNode); // If we found the endNode, return the shortest path to it\n\n    if (currentNode === endNode) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, endNode);\n      return [visited, shortestPath];\n    } // Get the coordinates of the nodes\n\n\n    let currentX = currentNode.x;\n    let currentY = currentNode.y; // Iterate the neighbors of the node\n\n    for (const neighbor of ensure(mazeGraph.get(pairGrid[currentX][currentY]))) {\n      // Get the coordinates of the neighbor node\n      let neighborX = neighbor[0],\n          neighborY = neighbor[1]; // Check if the coordinates are valid\n\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n) continue;\n      let nextNode = grid[neighbor[0]][neighbor[1]]; // Calculate the distance between the current node and the next node\n      // To Do: take into account the weight of the path\n\n      let currentDistance = distances[currentX][currentY] + 1; // If the distance is less than the distance in the array distances,\n      // change it and change the predecessor of the next node to be the current one\n\n      if (currentDistance < distances[neighbor[0]][neighbor[1]]) {\n        predecessor[nextNode.id] = currentNode;\n        distances[neighbor[0]][neighbor[1]] = currentDistance;\n      } // If the node is not yet visited, remove it from the heap and\n      // put it back in with its new distance as the score function\n\n\n      if (!visited.find(visitedNode => visitedNode === nextNode)) {\n        pq.remove(nextNode);\n        pq.push(nextNode);\n      }\n    }\n  }\n\n  return [visited, []];\n};\n\nconst manhattanDistance = (a, b) => {\n  return Math.abs(b.x - a.x) + Math.abs(b.y - a.y);\n};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helperFunctions/shortestPathAlgorithms/aStar.ts"],"names":["BinaryHeap","retrievePath","ensure","aStar","grid","pairGrid","mazeGraph","startNode","endNode","m","length","n","distances","i","push","j","Number","MAX_SAFE_INTEGER","x","y","predecessor","fill","id","visited","pq","a","b","dA","manhattanDistance","dB","size","currentNode","pop","shortestPath","currentX","currentY","neighbor","get","neighborX","neighborY","nextNode","currentDistance","find","visitedNode","remove","Math","abs"],"mappings":"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","sourcesContent":["import { node } from \"../usefulInterfaces\";\nimport { BinaryHeap } from \"../dataStructures/binaryHeap\";\nimport { retrievePath } from \"./retrievePath\";\nimport { ensure } from \"../ensureNotUndefined\";\n\nexport const aStar: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [number, number][]>,\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>(\n    (a: [node, number], b: [node, number]) => {\n      let dA: number = manhattanDistance(a[0], endNode),\n        dB: number = manhattanDistance(b[0], endNode);\n      if (distances[a[0].x][a[0].y] + dA === distances[b[0].x][b[0].y] + dB) {\n        return distances[a[0].x][a[0].y] < distances[b[0].x][b[0].y];\n      }\n      return a[1] < b[1];\n    }\n  );\n\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    visited.push(currentNode);\n\n    // If we found the endNode, return the shortest path to it\n    if (currentNode === endNode) {\n      // Retrieve the shortest path\n      const shortestPath = retrievePath(predecessor, startNode, endNode);\n      return [visited, shortestPath];\n    }\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentX][currentY])\n    )) {\n      // Get the coordinates of the neighbor node\n      let neighborX: number = neighbor[0],\n        neighborY: number = neighbor[1];\n\n      // Check if the coordinates are valid\n      if (neighborX < 0 || neighborX >= m || neighborY < 0 || neighborY >= n)\n        continue;\n\n      let nextNode: node = grid[neighbor[0]][neighbor[1]];\n\n      // Calculate the distance between the current node and the next node\n      // To Do: take into account the weight of the path\n      let currentDistance: number = distances[currentX][currentY] + 1;\n\n      // If the distance is less than the distance in the array distances,\n      // change it and change the predecessor of the next node to be the current one\n      if (currentDistance < distances[neighbor[0]][neighbor[1]]) {\n        predecessor[nextNode.id] = currentNode;\n        distances[neighbor[0]][neighbor[1]] = currentDistance;\n      }\n\n      // If the node is not yet visited, remove it from the heap and\n      // put it back in with its new distance as the score function\n      if (!visited.find((visitedNode) => visitedNode === nextNode)) {\n        pq.remove(nextNode);\n        pq.push(nextNode);\n      }\n    }\n  }\n  return [visited, []];\n};\n\nconst manhattanDistance: (a: node, b: node) => number = (a, b) => {\n  return Math.abs(b.x - a.x) + Math.abs(b.y - a.y);\n};\n"]},"metadata":{},"sourceType":"module"}