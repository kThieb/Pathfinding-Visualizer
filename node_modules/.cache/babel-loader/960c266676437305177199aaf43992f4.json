{"ast":null,"code":"import { BinaryHeap } from \"../binaryHeap\";\nimport { retrievePath } from \"./retrievePath\";\nexport const dijkstra = (grid, startNode, endNode) => {\n  const m = grid.length,\n        n = grid[0].length; // Initialize the distances array\n\n  const distances = [];\n\n  for (let i = 0; i < m; i++) {\n    distances.push([]);\n\n    for (let j = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0; // Initialize the predecessor array\n\n  const predecessor = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode; // Initialize the visited nodes array\n\n  let visited = []; // Initialize the directions array we will use to perform Dijkstra's algorithm\n\n  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]; //   Initialize the Binary Heap\n\n  let pq = new BinaryHeap(n => distances[n.x][n.y]);\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode = ensure(pq.pop()); // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n\n    visited.push(currentNode); // Get the coordinates of the nodes\n\n    let currentX = currentNode.x;\n    let currentY = currentNode.y; // Iterate the neighbors of the node\n\n    for (const dir of directions) {\n      // Get the coordinates of the next node\n      let nextX = currentX + dir[0];\n      let nextY = currentY + dir[1]; // Check if the coordinates are valid\n\n      if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n) {\n        let nextNode = grid[nextX][nextY]; // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n\n        if (!visited.find(currentNode => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          pq.push(nextNode);\n        } // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n\n\n        let currentDistance = distances[currentX][currentY] + 1; // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n\n        if (currentDistance < distances[nextX][nextY]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[nextX][nextY] = currentDistance;\n        } // If we found the target node then we return what we need\n\n\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrievePath(predecessor, startNode, endNode);\n          visited.shift(); // return the correct value\n\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n};\nexport const dijkstraWithWalls = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n        n = grid[0].length; // Initialize the distances array\n\n  const distances = [];\n\n  for (let i = 0; i < m; i++) {\n    distances.push([]);\n\n    for (let j = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0; // Initialize the predecessor array\n\n  const predecessor = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode; // Initialize the visited nodes array\n\n  let visited = []; //   Initialize the Binary Heap\n\n  let pq = new BinaryHeap(n => distances[n.x][n.y]);\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode = ensure(pq.pop()); // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n\n    visited.push(currentNode); // Get the coordinates of the nodes\n\n    let currentX = currentNode.x;\n    let currentY = currentNode.y; // Iterate the neighbors of the node\n\n    for (const neighbor of ensure(mazeGraph.get(pairGrid[currentX][currentY]))) {\n      // Check if the coordinates are valid\n      if (neighbor[0] >= 0 && neighbor[0] < m && neighbor[1] >= 0 && neighbor[1] < n) {\n        let nextNode = grid[neighbor[0]][neighbor[1]]; // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n\n        if (!visited.find(currentNode => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          pq.push(nextNode);\n        } // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n\n\n        let currentDistance = distances[currentX][currentY] + 1; // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n\n        if (currentDistance < distances[neighbor[0]][neighbor[1]]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[neighbor[0]][neighbor[1]] = currentDistance;\n        } // If we found the target node then we return what we need\n\n\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrievePath(predecessor, startNode, endNode);\n          visited.push(endNode);\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n}; // This function is here to ensure that a value is not undefined (especially when using arrays).\n\nfunction ensure(argument, message = \"This value was promised to be there.\") {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helper_functions/shortestPathAlgorithms/dijkstra.ts"],"names":["BinaryHeap","retrievePath","dijkstra","grid","startNode","endNode","m","length","n","distances","i","push","j","Number","MAX_SAFE_INTEGER","x","y","predecessor","fill","id","visited","directions","pq","size","currentNode","ensure","pop","currentX","currentY","dir","nextX","nextY","nextNode","find","remove","currentDistance","shortestPath","shift","dijkstraWithWalls","pairGrid","mazeGraph","neighbor","get","argument","message","undefined","TypeError"],"mappings":"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","sourcesContent":["import { node } from \"../usefulInterfaces\";\nimport { BinaryHeap } from \"../binaryHeap\";\nimport { retrievePath } from \"./retrievePath\";\n\nexport const dijkstra: (\n  grid: node[][],\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  // Initialize the directions array we will use to perform Dijkstra's algorithm\n  const directions: number[][] = [\n    [0, 1],\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n  ];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>(\n    (n: node) => distances[n.x][n.y]\n  );\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n    visited.push(currentNode);\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const dir of directions) {\n      // Get the coordinates of the next node\n      let nextX: number = currentX + dir[0];\n      let nextY: number = currentY + dir[1];\n\n      // Check if the coordinates are valid\n      if (nextX >= 0 && nextX < m && nextY >= 0 && nextY < n) {\n        let nextNode: node = grid[nextX][nextY];\n\n        // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n        if (!visited.find((currentNode) => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          pq.push(nextNode);\n        }\n\n        // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n        let currentDistance: number = distances[currentX][currentY] + 1;\n\n        // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n        if (currentDistance < distances[nextX][nextY]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[nextX][nextY] = currentDistance;\n        }\n\n        // If we found the target node then we return what we need\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrievePath(\n            predecessor,\n            startNode,\n            endNode\n          );\n          visited.shift();\n          // return the correct value\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n};\n\nexport const dijkstraWithWalls: (\n  grid: node[][],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [number, number][]>,\n  startNode: node,\n  targetNode: node\n) => [node[], node[]] = (grid, pairGrid, mazeGraph, startNode, endNode) => {\n  const m = grid.length,\n    n = grid[0].length;\n\n  // Initialize the distances array\n  const distances: number[][] = [];\n  for (let i: number = 0; i < m; i++) {\n    distances.push([]);\n    for (let j: number = 0; j < n; j++) {\n      distances[i].push(Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  distances[startNode.x][startNode.y] = 0;\n\n  // Initialize the predecessor array\n  const predecessor: node[] = [];\n  predecessor.fill(startNode, 0, m * n);\n  predecessor[startNode.id] = startNode;\n\n  // Initialize the visited nodes array\n  let visited: node[] = [];\n\n  //   Initialize the Binary Heap\n  let pq: BinaryHeap<node> = new BinaryHeap<node>(\n    (n: node) => distances[n.x][n.y]\n  );\n  pq.push(startNode);\n\n  while (pq.size() > 0) {\n    let currentNode: node = ensure(pq.pop());\n\n    // add the current node to the visited nodes\n    // currentNode.isVisited = true;\n    visited.push(currentNode);\n\n    // Get the coordinates of the nodes\n    let currentX: number = currentNode.x;\n    let currentY: number = currentNode.y;\n\n    // Iterate the neighbors of the node\n    for (const neighbor of ensure(\n      mazeGraph.get(pairGrid[currentX][currentY])\n    )) {\n      // Check if the coordinates are valid\n      if (\n        neighbor[0] >= 0 &&\n        neighbor[0] < m &&\n        neighbor[1] >= 0 &&\n        neighbor[1] < n\n      ) {\n        let nextNode: node = grid[neighbor[0]][neighbor[1]];\n\n        // If the node is not yet visited, remove it from the heap and\n        // put it back in with its new distance as the score function\n        if (!visited.find((currentNode) => currentNode === nextNode)) {\n          pq.remove(nextNode);\n          pq.push(nextNode);\n        }\n\n        // Calculate the distance between the current node and the next node\n        // To Do: take into account the weight of the path\n        let currentDistance: number = distances[currentX][currentY] + 1;\n\n        // If the distance is less than the distance in the array distances,\n        // change it and change the predecessor of the next node to be the current one\n        if (currentDistance < distances[neighbor[0]][neighbor[1]]) {\n          predecessor[nextNode.id] = currentNode;\n          distances[neighbor[0]][neighbor[1]] = currentDistance;\n        }\n\n        // If we found the target node then we return what we need\n        if (nextNode === endNode) {\n          // Retrieve the shortest path\n          const shortestPath = retrievePath(predecessor, startNode, endNode);\n          visited.push(endNode);\n          return [visited, shortestPath];\n        }\n      }\n    }\n  }\n\n  return [visited, []];\n};\n\n// This function is here to ensure that a value is not undefined (especially when using arrays).\nfunction ensure<T>(\n  argument: T | undefined | null,\n  message: string = \"This value was promised to be there.\"\n): T {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}\n"]},"metadata":{},"sourceType":"module"}