{"ast":null,"code":"const createMazeGraph = (n, grid) => {\n  // Create the grid\n  let pairGrid = [];\n\n  for (let i = 0; i < n; i++) {\n    let pairRow = [];\n\n    for (let j = 0; j < n; j++) {\n      let currentNode = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n\n    pairGrid.push(pairRow);\n  } // Create the maze graph\n\n\n  let mazeGraph = new Map();\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      mazeGraph.set(pairGrid[i][j], []);\n    }\n  }\n\n  return [pairGrid, mazeGraph];\n};\n\nexport const generateSquareMazeGraph = (n, grid, symmetry) => {\n  let [pairGrid, mazeGraph] = createMazeGraph(n, grid);\n  console.log(mazeGraph); // 1. Choose the initial cell, mark it as visited and push it to the stack\n\n  let startNode = pairGrid[0][0];\n  let stack = [startNode];\n  let visited = new Set([startNode]); // 2. While the stack is not empty\n\n  while (stack.length > 0) {\n    var _stack$pop;\n\n    // 1.1 Pop a cell from the stack and make it a current cell\n    let currentNode = (_stack$pop = stack.pop()) !== null && _stack$pop !== void 0 ? _stack$pop : [0, 0]; // 1.2 Get the symmetric of the currentNode\n\n    let symmetricNode = pairGrid[n - 1 - currentNode[0]][n - 1 - currentNode[1]];\n    let currentNonVisitedNeighbors = getSquareNeighbors(pairGrid, currentNode, n, visited, symmetry); // 2. If the current cell has any neighbours which have not been visited\n\n    if (currentNonVisitedNeighbors.length > 0) {\n      var _mazeGraph$get, _mazeGraph$get2;\n\n      // 1. Push the current cell to the stack\n      stack.push(currentNode); // 2.1 Choose one of the unvisited neighbours\n\n      let randIndex = Math.floor(Math.random() * currentNonVisitedNeighbors.length);\n      let neighborNode = currentNonVisitedNeighbors[randIndex]; // 2.2 Get the symmetric of the chosen node\n\n      let neighborSymmetricNode = [0, 0];\n\n      if (symmetry) {\n        neighborSymmetricNode = pairGrid[n - 1 - neighborNode[0]][n - 1 - neighborNode[1]];\n      } // 3.1 Remove the wall between the current cell and the chosen cell\n\n\n      let currentNodeNeighbors = (_mazeGraph$get = mazeGraph.get(currentNode)) !== null && _mazeGraph$get !== void 0 ? _mazeGraph$get : [];\n      currentNodeNeighbors.push(neighborNode);\n      mazeGraph.set(currentNode, currentNodeNeighbors);\n      let neighborNodeNeighbors = (_mazeGraph$get2 = mazeGraph.get(neighborNode)) !== null && _mazeGraph$get2 !== void 0 ? _mazeGraph$get2 : [];\n      neighborNodeNeighbors.push(currentNode);\n      mazeGraph.set(neighborNode, neighborNodeNeighbors); // 3.2 Remove the wall between the current symmetric cell and the chosen cell\n\n      if (symmetry) {\n        var _mazeGraph$get3, _mazeGraph$get4;\n\n        let symmetricNodeNeighbors = (_mazeGraph$get3 = mazeGraph.get(symmetricNode)) !== null && _mazeGraph$get3 !== void 0 ? _mazeGraph$get3 : [];\n        symmetricNodeNeighbors.push(neighborSymmetricNode);\n        mazeGraph.set(symmetricNode, symmetricNodeNeighbors);\n        let neighborSymmetricNodeNeighbors = (_mazeGraph$get4 = mazeGraph.get(neighborSymmetricNode)) !== null && _mazeGraph$get4 !== void 0 ? _mazeGraph$get4 : [];\n        neighborSymmetricNodeNeighbors.push(symmetricNode);\n        mazeGraph.set(neighborSymmetricNode, neighborSymmetricNodeNeighbors);\n      } // 4. Mark the chosen cell as visited and push it to the stack\n\n\n      visited.add(neighborNode);\n      stack.push(neighborNode);\n    }\n  }\n\n  return [pairGrid, mazeGraph];\n};\n\nconst getSquareNeighbors = (pairGrid, currentNode, n, visited, symmetry) => {\n  const directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n  let neighbors = [];\n  let neighborX = -1;\n  let neighborY = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n\n    if (neighborX >= 0 && neighborY >= 0) {\n      if (symmetry) {\n        if (!(neighborX + neighborY < n)) continue;\n      } else if (neighborX >= n || neighborY >= n) continue;\n\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n\n  let newNeighbors = [];\n\n  for (let i = 0; i < neighbors.length; i++) {\n    if (!visited.has(neighbors[i])) {\n      newNeighbors.push(neighbors[i]);\n    }\n  }\n\n  return newNeighbors;\n};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/simple-visualizer/src/helper_functions/mazeGenerators/squareMazeGenerator.ts"],"names":["createMazeGraph","n","grid","pairGrid","i","pairRow","j","currentNode","push","x","y","mazeGraph","Map","set","generateSquareMazeGraph","symmetry","console","log","startNode","stack","visited","Set","length","pop","symmetricNode","currentNonVisitedNeighbors","getSquareNeighbors","randIndex","Math","floor","random","neighborNode","neighborSymmetricNode","currentNodeNeighbors","get","neighborNodeNeighbors","symmetricNodeNeighbors","neighborSymmetricNodeNeighbors","add","directions","neighbors","neighborX","neighborY","dir","newNeighbors","has"],"mappings":"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","sourcesContent":["import { node } from \"../usefulInterfaces\";\n\nconst createMazeGraph: (\n  n: number,\n  grid: node[][]\n) => [[number, number][][], Map<[number, number], [number, number][]>] = (\n  n,\n  grid\n) => {\n  // Create the grid\n  let pairGrid: [number, number][][] = [];\n  for (let i: number = 0; i < n; i++) {\n    let pairRow: [number, number][] = [];\n    for (let j: number = 0; j < n; j++) {\n      let currentNode: node = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n    pairGrid.push(pairRow);\n  }\n\n  // Create the maze graph\n  let mazeGraph: Map<[number, number], [number, number][]> = new Map();\n  for (let i: number = 0; i < n; i++) {\n    for (let j: number = 0; j < n; j++) {\n      mazeGraph.set(pairGrid[i][j], []);\n    }\n  }\n  return [pairGrid, mazeGraph];\n};\n\nexport const generateSquareMazeGraph: (\n  n: number,\n  grid: node[][],\n  symmetry: boolean\n) => [[number, number][][], Map<[number, number], [number, number][]>] = (\n  n,\n  grid,\n  symmetry\n) => {\n  let [pairGrid, mazeGraph] = createMazeGraph(n, grid);\n  console.log(mazeGraph);\n  // 1. Choose the initial cell, mark it as visited and push it to the stack\n  let startNode: [number, number] = pairGrid[0][0];\n  let stack: [number, number][] = [startNode];\n  let visited = new Set([startNode]);\n\n  // 2. While the stack is not empty\n  while (stack.length > 0) {\n    // 1.1 Pop a cell from the stack and make it a current cell\n    let currentNode: [number, number] = stack.pop() ?? [0, 0];\n\n    // 1.2 Get the symmetric of the currentNode\n    let symmetricNode: [number, number] =\n      pairGrid[n - 1 - currentNode[0]][n - 1 - currentNode[1]];\n\n    let currentNonVisitedNeighbors: [number, number][] = getSquareNeighbors(\n      pairGrid,\n      currentNode,\n      n,\n      visited,\n      symmetry\n    );\n    // 2. If the current cell has any neighbours which have not been visited\n    if (currentNonVisitedNeighbors.length > 0) {\n      // 1. Push the current cell to the stack\n      stack.push(currentNode);\n\n      // 2.1 Choose one of the unvisited neighbours\n      let randIndex: number = Math.floor(\n        Math.random() * currentNonVisitedNeighbors.length\n      );\n      let neighborNode: [number, number] =\n        currentNonVisitedNeighbors[randIndex];\n\n      // 2.2 Get the symmetric of the chosen node\n      let neighborSymmetricNode: [number, number] = [0, 0];\n      if (symmetry) {\n        neighborSymmetricNode =\n          pairGrid[n - 1 - neighborNode[0]][n - 1 - neighborNode[1]];\n      }\n\n      // 3.1 Remove the wall between the current cell and the chosen cell\n      let currentNodeNeighbors: [number, number][] =\n        mazeGraph.get(currentNode) ?? [];\n      currentNodeNeighbors.push(neighborNode);\n      mazeGraph.set(currentNode, currentNodeNeighbors);\n\n      let neighborNodeNeighbors: [number, number][] =\n        mazeGraph.get(neighborNode) ?? [];\n      neighborNodeNeighbors.push(currentNode);\n      mazeGraph.set(neighborNode, neighborNodeNeighbors);\n\n      // 3.2 Remove the wall between the current symmetric cell and the chosen cell\n      if (symmetry) {\n        let symmetricNodeNeighbors: [number, number][] =\n          mazeGraph.get(symmetricNode) ?? [];\n\n        symmetricNodeNeighbors.push(neighborSymmetricNode);\n        mazeGraph.set(symmetricNode, symmetricNodeNeighbors);\n\n        let neighborSymmetricNodeNeighbors: [number, number][] =\n          mazeGraph.get(neighborSymmetricNode) ?? [];\n        neighborSymmetricNodeNeighbors.push(symmetricNode);\n        mazeGraph.set(neighborSymmetricNode, neighborSymmetricNodeNeighbors);\n      }\n\n      // 4. Mark the chosen cell as visited and push it to the stack\n      visited.add(neighborNode);\n      stack.push(neighborNode);\n    }\n  }\n  return [pairGrid, mazeGraph];\n};\n\nconst getSquareNeighbors: (\n  grid: [number, number][][],\n  currentNode: [number, number],\n  n: number,\n  visited: any,\n  symmetry: boolean\n) => [number, number][] = (pairGrid, currentNode, n, visited, symmetry) => {\n  const directions = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n\n    if (neighborX >= 0 && neighborY >= 0) {\n      if (symmetry) {\n        if (!(neighborX + neighborY < n)) continue;\n      } else if (neighborX >= n || neighborY >= n) continue;\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n\n  let newNeighbors: [number, number][] = [];\n  for (let i: number = 0; i < neighbors.length; i++) {\n    if (!visited.has(neighbors[i])) {\n      newNeighbors.push(neighbors[i]);\n    }\n  }\n  return newNeighbors;\n};\n"]},"metadata":{},"sourceType":"module"}