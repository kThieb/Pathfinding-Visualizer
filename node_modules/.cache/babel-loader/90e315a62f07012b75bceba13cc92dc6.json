{"ast":null,"code":"// TODO: Refactor the code to use the different key-values pair as the nodes get changed when there is a setGrid that is applied\nconst createMazeGraph = (rowLength, columnLength, grid) => {\n  let pairGrid = [];\n\n  for (let i = 0; i < columnLength; i++) {\n    let pairRow = [];\n\n    for (let j = 0; j < rowLength; j++) {\n      let currentNode = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n\n    pairGrid.push(pairRow);\n  } // Create the maze graph\n\n\n  let mazeGraph = new Map();\n\n  for (let i = 0; i < columnLength; i++) {\n    for (let j = 0; j < rowLength; j++) {\n      mazeGraph.set(pairGrid[i][j], []);\n    }\n  }\n\n  return [pairGrid, mazeGraph];\n};\n\nexport const createEmptyMazeGraph = (rowLength, columnLength, grid) => {\n  let pairGrid = [];\n\n  for (let i = 0; i < columnLength; i++) {\n    let pairRow = [];\n\n    for (let j = 0; j < rowLength; j++) {\n      let currentNode = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n\n    pairGrid.push(pairRow);\n  } // Create the maze graph\n\n\n  let mazeGraph = new Map();\n\n  for (let i = 0; i < columnLength; i++) {\n    for (let j = 0; j < rowLength; j++) {\n      let neighbors = getNeighborsEmpty(pairGrid, [i, j], columnLength, rowLength);\n      mazeGraph.set(pairGrid[i][j], neighbors);\n    }\n  }\n\n  return [pairGrid, mazeGraph];\n};\nexport const generateMazeGraph = (rowLength, columnLength, grid, wallsDensity) => {\n  let [pairGrid, mazeGraph] = createMazeGraph(rowLength, columnLength, grid); // I. Generate a maze where each cells is reachable (with a DFS)\n\n  let currentWallsCount = rowLength * columnLength * 4 - 2 * (rowLength - 2) - 2 * (columnLength - 2) - 8; // 1. Choose the initial cell, mark it as visited and push it to the stack\n\n  let startNode = pairGrid[0][0];\n  let stack = [startNode];\n  let visited = [startNode]; // 2. While the stack is not empty\n\n  while (stack.length > 0) {\n    // 1. Pop a cell from the stack and make it a current cell\n    let currentNode = ensure(stack.pop());\n    let currentNonVisitedNeighbors = getNeighbors(pairGrid, currentNode, rowLength, columnLength, visited); // 2. If the current cell has any neighbours which have not been visited\n\n    if (currentNonVisitedNeighbors.length > 0) {\n      // 1. Push the current cell to the stack\n      stack.push(currentNode); // 2. Choose one of the unvisited neighbours\n\n      let randIndex = Math.floor(Math.random() * currentNonVisitedNeighbors.length);\n      let neighborNode = currentNonVisitedNeighbors[randIndex]; // 3. Remove the wall between the current cell and the chosen cell\n\n      let currentNodeNeighbors = ensure(mazeGraph.get(currentNode));\n      currentNodeNeighbors.push(neighborNode);\n      mazeGraph.set(currentNode, currentNodeNeighbors);\n      let neighborNodeNeighbors = ensure(mazeGraph.get(neighborNode));\n      neighborNodeNeighbors.push(currentNode);\n      mazeGraph.set(neighborNode, neighborNodeNeighbors); // 4. Mark the chosen cell as visited and push it to the stack\n\n      visited.push(neighborNode);\n      stack.push(neighborNode); // 5. Remove 1 from the currentWallsCount\n\n      currentWallsCount--;\n    }\n  }\n\n  let maxWallsCount = currentWallsCount;\n  console.log(currentWallsCount * (1 / maxWallsCount)); // II. Remove walls until the desired density is achieved\n\n  while (currentWallsCount * (1 / maxWallsCount) > wallsDensity) {\n    let randRow = Math.floor(Math.random() * rowLength);\n    let randCol = Math.floor(Math.random() * columnLength);\n    let currentNode = [randRow, randCol];\n    let neighbors = getNeighborsII(pairGrid, currentNode, rowLength, columnLength, mazeGraph);\n    console.log(neighbors);\n    break;\n  }\n\n  return [pairGrid, mazeGraph];\n};\n\nconst getNeighbors = (pairGrid, currentNode, rowLength, columnLength, visited) => {\n  const directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n  let neighbors = [];\n  let neighborX = -1;\n  let neighborY = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n\n    if (neighborX >= 0 && neighborX < columnLength && neighborY >= 0 && neighborY < rowLength && !visited.includes(pairGrid[neighborX][neighborY])) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n\n  return neighbors;\n};\n\nexport const getNeighborsEmpty = (pairGrid, currentNode, columnLength, rowLength) => {\n  const directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n  let neighbors = [];\n  let neighborX = -1;\n  let neighborY = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n\n    if (neighborX >= 0 && neighborX < columnLength && neighborY >= 0 && neighborY < rowLength) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n\n  return neighbors;\n};\n\nconst getNeighborsII = (pairGrid, currentNode, rowLength, columnLength, mazeGraph) => {\n  const directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n  let neighbors = [];\n  let neighborX = -1;\n  let neighborY = -1;\n\n  for (const dir of directions) {\n    var _mazeGraph$get;\n\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n\n    if (neighborX >= 0 && neighborX < columnLength && neighborY >= 0 && neighborY < rowLength && !((_mazeGraph$get = mazeGraph.get(currentNode)) === null || _mazeGraph$get === void 0 ? void 0 : _mazeGraph$get.includes([neighborX, neighborY]))) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n\n  return neighbors;\n};\n\nfunction ensure(argument, message = \"This value was promised to be there.\") {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/simple-visualizer/src/helper_functions/mazeGenerators/mazeGraph.ts"],"names":["createMazeGraph","rowLength","columnLength","grid","pairGrid","i","pairRow","j","currentNode","push","x","y","mazeGraph","Map","set","createEmptyMazeGraph","neighbors","getNeighborsEmpty","generateMazeGraph","wallsDensity","currentWallsCount","startNode","stack","visited","length","ensure","pop","currentNonVisitedNeighbors","getNeighbors","randIndex","Math","floor","random","neighborNode","currentNodeNeighbors","get","neighborNodeNeighbors","maxWallsCount","console","log","randRow","randCol","getNeighborsII","directions","neighborX","neighborY","dir","includes","argument","message","undefined","TypeError"],"mappings":"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","sourcesContent":["import { node } from \"../usefulInterfaces\";\n\n// TODO: Refactor the code to use the different key-values pair as the nodes get changed when there is a setGrid that is applied\n\nconst createMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][]\n) => [[number, number][][], Map<[number, number], [number, number][]>] = (\n  rowLength,\n  columnLength,\n  grid\n) => {\n  let pairGrid: [number, number][][] = [];\n  for (let i: number = 0; i < columnLength; i++) {\n    let pairRow: [number, number][] = [];\n    for (let j: number = 0; j < rowLength; j++) {\n      let currentNode: node = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n    pairGrid.push(pairRow);\n  }\n\n  // Create the maze graph\n  let mazeGraph: Map<[number, number], [number, number][]> = new Map();\n  for (let i: number = 0; i < columnLength; i++) {\n    for (let j: number = 0; j < rowLength; j++) {\n      mazeGraph.set(pairGrid[i][j], []);\n    }\n  }\n  return [pairGrid, mazeGraph];\n};\n\nexport const createEmptyMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][]\n) => [[number, number][][], Map<[number, number], [number, number][]>] = (\n  rowLength,\n  columnLength,\n  grid\n) => {\n  let pairGrid: [number, number][][] = [];\n  for (let i: number = 0; i < columnLength; i++) {\n    let pairRow: [number, number][] = [];\n    for (let j: number = 0; j < rowLength; j++) {\n      let currentNode: node = grid[i][j];\n      pairRow.push([currentNode.x, currentNode.y]);\n    }\n    pairGrid.push(pairRow);\n  }\n  // Create the maze graph\n  let mazeGraph: Map<[number, number], [number, number][]> = new Map();\n  for (let i: number = 0; i < columnLength; i++) {\n    for (let j: number = 0; j < rowLength; j++) {\n      let neighbors: [number, number][] = getNeighborsEmpty(\n        pairGrid,\n        [i, j],\n        columnLength,\n        rowLength\n      );\n      mazeGraph.set(pairGrid[i][j], neighbors);\n    }\n  }\n  return [pairGrid, mazeGraph];\n};\n\nexport const generateMazeGraph: (\n  rowLength: number,\n  columnLength: number,\n  grid: node[][],\n  wallsDensity: number\n  // verticalSymetry: boolean,\n  // centralSymetry: boolean\n) => [[number, number][][], Map<[number, number], [number, number][]>] = (\n  rowLength,\n  columnLength,\n  grid,\n  wallsDensity\n) => {\n  let [pairGrid, mazeGraph] = createMazeGraph(rowLength, columnLength, grid);\n\n  // I. Generate a maze where each cells is reachable (with a DFS)\n  let currentWallsCount: number =\n    rowLength * columnLength * 4 -\n    2 * (rowLength - 2) -\n    2 * (columnLength - 2) -\n    8;\n\n  // 1. Choose the initial cell, mark it as visited and push it to the stack\n  let startNode: [number, number] = pairGrid[0][0];\n  let stack: [number, number][] = [startNode];\n  let visited: [number, number][] = [startNode];\n\n  // 2. While the stack is not empty\n  while (stack.length > 0) {\n    // 1. Pop a cell from the stack and make it a current cell\n    let currentNode: [number, number] = ensure(stack.pop());\n    let currentNonVisitedNeighbors: [number, number][] = getNeighbors(\n      pairGrid,\n      currentNode,\n      rowLength,\n      columnLength,\n      visited\n    );\n    // 2. If the current cell has any neighbours which have not been visited\n    if (currentNonVisitedNeighbors.length > 0) {\n      // 1. Push the current cell to the stack\n      stack.push(currentNode);\n\n      // 2. Choose one of the unvisited neighbours\n      let randIndex: number = Math.floor(\n        Math.random() * currentNonVisitedNeighbors.length\n      );\n      let neighborNode: [number, number] =\n        currentNonVisitedNeighbors[randIndex];\n\n      // 3. Remove the wall between the current cell and the chosen cell\n      let currentNodeNeighbors: [number, number][] = ensure(\n        mazeGraph.get(currentNode)\n      );\n      currentNodeNeighbors.push(neighborNode);\n      mazeGraph.set(currentNode, currentNodeNeighbors);\n\n      let neighborNodeNeighbors: [number, number][] = ensure(\n        mazeGraph.get(neighborNode)\n      );\n      neighborNodeNeighbors.push(currentNode);\n      mazeGraph.set(neighborNode, neighborNodeNeighbors);\n\n      // 4. Mark the chosen cell as visited and push it to the stack\n      visited.push(neighborNode);\n      stack.push(neighborNode);\n\n      // 5. Remove 1 from the currentWallsCount\n      currentWallsCount--;\n    }\n  }\n\n  let maxWallsCount: number = currentWallsCount;\n  console.log(currentWallsCount * (1 / maxWallsCount));\n  // II. Remove walls until the desired density is achieved\n  while (currentWallsCount * (1 / maxWallsCount) > wallsDensity) {\n    let randRow: number = Math.floor(Math.random() * rowLength);\n    let randCol: number = Math.floor(Math.random() * columnLength);\n    let currentNode: [number, number] = [randRow, randCol];\n    let neighbors: [number, number][] = getNeighborsII(\n      pairGrid,\n      currentNode,\n      rowLength,\n      columnLength,\n      mazeGraph\n    );\n    console.log(neighbors);\n    break;\n  }\n  return [pairGrid, mazeGraph];\n};\n\nconst getNeighbors: (\n  grid: [number, number][][],\n  currentNode: [number, number],\n  rowLength: number,\n  columnLength: number,\n  visited: [number, number][]\n) => [number, number][] = (\n  pairGrid,\n  currentNode,\n  rowLength,\n  columnLength,\n  visited\n) => {\n  const directions = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength &&\n      !visited.includes(pairGrid[neighborX][neighborY])\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n\nexport const getNeighborsEmpty: (\n  pairGrid: [number, number][][],\n  currentNode: [number, number],\n  columnLength: number,\n  rowLength: number\n) => [number, number][] = (pairGrid, currentNode, columnLength, rowLength) => {\n  const directions = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n\nconst getNeighborsII: (\n  grid: [number, number][][],\n  currentNode: [number, number],\n  rowLength: number,\n  columnLength: number,\n  mazeGraph: Map<[number, number], [number, number][]>\n) => [number, number][] = (\n  pairGrid,\n  currentNode,\n  rowLength,\n  columnLength,\n  mazeGraph\n) => {\n  const directions = [\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n  ];\n\n  let neighbors: [number, number][] = [];\n  let neighborX: number = -1;\n  let neighborY: number = -1;\n\n  for (const dir of directions) {\n    neighborX = currentNode[0] + dir[0];\n    neighborY = currentNode[1] + dir[1];\n    if (\n      neighborX >= 0 &&\n      neighborX < columnLength &&\n      neighborY >= 0 &&\n      neighborY < rowLength &&\n      !mazeGraph.get(currentNode)?.includes([neighborX, neighborY])\n    ) {\n      neighbors.push(pairGrid[neighborX][neighborY]);\n    }\n  }\n  return neighbors;\n};\n\nfunction ensure<T>(\n  argument: T | undefined | null,\n  message: string = \"This value was promised to be there.\"\n): T {\n  if (argument === undefined || argument === null) {\n    throw new TypeError(message);\n  }\n\n  return argument;\n}\n"]},"metadata":{},"sourceType":"module"}