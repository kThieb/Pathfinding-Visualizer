{"ast":null,"code":"// This function (Not a React Component!) is made to initialize the grid rendered in the App component.\nexport const constructGrid = (numberOfRow, numberOfColumn, startNode, endNode, multipleTargets) => {\n  let result = [];\n\n  for (let i = 0; i < numberOfColumn; i++) {\n    let currentRow = [];\n\n    for (let j = 0; j < numberOfRow; j++) {\n      let currentNode = {\n        id: i + j * numberOfColumn,\n        x: i,\n        y: j,\n        isStart: false,\n        hasCheese: false,\n        isVisited: false,\n        isShortestPath: false,\n        successorPosition: \"\"\n      };\n      currentRow.push(currentNode);\n    }\n\n    result.push(currentRow);\n  }\n\n  result[startNode[0]][startNode[1]].isStart = true;\n  result[endNode[0]][endNode[1]].hasCheese = true;\n  let targetList;\n  if (multipleTargets) [result, targetList] = piecesOfCheese(result, startNode, endNode, 10);\n  return [result, result[startNode[0]][startNode[1]], result[endNode[0]][endNode[1]]];\n};\n\nconst piecesOfCheese = (grid, startNode, endNode, cheeseNum) => {\n  const n = grid.length,\n        m = grid[0].length;\n  const targetList = [grid[endNode[0]][endNode][1]];\n  let visited = new Array(n);\n\n  for (let i = 0; i < n; ++i) {\n    visited[i] = new Array(m);\n  }\n\n  for (let i = 0; i < n; ++i) {\n    for (let j = 0; j < m; ++j) {\n      visited[i][j] = false;\n    }\n  }\n\n  visited[startNode[0]][startNode[1]] = true;\n  visited[endNode[0]][endNode[1]] = true;\n\n  for (let k = 0; k < cheeseNum; k++) {\n    let i = -1,\n        j = -1;\n\n    do {\n      i = Math.floor(Math.random() * n);\n      j = Math.floor(Math.random() * m);\n    } while (visited[i][j]);\n\n    visited[i][j] = true;\n    grid[i][j].hasCheese = true;\n  }\n\n  return [grid, targetList];\n};\n\nexport const reconstructGridWithCheese = (grid, startNode, endNode, targetList) => {\n  return [grid, startNode, endNode];\n};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helperFunctions/constructGrid.ts"],"names":["constructGrid","numberOfRow","numberOfColumn","startNode","endNode","multipleTargets","result","i","currentRow","j","currentNode","id","x","y","isStart","hasCheese","isVisited","isShortestPath","successorPosition","push","targetList","piecesOfCheese","grid","cheeseNum","n","length","m","visited","Array","k","Math","floor","random","reconstructGridWithCheese"],"mappings":"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","sourcesContent":["import { node } from \"./usefulInterfaces\";\n\n// This function (Not a React Component!) is made to initialize the grid rendered in the App component.\nexport const constructGrid: (\n  numberOfRows: number,\n  numberOfColumn: number,\n  startNode: [number, number],\n  endNode: [number, number],\n  multipleTargets: boolean\n) => [node[][], node, node] = (\n  numberOfRow,\n  numberOfColumn,\n  startNode,\n  endNode,\n  multipleTargets\n) => {\n  let result: node[][] = [];\n  for (let i: number = 0; i < numberOfColumn; i++) {\n    let currentRow: node[] = [];\n    for (let j: number = 0; j < numberOfRow; j++) {\n      let currentNode: node = {\n        id: i + j * numberOfColumn,\n        x: i,\n        y: j,\n        isStart: false,\n        hasCheese: false,\n        isVisited: false,\n        isShortestPath: false,\n        successorPosition: \"\",\n      };\n      currentRow.push(currentNode);\n    }\n    result.push(currentRow);\n  }\n  result[startNode[0]][startNode[1]].isStart = true;\n  result[endNode[0]][endNode[1]].hasCheese = true;\n  let targetList: node[];\n  if (multipleTargets)\n    [result, targetList] = piecesOfCheese(result, startNode, endNode, 10);\n  return [\n    result,\n    result[startNode[0]][startNode[1]],\n    result[endNode[0]][endNode[1]],\n  ];\n};\n\nconst piecesOfCheese: (\n  grid: node[][],\n  startNode: [number, number],\n  endNode: [number, number],\n  cheeseNum: number\n) => [node[][], node[]] = (grid, startNode, endNode, cheeseNum) => {\n  const n: number = grid.length,\n    m: number = grid[0].length;\n  const targetList = [grid[endNode[0]][endNode][1]];\n  let visited: boolean[][] = new Array(n);\n  for (let i: number = 0; i < n; ++i) {\n    visited[i] = new Array(m);\n  }\n  for (let i: number = 0; i < n; ++i) {\n    for (let j: number = 0; j < m; ++j) {\n      visited[i][j] = false;\n    }\n  }\n\n  visited[startNode[0]][startNode[1]] = true;\n  visited[endNode[0]][endNode[1]] = true;\n  for (let k: number = 0; k < cheeseNum; k++) {\n    let i = -1,\n      j = -1;\n    do {\n      i = Math.floor(Math.random() * n);\n      j = Math.floor(Math.random() * m);\n    } while (visited[i][j]);\n    visited[i][j] = true;\n    grid[i][j].hasCheese = true;\n  }\n  return [grid, targetList];\n};\n\nexport const reconstructGridWithCheese: (\n  grid: node[][],\n  startNode: node,\n  endNode: node,\n  targetList: node[]\n) => [node[][], node, node] = (grid, startNode, endNode, targetList) => {\n  return [grid, startNode, endNode];\n};\n"]},"metadata":{},"sourceType":"module"}