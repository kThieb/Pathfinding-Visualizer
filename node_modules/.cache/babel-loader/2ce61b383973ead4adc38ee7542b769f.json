{"ast":null,"code":"import { ensure } from \"../ensureNotUndefined\";\nexport const retrievePath = (predecessor, startNode, endNode) => {\n  let shortestPath = [endNode];\n  let current = endNode;\n\n  while (current.x !== startNode.x || current.y !== startNode.y) {\n    current = predecessor[current.id];\n    shortestPath.unshift(current);\n  }\n\n  return shortestPath;\n};\nexport const retrieveTwoEndedPath = (predecessor, successor, middleNode, startNode, endNode) => {\n  let shortestPath = [middleNode];\n  let current = middleNode;\n\n  while (current.x !== startNode.x || current.y !== startNode.y) {\n    current = predecessor[current.id];\n    shortestPath.unshift(current);\n  }\n\n  current = middleNode;\n\n  while (current.x !== endNode.x || current.y !== endNode.y) {\n    current = successor[current.id];\n    shortestPath.push(current);\n  }\n\n  return shortestPath;\n};\nexport const retrieveDistance = (path, pairGrid, mazeGraph) => {\n  let distance = 0;\n\n  for (let i = 1; i < path.length; i++) {\n    let predNode = path[i - 1],\n        currNode = path[i];\n    let pred = pairGrid[predNode.x][predNode.y],\n        curr = pairGrid[currNode.x][currNode.y];\n    let neighbor = ensure(ensure(mazeGraph.get(pred)).find(neighborEdge => neighborEdge[0][0] === curr[0] && neighborEdge[0][1] === curr[1]));\n    distance += neighbor[1];\n  }\n\n  return distance;\n};","map":{"version":3,"sources":["/home/kevin/Documents/Projects/Simple-Visualizer/pathfinding-visualizer/src/helperFunctions/shortestPathAlgorithms/retrievePath.ts"],"names":["ensure","retrievePath","predecessor","startNode","endNode","shortestPath","current","x","y","id","unshift","retrieveTwoEndedPath","successor","middleNode","push","retrieveDistance","path","pairGrid","mazeGraph","distance","i","length","predNode","currNode","pred","curr","neighbor","get","find","neighborEdge"],"mappings":"AAAA,SAASA,MAAT,QAAuB,uBAAvB;AAGA,OAAO,MAAMC,YAIF,GAAG,CAACC,WAAD,EAAcC,SAAd,EAAyBC,OAAzB,KAAqC;AACjD,MAAIC,YAAY,GAAG,CAACD,OAAD,CAAnB;AACA,MAAIE,OAAa,GAAGF,OAApB;;AACA,SAAOE,OAAO,CAACC,CAAR,KAAcJ,SAAS,CAACI,CAAxB,IAA6BD,OAAO,CAACE,CAAR,KAAcL,SAAS,CAACK,CAA5D,EAA+D;AAC7DF,IAAAA,OAAO,GAAGJ,WAAW,CAACI,OAAO,CAACG,EAAT,CAArB;AACAJ,IAAAA,YAAY,CAACK,OAAb,CAAqBJ,OAArB;AACD;;AAED,SAAOD,YAAP;AACD,CAbM;AAeP,OAAO,MAAMM,oBAMF,GAAG,CAACT,WAAD,EAAcU,SAAd,EAAyBC,UAAzB,EAAqCV,SAArC,EAAgDC,OAAhD,KAA4D;AACxE,MAAIC,YAAY,GAAG,CAACQ,UAAD,CAAnB;AACA,MAAIP,OAAa,GAAGO,UAApB;;AACA,SAAOP,OAAO,CAACC,CAAR,KAAcJ,SAAS,CAACI,CAAxB,IAA6BD,OAAO,CAACE,CAAR,KAAcL,SAAS,CAACK,CAA5D,EAA+D;AAC7DF,IAAAA,OAAO,GAAGJ,WAAW,CAACI,OAAO,CAACG,EAAT,CAArB;AACAJ,IAAAA,YAAY,CAACK,OAAb,CAAqBJ,OAArB;AACD;;AACDA,EAAAA,OAAO,GAAGO,UAAV;;AACA,SAAOP,OAAO,CAACC,CAAR,KAAcH,OAAO,CAACG,CAAtB,IAA2BD,OAAO,CAACE,CAAR,KAAcJ,OAAO,CAACI,CAAxD,EAA2D;AACzDF,IAAAA,OAAO,GAAGM,SAAS,CAACN,OAAO,CAACG,EAAT,CAAnB;AACAJ,IAAAA,YAAY,CAACS,IAAb,CAAkBR,OAAlB;AACD;;AACD,SAAOD,YAAP;AACD,CAnBM;AAqBP,OAAO,MAAMU,gBAIF,GAAG,CAACC,IAAD,EAAOC,QAAP,EAAiBC,SAAjB,KAA+B;AAC3C,MAAIC,QAAgB,GAAG,CAAvB;;AACA,OAAK,IAAIC,CAAS,GAAG,CAArB,EAAwBA,CAAC,GAAGJ,IAAI,CAACK,MAAjC,EAAyCD,CAAC,EAA1C,EAA8C;AAC5C,QAAIE,QAAc,GAAGN,IAAI,CAACI,CAAC,GAAG,CAAL,CAAzB;AAAA,QACEG,QAAc,GAAGP,IAAI,CAACI,CAAD,CADvB;AAEA,QAAII,IAAsB,GAAGP,QAAQ,CAACK,QAAQ,CAACf,CAAV,CAAR,CAAqBe,QAAQ,CAACd,CAA9B,CAA7B;AAAA,QACEiB,IAAsB,GAAGR,QAAQ,CAACM,QAAQ,CAAChB,CAAV,CAAR,CAAqBgB,QAAQ,CAACf,CAA9B,CAD3B;AAEA,QAAIkB,QAAoC,GAAG1B,MAAM,CAC/CA,MAAM,CAACkB,SAAS,CAACS,GAAV,CAAcH,IAAd,CAAD,CAAN,CAA4BI,IAA5B,CACGC,YAAD,IACEA,YAAY,CAAC,CAAD,CAAZ,CAAgB,CAAhB,MAAuBJ,IAAI,CAAC,CAAD,CAA3B,IAAkCI,YAAY,CAAC,CAAD,CAAZ,CAAgB,CAAhB,MAAuBJ,IAAI,CAAC,CAAD,CAFjE,CAD+C,CAAjD;AAMAN,IAAAA,QAAQ,IAAIO,QAAQ,CAAC,CAAD,CAApB;AACD;;AACD,SAAOP,QAAP;AACD,CApBM","sourcesContent":["import { ensure } from \"../ensureNotUndefined\";\nimport { node } from \"../usefulInterfaces\";\n\nexport const retrievePath: (\n  predecessor: node[],\n  startNode: node,\n  endNode: node\n) => node[] = (predecessor, startNode, endNode) => {\n  let shortestPath = [endNode];\n  let current: node = endNode;\n  while (current.x !== startNode.x || current.y !== startNode.y) {\n    current = predecessor[current.id];\n    shortestPath.unshift(current);\n  }\n\n  return shortestPath;\n};\n\nexport const retrieveTwoEndedPath: (\n  predecessor: node[],\n  successor: node[],\n  middleNode: node,\n  startNode: node,\n  endNode: node\n) => node[] = (predecessor, successor, middleNode, startNode, endNode) => {\n  let shortestPath = [middleNode];\n  let current: node = middleNode;\n  while (current.x !== startNode.x || current.y !== startNode.y) {\n    current = predecessor[current.id];\n    shortestPath.unshift(current);\n  }\n  current = middleNode;\n  while (current.x !== endNode.x || current.y !== endNode.y) {\n    current = successor[current.id];\n    shortestPath.push(current);\n  }\n  return shortestPath;\n};\n\nexport const retrieveDistance: (\n  path: node[],\n  pairGrid: [number, number][][],\n  mazeGraph: Map<[number, number], [[number, number], number][]>\n) => number = (path, pairGrid, mazeGraph) => {\n  let distance: number = 0;\n  for (let i: number = 1; i < path.length; i++) {\n    let predNode: node = path[i - 1],\n      currNode: node = path[i];\n    let pred: [number, number] = pairGrid[predNode.x][predNode.y],\n      curr: [number, number] = pairGrid[currNode.x][currNode.y];\n    let neighbor: [[number, number], number] = ensure(\n      ensure(mazeGraph.get(pred)).find(\n        (neighborEdge) =>\n          neighborEdge[0][0] === curr[0] && neighborEdge[0][1] === curr[1]\n      )\n    );\n    distance += neighbor[1];\n  }\n  return distance;\n};\n"]},"metadata":{},"sourceType":"module"}